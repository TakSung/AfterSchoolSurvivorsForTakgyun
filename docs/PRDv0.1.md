# Overview  
방과후생존은 "10분 동안 아무 생각 없이 몰입하여 스트레스를 해소하는" 하이퍼 캐주얼 로그라이크 생존 게임입니다. 플레이어는 마우스 이동으로 캐릭터를 조작하며, 자동 공격으로 적을 처치하고, 레벨업을 통해 아이템을 획득하여 시너지를 조합하는 게임입니다. Python + Pygame으로 개발되며, PC 플랫폼에서 40+ FPS 성능을 목표로 합니다.

# Core Features  
## 자동 플레이 시스템
- **마우스 이동**: 마우스 커서를 따라 플레이어 자동 이동
- **자동 공격**: 시간 기반으로 가장 가까운 적을 자동 공격
- **투사체 시스템**: 다양한 발사체로 적을 처치

## 아이템 및 시너지 시스템  
- **JSON 기반 아이템**: 외부 데이터 파일로 아이템 정보 관리
- **룰 엔진 시너지**: 특정 아이템 조합 시 추가 효과 발생 (예: 축구화 + 축구공 = 15% 데미지 증가)
- **6슬롯 인벤토리**: 제한된 슬롯으로 전략적 아이템 선택 필요
- **레벨업 선택**: 레벨업 시 2개 아이템 중 1개 선택

## 보스 시스템
- **교장선생님 보스**: 1분 30초마다 등장하는 패턴 보스
- **훈화 말씀 패턴**: 알파(스턴) → 베타(광역 공격) 패턴
- **디버프 시스템**: 보스 공격 시 플레이어에게 디버프 적용 
- **미션 시스템**: 디버프 해제를 위한 특정 조건 달성 필요

## 적 AI 시스템
- **기본 적**: 단순 추격 및 공격 AI
- **상태 기반 AI**: 거리에 따른 행동 변화 (순찰/추격/공격)
- **동적 난이도**: 시간 경과에 따른 적 능력치 증가

# User Experience  
## 핵심 플레이 루프
```
게임 시작 → 마우스 이동 → 자동 공격 → 적 처치 → 경험치 획득 
→ 레벨업 → 아이템 선택 → 시너지 조합 → 보스 대응 → 성장 → 반복
```

## 사용자 여정
- **즉시 플레이 가능**: 복잡한 조작 없이 마우스만으로 게임 플레이
- **점진적 복잡도**: 기본 공격 → 아이템 선택 → 시너지 이해 → 보스 대응 순서로 학습
- **빠른 피드백**: 적 처치, 레벨업, 아이템 획득 등 즉각적인 보상 시스템

## UI/UX 고려사항
- **최소한의 UI**: 체력바, 경험치바 등 핵심 정보만 표시
- **직관적 아이템 선택**: 아이템 아이콘과 효과를 명확히 표시
- **시각적 피드백**: 데미지 숫자, 레벨업 이펙트 등으로 진행 상황 표현

# Technical Architecture  
## ECS (Entity-Component-System) 기반 설계
- **Entity Manager**: 모든 게임 객체 생명주기 관리
- **Component Registry**: Position, Health, Movement, Weapon 등 컴포넌트 관리
- **System Orchestrator**: CollisionSystem, RenderSystem, AISystem, PhysicsSystem 실행 순서 제어

## 핵심 시스템 컴포넌트
- **CollisionSystem**: 충돌감지 (초기: O(n²) 브루트포스, 확장: Spatial Partitioning)
- **RenderSystem**: 화면 렌더링 (초기: 개별 draw 호출, 확장: Sprite Group 최적화)  
- **AISystem**: 적 AI 로직 (초기: if-else 체인, 확장: Behavior Tree)
- **PhysicsSystem**: 물리 시뮬레이션 (초기: 기본 벡터 연산, 확장: Pymunk)

## 데이터 관리
- **JSON 기반 외부 데이터**: items.json, enemies.json, bosses.json, game_balance.json
- **추상화 인터페이스**: 모든 시스템을 인터페이스로 설계하여 성능 최적화 시 교체 가능
- **순수 함수 기반**: 상태와 계산 로직 분리로 테스트 용이성 확보

## 성능 목표
- **40+ FPS 유지**: 적 50마리 + 투사체 100개 환경에서
- **플랫폼 지원**: Windows, macOS
- **메모리 관리**: 30분 플레이 후 50MB 이하 메모리 증가

# Development Roadmap  
## Phase 1: 핵심 인프라 구축 (2-3주)
**목표**: ECS 프레임워크 + 테스트 환경 + 기본 게임 루프

**개발 항목**:
- ECS 프레임워크 구현 (Entity, Component, System 인터페이스)
- 게임 루프 시스템 (60fps/40fps 선택 가능)
- 기본 렌더링 시스템 (pygame 기반 단순 구현)
- 충돌감지 시스템 (브루트포스 방식 + 추상화 인터페이스)
- pytest 테스트 환경 구축
- JSON 데이터 로딩 시스템

**완료 조건**:
- 빈 게임 월드에서 40+ FPS 달성
- 모든 시스템 인터페이스 정의 완료  
- 기본 단위 테스트 프레임워크 동작

## Phase 2: 기본 게임플레이 구현 (3-4주)  
**목표**: 플레이어 조작 + 적 AI + 경험치 시스템

**개발 항목**:
- 플레이어 마우스 이동 시스템
- 자동 공격 시스템 (시간 기반)
- 기본 적 1종 + 간단 AI (추격 + 공격)
- 투사체 시스템 
- 경험치/레벨업 시스템
- 기본 UI (체력, 경험치 바)

**완료 조건**:
- 플레이어가 마우스로 이동 가능
- 적을 자동으로 공격하여 처치 가능
- 경험치 획득으로 레벨업 가능
- 적 20마리 동시 존재 시 40+ FPS 유지

## Phase 3: 아이템 시스템 구현 (2-3주)
**목표**: JSON 기반 아이템 + 룰 엔진 + 시너지

**개발 항목**:
- JSON 기반 아이템 데이터 구조
- 룰 엔진 기반 시너지 계산
- 아이템 선택 UI (레벨업 시)
- 아이템 인벤토리 시스템 (6슬롯)
- 가산 방식 효과 계산 시스템
- 아이템 시스템 단위 테스트

**완료 조건**:
- 7개 기본 아이템 구현
- 축구화+축구공 등 기본 시너지 동작
- 아이템 효과가 실시간 플레이에 반영
- 시너지 계산 로직 100% 테스트 커버리지

## Phase 4: 보스 시스템 구현 (3-4주)
**목표**: 교장선생님 보스 + 디버프 시스템

**개발 항목**:
- 보스 등장 시스템 (1분 30초 주기)
- 교장선생님 AI 패턴 (훈화 말씀 알파/베타)
- 디버프 적용 시스템
- 미션 조건 시스템 
- 보스 공격 시각적 예고 시스템
- 보스전 통합 테스트

**완료 조건**:
- 1분 30초마다 보스가 등장
- 보스 패턴이 예측 가능하게 동작
- 디버프와 미션이 올바르게 연동
- 보스 + 적 50마리 동시 존재 시 40+ FPS 유지

## Phase 5: 성능 최적화 (2-3주)
**목표**: 시스템별 성능 최적화

**개발 항목**:
- 충돌감지 시스템 → Spatial Partitioning 교체
- 렌더링 시스템 → Sprite Group 최적화
- 메모리 풀링 패턴 적용
- 성능 프로파일링 및 병목 지점 해결

## Phase 6: 콘텐츠 확장 (4-6주)
**목표**: 추가 콘텐츠 및 품질 향상

**개발 항목**:
- 추가 적 타입 (수학선생님, 국어선생님)
- 아이템 확장 (20+ 종류)
- 추가 시너지 조합
- 새로운 보스 패턴
- 사운드 이펙트 + 배경음악
- 시각 효과 개선 (파티클, 화면 흔들림)

# Logical Dependency Chain
## 기초 인프라 우선 (Phase 1)
- ECS 프레임워크가 모든 시스템의 기반이므로 최우선 개발
- 테스트 환경 구축으로 개발 품질 보장 
- 게임 루프와 렌더링 시스템으로 시각적 피드백 환경 구성

## 플레이 가능한 프로토타입 구축 (Phase 2)
- 플레이어 이동과 공격으로 기본 인터랙션 구현
- 적 AI와 충돌감지로 게임플레이 루프 완성
- 경험치 시스템으로 성장 요소 추가

## 게임의 핵심 재미 요소 구현 (Phase 3)
- 아이템 시스템이 게임의 핵심 차별화 요소
- 시너지 시스템으로 전략적 깊이 제공
- Phase 2의 기본 게임플레이 위에 구축

## 도전 요소와 변화 추가 (Phase 4)
- 보스 시스템으로 게임에 긴장감과 변화 제공
- 디버프 시스템으로 플레이어의 강력해진 능력을 균형 조정
- 기존 시스템들의 안정성이 확보된 후 구현

## 성능 및 품질 최적화 (Phase 5-6)
- 핵심 기능 완성 후 성능 최적화 진행
- 콘텐츠 확장으로 재플레이 가치 향상
- 시각적/청각적 품질 향상으로 완성도 제고

# Risks and Mitigations  
## 기술적 위험 요소
**Python + Pygame 성능 한계**
- **위험**: GIL로 인한 멀티스레딩 제한, 렌더링 성능 병목
- **완화 방안**: 게임 로직을 단일 스레드로 설계, Sprite Group + 더티 렌더링 활용, 객체 수 제한 (적 50마리, 투사체 100개)

**복잡한 시스템 최적화**
- **위험**: 초보 개발자에게 과도한 최적화 부담
- **완화 방안**: 추상화 인터페이스로 단순 구현 → 최적화 구현 교체 가능하게 설계, MVP에서는 브루트포스 방식 사용

## 개발 일정 위험 요소
**기능 범위 확장**
- **위험**: 개발 중 추가 기능 요구로 일정 지연
- **완화 방안**: Phase별 명확한 완료 조건 정의, 매주 플레이 가능한 빌드 생성으로 진행도 가시화

**밸런싱 복잡성**
- **위험**: 아이템 시너지 조합이 게임을 너무 쉽거나 어렵게 만듦
- **완화 방안**: JSON 기반 외부 데이터로 런타임 밸런스 조정 가능, 최대 효과 제한 설정 (데미지 300%, 공속 200%)

## 리소스 제약 위험
**1인 개발 한계**
- **위험**: 모든 영역을 혼자 개발하는 부담
- **완화 방안**: 단순하고 안정적인 구조 우선, 테스트 자동화로 회귀 버그 방지, 핵심 재미에 집중

**API 의존성**
- **위험**: 외부 리소스나 라이브러리 의존성
- **완화 방안**: 최소한의 외부 의존성 유지, 핵심 기능은 순수 Python으로 구현

# Appendix  
## 기술 스택
- **언어**: Python 3.13+
- **게임 엔진**: Pygame 2.6.0+
- **수학 라이브러리**: numpy 2.2.4+
- **테스팅**: pytest 8.0.0+
- **코드 품질**: ruff 0.6.0+ (린팅 + 포맷팅)
- **성능 분석**: memory-profiler

## 프로젝트 구조
```
AfterSchoolSurvivors/
├── src/
│   ├── core/          # ECS 프레임워크
│   ├── systems/       # 게임 시스템들
│   ├── components/    # ECS 컴포넌트들
│   ├── data/          # 데이터 관리
│   └── ui/            # 사용자 인터페이스
├── data/              # JSON 데이터 파일들
├── tests/             # 테스트 코드
├── assets/            # 이미지, 사운드 리소스
└── docs/              # 문서화
```

## 성능 목표
- **FPS**: 40+ FPS (적 50마리 + 투사체 100개 환경)
- **메모리**: 30분 플레이 후 50MB 이하 증가량
- **로딩 시간**: 게임 시작부터 플레이 가능까지 3초 이내
- **플랫폼**: Windows, macOS 크로스 플랫폼 지원

## 품질 지표
- **테스트 커버리지**: 핵심 게임 로직 90% 이상
- **버그 밀도**: 플레이 10분당 크래시 0건, 심각한 버그 1건 이하
- **사용자 경험**: 신규 플레이어 조작법 학습 시간 30초 이하

## 참고 문서
- [기획 PRD](./PRD.md) - 게임 컨셉 및 기획 요구사항
- [개발자 PRD](./DEV-PRD.md) - 상세 기술 설계 문서
- [게임 의존성](./game-dependency.md) - Python 라이브러리 스택  
- [아키텍트 인터뷰](./interview/25-08-07-아키텍쳐_기술_인터뷰.md) - 설계 결정 과정