# ECS 아키텍처 리팩토링 인터뷰 - 2025-08-16

## 인터뷰 개요
- **목적**: design2.md 기반 Producer-Consumer 이벤트 시스템 및 전략 패턴 적용 리팩토링 계획 수립
- **참여자**: 프로젝트 오너, 시니어 게임 아키텍트 (AI)
- **일시**: 2025-08-16

---

## Q1. 현재 코드베이스 상태 파악

**Q: 현재 프로젝트에서 가장 큰 기술적 문제점이나 불편함을 느끼는 부분은 무엇인가요?**

**A: 일단 인터페이스를 통해서 api가 있고 이를 통해서 통일된 로직이 작성되어야 하는데, 해당 부분이 없어서 디버깅 소요가 많습니다. EntityManager 에 대해서는 각 객체마다 다른 조합을 가지고 있는데, entityManager에서 모두 관리하는 것이 단일책임 원칙에도 어긋나며, 각 기능별로 응집되는 것을 방해 합니다.
또한 혼돈된 이벤트 개념과 매니저 개념이 각 계층의 경계를 무너트려 코드의 이해를 어렵게 합니다.**

### 핵심 문제점 식별:
1. **인터페이스 부재**: 통일된 API 없어 디버깅 소요 증가
2. **EntityManager 단일책임 위반**: 각 객체별 다른 조합을 하나의 클래스에서 관리
3. **기능별 응집도 저하**: 객체별 특성이 분산되어 응집성 부족
4. **이벤트/매니저 개념 혼재**: 계층 경계 불분명으로 코드 이해도 저하

---

## Q2. 리팩토링 범위 및 우선순위

**Q: design2.md에 제시된 목표 아키텍처 중에서 가장 먼저 해결하고 싶은 부분과 우선순위는?**

**A: 영향도가 가장 큰 것부터하는 것이 좋다고 생각합니다. 영향도가 큰것을 나중에 바꾸면 나중에 모든것을 바꾸어야 하기 때문에 영향도가 큰것 (예를 들면, entity 그런 다른 객체들의 참조를 받고 있는 것) 을 우선적으로 바꾸는 것이 좋다고 생각하는데, 무엇이 영향다고 크다고 판단하시나요? 그러한 기준이 있으신가요?**

### 리팩토링 접근 방식:
- **영향도 기반 우선순위**: 다른 객체들의 참조를 많이 받는 핵심 컴포넌트부터 변경
- **연쇄 변경 최소화**: 나중에 모든 것을 다시 바꾸는 상황 방지

### 현재 코드베이스 영향도 분석 결과:
1. **Component** (109개 참조) - 최고 영향도
2. **Entity** (65개 참조) - 매우 높은 영향도  
3. **System** (26개 참조) - 높은 영향도
4. **EntityManager** (20개 참조) - 중간 영향도

### 영향도 판단 기준 제시:
1. **참조 빈도**: 다른 클래스들이 import하는 횟수
2. **상속 관계**: 기본 클래스일수록 높은 영향도
3. **생명주기 관리**: 객체 생성/소멸을 담당하는 클래스
4. **인터페이스 여부**: 구체 클래스보다 추상 인터페이스가 높은 영향도

---

## Q3. 영향도 기반 리팩토링 순서 결정

**Q: 영향도 기반 리팩토링 순서 제안 및 각 Phase별 작업 기간은?**

**A: Entity -> Component → System 이 순서입니다.
Phase 4 는 System 구현체 및 Event, Strategy 패턴 적용 인가요? 자세히 어떤 뜻인가요?**

### 올바른 영향도 순서:
1. **Entity** (65개 참조) - 최우선: 모든 객체의 기반
2. **Component** (109개 참조) - 두 번째: Entity에 의존 
3. **System** (26개 참조) - 세 번째: Component와 Entity 사용
4. **EntityManager** (20개 참조) - 네 번째: 상위 객체들 관리

### Phase 4 명확화 요청:
- System 구현체란 구체적으로 무엇을 의미하는지?
- Event 시스템과 Strategy 패턴 적용의 상세 범위는?

---

## Q4. 세분화된 리팩토링 계획

**Q: Phase 4 세분화 및 시스템별 영향도 기반 순서는?**

**A: 단계를 세분화 해서 진행하길 원합니다. Event/Strategy 중에는 event 먼저 끝내고 strategy 를 진행합니다. 그리고 각 시스템들 중에도 영향도가 큰 시스템이 있는데요.(예를들명 좌표변환시스템) 영향도가 큰 시스템부터 하나하나 변경해 나가길 원합니다.**

### 세분화된 Phase 계획:
- **Phase 4A**: System 인터페이스 변경 (entity_manager 파라미터 제거)
- **Phase 4B**: Event 시스템 먼저 적용 (SharedEventQueue 기반)
- **Phase 4C**: Strategy 패턴 나중에 적용
- **시스템별 우선순위**: 영향도 큰 시스템(좌표변환시스템 등)부터 단계적 변경

---

## Q5. 시스템별 영향도 및 작업 기간 추정

**Q: 각 Phase별 작업 기간과 좌표변환시스템 우선순위는?**

**A: 작업 기간은 적당히 산정해 주세요. phase 4 중에서는 좌표변환시스템을 가장 먼저 변경하는게 좋다고 생각합니다.**

### 시스템별 영향도 분석 결과:
1. **CoordinateManager/좌표변환시스템** (58개 참조) - 최고 영향도
2. **RenderSystem** (2개 참조) - 낮은 영향도  
3. **CollisionSystem** (2개 참조) - 낮은 영향도
4. **CameraSystem, PlayerMovementSystem** (1개 참조) - 낮은 영향도

### 작업 기간 산정:
- **Phase 1 (Entity 리팩토링)**: 2일
- **Phase 2 (Component 리팩토링)**: 3일  
- **Phase 3 (System 기본 리팩토링)**: 3일
- **Phase 4A (System 인터페이스 변경)**: 3일
- **Phase 4B (Event 시스템)**: 5일
- **Phase 4C (Strategy 패턴)**: 4일

### Phase 4 내 시스템별 우선순위:
1. **좌표변환시스템** (최우선 - 58개 참조)
2. RenderSystem, CollisionSystem 등 (후순위)

---

## Q6. 테스트 전략 및 기능 보장

**Q: 핵심 기능 보장 및 각 Phase별 테스트 전략은?**

**A: 모든 기능이 중요합니다. 다만 로직이 꼬이면서 통폐합 되어야 할 부분이 있습니다. 이는 종속성을 기반으로 판단해봐야하며, 리팩토링이 필요한 그때그때 마다 분석해봐야 합니다.

1,2,3 까지는 기존 테스트 케이스 수정으로 진행합니다. 통합테스트 보다는 단위테스트가 우선입니다. 4단계 부터는 기존 코드를 참고하여 새로운 코드를 만드는 것이 좋겠습니다. 이미 변경된 사항이 많을 것이기 때문입니다. 추가적으로 4단계 부터는 TDD 형태로 진행하면 좋겠습니다. step1 은 인터페이스를 구현하고, step2 는 기존 테스트 케이스를 참고하여 새로 만들 구현체의 스팩을 분석합니다. step3은 분석한 내용을 기반으로 사용자와 인터뷰하여 테스트 케이스의 시나리오와 스팩을 확정합니다. step4는 해당 시나리오로 테스트를 구현하며 반드시 인터페이스를 통해 공개된 것만 사용합니다. step5는 작성한 테스트 케이스를 돌려보며 리펙토링을 진행합니다. step6 ruff, mypy, pytest all 을 진행하며 코드 품질을 올립니다. 진행하는 과정중 테스트 케이스가 잘못 됐다고 생각하면 사용자에게 이러이러한 이유로 틀린것 같다고 요청하고 사용자에게 수정을 요청하며 절대로 ai가 수정해서는 안됩니다.

1,2,3까지는 단계가 끝날때 마다 demo-*.py를 하나씩 고쳐가면서 진행하면 좋겠습니다. 4단에서는 각 시스템의 단위테스트가 끝날때마다 진행하면 좋겠습니다.**

### 테스트 전략 정리:

#### Phase 1-3 (기존 코드 리팩토링):
- **테스트 방식**: 기존 테스트 케이스 수정
- **우선순위**: 단위테스트 > 통합테스트
- **검증 방법**: 각 단계 완료 시 demo-*.py 수정하며 동작 확인
- **품질 관리**: 종속성 기반 통폐합 분석

#### Phase 4 (새로운 아키텍처):
- **개발 방식**: TDD (Test-Driven Development)
- **TDD 6단계 프로세스**:
  1. **인터페이스 구현**
  2. **기존 테스트 케이스 분석** (구현체 스펙 도출)
  3. **사용자 인터뷰** (시나리오/스펙 확정)
  4. **테스트 구현** (인터페이스만 사용)
  5. **리팩토링 진행** (테스트 기반)
  6. **품질 검증** (ruff, mypy, pytest all)
- **검증 방법**: 각 시스템 단위테스트 완료 시마다 검증
- **AI 제약**: 테스트 케이스 수정 금지, 반드시 사용자 승인 필요

---