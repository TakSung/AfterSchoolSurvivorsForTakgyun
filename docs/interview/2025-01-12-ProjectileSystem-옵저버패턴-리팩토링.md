# ProjectileSystem 옵저버 패턴 리팩토링 인터뷰

## 인터뷰 정보
- **날짜**: 2025-01-12
- **인터뷰어**: 시니어 게임 PM (아키텍처 설계 전문가)
- **프로젝트 오너**: 개발자
- **목적**: ProjectileSystem의 책임 분리 및 옵저버 패턴 적용을 위한 작업 계획 수립

---

## 1. 현재 상황 분석

### 기존 ProjectileSystem의 문제점
- **단일 책임 원칙 위반**: 투사체 물리 처리 + 적 사망 처리 + 경험치 계산 + 엔티티 제거
- **높은 결합도**: 다양한 시스템과 직접적인 의존성
- **확장 어려움**: 새로운 사망 관련 로직 추가 시 ProjectileSystem 수정 필요
- **테스트 복잡성**: 여러 책임이 섞여있어 유닛테스트 작성이 어려움

### 목표 아키텍처
- **ProjectileSystem**: 투사체 물리 처리 및 적 사망 판정 후 이벤트 발행만 담당
- **옵저버 시스템들**: 사망 이벤트 구독하여 각자의 책임 처리
  - ExperienceSystem: 경험치 처리
  - ItemDropSystem: 아이템 드롭
  - EntityCleanupSystem: 엔티티 제거

---

## 2. 기술적 결정사항

### 옵저버 패턴 구현 방식
- **선택된 방식**: 큐잉 방식 (이벤트를 큐에 저장 후 각 시스템에서 처리)
- **거부된 방식**: 즉시 실행 방식 (publish 시 즉시 모든 구독자 실행)

### 큐잉 방식 선택 이유 (프로젝트 오너 답변)
1. **ECS 시스템 독립성 유지**: ProjectileSystem이 다른 시스템 실행에 영향받지 않음
2. **시스템 실행 순서와 무관**: 각 시스템이 자신의 우선순위에 따라 이벤트 처리
3. **예외 안전성**: 한 시스템의 오류가 다른 시스템에 전파되지 않음
4. **게임 로직 특성**: 1프레임 지연은 게임플레이에 영향 없음

### 이벤트 데이터 구조
- **EnemyDeathEvent**: `enemy_entity_id: str`만 포함
- **정보 조회 방식**: 구독자가 EntityManager를 통해 필요한 컴포넌트 조회
- **장점**: 최소한의 데이터 전달, 일관된 데이터 접근 패턴

---

## 3. 작업 계획 수립

### 작업 우선순위 결정 (프로젝트 오너 답변)
- **중요 원칙**: 각 단계 사이사이에 `@.claude/commands/interview-for-unit-test.md` 방법론을 사용하여 유닛 테스트 작성
- **목적**: 각 기능의 안정성을 높이고 리팩토링 과정에서의 회귀 방지

### 리팩토링 작업 단위별 우선순위 결정

다음 4가지 주요 작업들의 우선순위를 결정하여 가장 효율적이고 안전한 리팩토링 진행 방향을 설정하겠습니다:

1. **EventBus 시스템 구현**: 이벤트 발행/구독 메커니즘 및 큐잉 처리
2. **ProjectileSystem 수정**: 사망 이벤트 발행자로 역할 변경
3. **새로운 옵저버 시스템들 구현**: ExperienceSystem, ItemDropSystem, EntityCleanupSystem
4. **이벤트 정의 및 데이터 구조 설계**: EnemyDeathEvent와 관련 인터페이스

어떤 순서로 진행하면 가장 효율적이고 안전할까요?

**A: ** 4 → 1 → 2 → 3 순서로 진행합시다. 이벤트 정의부터 시작해서 EventBus 구현, ProjectileSystem 수정, 마지막에 새로운 시스템들 구현하는 것이 가장 안전하고 효율적입니다.

---

## 4. 세부 작업 계획

### 확정된 작업 순서 (프로젝트 오너 답변)

**Phase 1: 이벤트 정의 및 데이터 구조 설계**
- EnemyDeathEvent와 관련 인터페이스 정의
- 이벤트 기반 아키텍처의 기초 설계
- 유닛테스트를 통한 이벤트 구조 검증

**Phase 2: EventBus 시스템 구현**
- 이벤트 발행/구독 메커니즘 구현
- 큐잉 처리 로직 개발
- EventBus 핵심 기능에 대한 유닛테스트

**Phase 3: ProjectileSystem 수정**
- 기존 직접 처리 로직을 이벤트 발행으로 변경
- 사망 이벤트 발행자로 역할 전환
- 수정된 ProjectileSystem 유닛테스트

**Phase 4: 새로운 옵저버 시스템들 구현**
- ExperienceSystem, ItemDropSystem, EntityCleanupSystem 개발
- 각 시스템의 이벤트 구독 및 처리 로직
- 통합 테스트 및 시스템 간 연동 검증

---

## 5. Phase별 상세 구현 계획

### Phase 1 상세: 이벤트 정의 및 데이터 구조 설계

**구현 대상:**
1. **BaseEvent 추상 클래스**: 모든 이벤트의 기본 구조
2. **EnemyDeathEvent**: 적 사망 시 발행되는 이벤트
3. **이벤트 타입 Enum**: 이벤트 종류별 식별자

**유닛테스트 포인트:**
- EnemyDeathEvent 생성 및 데이터 접근 테스트
- 이벤트 타입 검증 및 데이터 무결성 테스트
- 잘못된 데이터로 이벤트 생성 시 예외 처리 테스트

### Phase 2 상세: EventBus 시스템 구현

**구현 대상:**
1. **EventBus 클래스**: 이벤트 발행/구독 메커니즘
2. **큐잉 시스템**: 이벤트를 큐에 저장하고 순차 처리
3. **구독자 관리**: 이벤트 타입별 구독자 등록/해제

**유닛테스트 포인트:**
- 이벤트 발행 및 큐 저장 검증
- 구독자 등록/해제 기능 테스트
- 큐에서 이벤트 순차 처리 테스트
- 구독자가 없는 이벤트 처리 테스트

### Phase 3 상세: ProjectileSystem 수정

**구현 대상:**
1. **_handle_enemy_death 메서드 수정**: 직접 처리 → 이벤트 발행
2. **EventBus 의존성 추가**: 생성자에서 EventBus 주입
3. **기존 경험치/엔티티 제거 로직 제거**

**유닛테스트 포인트:**
- 적 사망 시 EnemyDeathEvent 발행 검증
- 이벤트 발행 후 더 이상 직접 처리하지 않음 확인
- EventBus가 없을 때의 예외 처리 테스트

### Phase 4 상세: 새로운 옵저버 시스템들 구현

**구현 대상:**
1. **ExperienceSystem**: 경험치 처리 전용 시스템
2. **ItemDropSystem**: 아이템 드롭 처리 시스템
3. **EntityCleanupSystem**: 엔티티 정리 전용 시스템

**유닛테스트 포인트:**
- 각 시스템의 이벤트 구독 및 처리 로직 검증
- 시스템 간 독립성 보장 테스트 (한 시스템 오류가 다른 시스템에 영향 없음)
- 통합 환경에서 이벤트 흐름 검증

---

## 6. 리스크 분석 및 대응 방안

### 주요 리스크 요소

**Phase 1 리스크:**
- 이벤트 구조 설계 오류로 인한 후속 Phase 전체 재작업 위험
- **대응**: 다양한 시나리오를 고려한 이벤트 구조 설계 및 철저한 유닛테스트

**Phase 2 리스크:**
- EventBus 성능 이슈 (큐 처리 지연, 메모리 누수)
- **대응**: 큐 크기 제한, 메모리 사용량 모니터링 및 성능 테스트

**Phase 3 리스크:**
- 기존 ProjectileSystem 동작 변경으로 인한 게임 로직 버그
- **대응**: 기존 동작과 동일한 결과를 보장하는 통합 테스트 작성

**Phase 4 리스크:**
- 새로운 시스템들의 이벤트 처리 순서 의존성 문제
- **대응**: 시스템 간 독립성을 보장하는 설계 및 순서 무관 테스트

### 성공 기준

1. **기능적 성공**: 기존 ProjectileSystem과 동일한 게임 동작 유지
2. **아키텍처적 성공**: 책임 분리, 결합도 감소, 확장성 증대
3. **품질적 성공**: 모든 Phase의 유닛테스트 통과 및 코드 커버리지 90% 이상

---

## 7. 다음 단계 실행 계획

### 즉시 시작할 수 있는 작업
**Phase 1: 이벤트 정의 및 데이터 구조 설계** 부터 시작

이제 Phase 1 구현을 위한 상세 설계와 유닛테스트 인터뷰를 진행할 준비가 완료되었습니다.