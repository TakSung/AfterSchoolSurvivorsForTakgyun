# 인터뷰 기록: 아키텍쳐 기술 설계 요구사항
- 날짜: 2025-08-07
- 참석자: 시니어 아키텍트, 프로젝트 오너
- 진행자: 시니어 아키텍트

## 인터뷰 목적
- 개발에 특화된 PRD 작성을 위한 기술적 요구사항 수집
- Python 3.13+ Pygame 환경에서의 실현 가능성 검증
- 40+ FPS 성능 목표를 달성하기 위한 아키텍처 설계 방향 확정

## 질문 및 답변

### 1. 프로젝트 개요 및 랜덤성 설계

**Q1: 프로젝트 오너님께서 "10분 몰입형 하이퍼 캐주얼 로그라이크"라는 컨셉을 선택하신 핵심 이유는 무엇인가요? 랜덤성의 범위는 어디까지 설정하실 계획인지요?**
특히 아키텍트 관점에서 궁금한 것은, 이 게임이 **"반복 플레이"**를 전제로 하는데, 매번 다른
   경험을 제공하기 위한 랜덤성의 범위를 어디까지 설정하실 계획인지요?

  예를 들어:
  - 아이템 등장 순서만 랜덤인지
  - 적의 등장 패턴도 랜덤인지
  - 맵 구조나 보스 패턴까지 변화할 가능성이 있는지

  이것이 시스템 아키텍처 설계의 복잡도를 결정하는 핵심 요소가 될 것 같습니다.

**A: 아이템 등장 순서, 보스 패턴이 랜덤이야. 적의 등장 패턴는 큰부분에서는 정해지지만 작은 부분에서는 랜덤이야.**

**Q2: 아키텍처 설계 관점에서 매우 중요한 정보입니다. 그렇다면 구체적으로 "보스 패턴 랜덤"이라는 것은 어떤 수준의 변화를 의미하시나요?**
예를 들어:
  - 패턴 A: 교장 선생님이 매번 동일한 "훈화 말씀 알파 → 베타" 순서이지만, 베타 공격의
  범위/위치만 랜덤
  - 패턴 B: 교장 선생님이 "훈화 말씀 알파 → 베타 3회" 또는 "훈화 말씀 알파 → 특수공격 → 베타
   1회" 등 행동 시퀀스 자체가 랜덤
  - 패턴 C: 아예 다른 종류의 보스(예: 체육선생님, 수학선생님)가 랜덤하게 등장

  이 구분이 AI 상태머신 설계의 복잡도를 완전히 좌우할 것 같습니다. 어떤 수준을 염두에 두고
  계신가요?

**A: 패턴 B를 원해.** (교장 선생님이 "훈화 말씀 알파 → 베타 3회" 또는 "훈화 말씀 알파 → 특수공격 → 베타 1회" 등 행동 시퀀스 자체가 랜덤)

**Q3: 행동 시퀀스가 랜덤하게 변한다면, 보스의 "위험도 밸런스"를 어떻게 유지하실 계획인가요?**
 예를 들어:
  - 시퀀스 A: "알파 → 베타 1회" (상대적으로 쉬움)
  - 시퀀스 B: "알파 → 특수공격 → 베타 3회" (상대적으로 어려움)

  이런 난이도 편차가 생길 텐데, 이를 해결하기 위해:

  1. 보스 체력을 시퀀스 난이도에 따라 동적 조절할 것인지
  2. 시퀀스별로 고정된 위험도 점수를 미리 계산해둘 것인지
  3. 플레이어 현재 상태(체력, 아이템)에 따라 시퀀스 선택을 조절할 것인지

  어떤 방향을 선호하시나요?

**A: 그러네요 밸런스를 생각한다면 정해진 것이 좋겠습니다. 보스 패턴은 난이도를 같이 조절하되. 시간이 흐를수록 난이도가 증가한다면 상대적으로 어렵게 만들도록 하죠.**

🎯 아키텍트 답변: 이제 정해진 보스 패턴 + 시간 기반 난이도 조절로 방향이 명확해졌습니다. 이는 데이터 드리븐 설계가 최적일 것 같습니다.

### 2. 기술적 제약사항 및 성능 목표

**Q4: 현재 개발환경이 Python 3.13 + Pygame으로 설정되어 있는데, 초보 개발자분께서 개발하신다고 하셨죠. 그렇다면 "40+ FPS 성능 목표"를 달성하기 위해 어떤 수준의 기술적 복잡도까지는 허용 가능하시나요?**
구체적으로:
  - NumPy 기반 벡터 연산 (수학 최적화)
  - Pygame 스프라이트 그룹 최적화 (렌더링 최적화)
  - Object Pooling 패턴 (메모리 관리 최적화)
  - Spatial Partitioning (충돌감지 최적화)

  이 중에서 개발 난이도 대비 성능 향상 효과를 고려할 때, 어느 정도까지 적용하는 것이 적절하다고 보시나요?

**A: 위에 내용은 전부 적용할 것이지만, 추상화를 통해서 교체가 가능하도록 만들고 싶습니다. 초반에는 최적화를 하지 않은 버전으로 진행하다가 나중에 필요해 지면 최적화를 진행하고 싶습니다.**

🎯 아키텍트 답변: 추상화 기반 점진적 최적화 전략을 선택하셨군요! 이는 매우 현명한 접근입니다. Strategy 패턴 + Interface 기반 설계가 핵심이 되겠네요.

**Q5: 추상화 전략에서 가장 중요한 것은 "인터페이스 경계"를 잘 설정하는 것입니다. 다음 시스템들의 최적화 우선순위를 어떻게 설정하시겠습니까?**
우선순위를 매겨보시면:

  1. 렌더링 시스템 (화면에 그리는 부분) - 적/투사체가 많아질수록 병목
  2. 충돌감지 시스템 (적과 플레이어/투사체 충돌) - 객체 수의 제곱으로 증가
  3. AI 계산 시스템 (적들의 행동 결정) - 복잡한 AI일수록 부하
  4. 물리 시뮬레이션 (이동, 속도 계산) - 정밀도 vs 성능 트레이드오프

  어떤 순서로 최적화가 필요해질 것 같나요? 이것이 추상화 레이어의 우선순위를 결정할 것 같습니다.

**A: 충돌감지 시스템, 렌더링 시스템, AI 계산 시스템, 물리 시뮬레이션 순으로 중요합니다.**

### 3. 아이템 시스템 아키텍처

**Q6: 기존 기획서를 보면 "아이템 시너지 시스템"이 핵심 재미 요소인데, 현재 7개 아이템으로 시작해서 나중에 20+ 개로 확장될 가능성이 높습니다. 이때 "시너지 조합의 계산 복잡도"를 어떻게 관리하실 계획인가요?**
예를 들어:
  - 방법 A: 아이템 조합을 미리 하드코딩 (예: if 축구화 and 축구공: damage += 15%)
  - 방법 B: 룰 엔진 기반 (예: JSON으로 {"conditions": ["축구화", "축구공"], "effects": ["damage_bonus": 1.15]})
  - 방법 C: 태그 기반 시스템 (예: 아이템에 sport_type: soccer 태그를 붙여 동일 태그끼리 시너지)

  어떤 방향이 확장성과 유지보수성 측면에서 적합하다고 생각하시나요?

**A: 방법 B** (룰 엔진 기반 - JSON으로 `{"conditions": ["축구화", "축구공"], "effects": ["damage_bonus": 1.15]}` 형태)

**Q7: 룰 엔진 방식에서 가장 중요한 것은 "효과 적용 타이밍"입니다. 아이템 시너지 효과가 언제 계산되고 적용되어야 할까요?**
예를 들어:
  - 타이밍 A: 아이템을 획득하는 순간 즉시 계산 (캐싱 방식)
  - 타이밍 B: 공격이나 행동을 할 때마다 실시간 계산
  - 타이밍 C: 게임 루프마다 매 프레임 계산

  이는 성능 vs 동적 효과의 트레이드오프인데:
  - A는 빠르지만 실시간 변화 효과가 제한적
  - B는 액션 기반으로 자연스럽지만 중간 복잡도
  - C는 가장 유연하지만 성능 부담이 큼

  어떤 방식을 선호하시나요?

**A: 타이밍 A 방안으로 하려고 하는데, 한번 정하면 변경하기 어려운가요?**

🎯 아키텍트 답변:
 좋은 질문입니다! **타이밍 A (캐싱 방식)**는 실제로는 가장 변경하기 쉬운 방식입니다.
  아니요, 오히려 타이밍 A가 가장 유연합니다! 왜냐하면:

  1. 캐싱 레이어를 두면 나중에 다른 타이밍으로 쉽게 전환 가능
  2. 성능이 가장 좋아서 추후 최적화 압박이 적음
  3. 디버깅과 밸런싱이 가장 쉬움

  구체적으로는 이런 확장 경로를 가질 수 있습니다:
  - 초기: 아이템 획득 시 즉시 캐싱
  - 중기: 필요 시 "재계산 트리거" 추가 (특정 조건에서만 다시 계산)
  - 후기: 실시간 계산 옵션 추가 (하지만 캐싱 결과와 비교 검증 가능)

**Q8: 그렇다면 "디버프 시스템"과 "아이템 시너지"가 동시에 적용될 때는 어떤 우선순위로 처리하시겠습니까?**

**A: C 방식** (가산 방식 - `기본 데미지 × (1.15 - 0.3)`)

### 4. 게임 루프 및 상태 관리

**Q9: 게임의 핵심 루프를 보면 "마우스 따라 이동" + "자동 공격" + "실시간 적 등장"이 동시에 일어납니다. 이때 가장 중요한 것은 "프레임 드롭 없는 부드러운 움직임"일 텐데, 어떤 접근 방식을 선호하시나요?**
- 방식 A: 고정 프레임 (60 FPS로 고정, 느린 기기에서는 게임 속도 저하)
  - 방식 B: 가변 프레임 (기기 성능에 맞춰 FPS 조절, 하지만 delta time 계산 필요)
  - 방식 C: 하이브리드 (60 FPS 목표, 40 FPS 이하로 떨어지면 품질 자동 조절)

  "10분 몰입형" 게임의 특성상 어떤 방식이 플레이 경험에 가장 좋을 것 같나요?

PM : 각 방식의 특징들은 무엇인가요?

🎯 아키텍트 답변:

  각 방식의 특징을 자세히 설명드리겠습니다:

  방식 A: 고정 프레임 (60 FPS)

  장점:
  - 구현이 가장 간단 (delta time 계산 불필요)
  - 게임 로직이 예측 가능하고 디버깅 쉬움
  - 물리 시뮬레이션이 일정함

  단점:
  - 느린 기기에서 전체 게임이 슬로우모션
  - 40 FPS 미만으로 떨어지면 거의 플레이 불가능
  - 기기별 성능 격차를 무시함

  방식 B: 가변 프레임 (Delta Time)

  장점:
  - 모든 기기에서 동일한 게임 속도
  - 하드웨어 성능을 최대한 활용
  - 프로 게임 개발의 표준 방식

  단점:
  - 구현 복잡도 높음 (모든 이동/시간 계산에 delta time 적용)
  - 물리 시뮬레이션 불안정할 수 있음
  - 초보 개발자에게는 어려울 수 있음

  방식 C: 하이브리드

  장점:
  - 좋은 기기에서는 최고 품질
  - 나쁜 기기에서도 최소 플레이 보장
  - 점진적 품질 조절 가능

  단점:
  - 가장 복잡한 구현
  - 품질 조절 로직 추가 필요
  - 테스트 케이스가 많음

  방과후생존 게임 특성 고려:
  - 10분 몰입형 → 끊김 없는 부드러움이 핵심
  - 초보 개발자 → 구현 복잡도 고려 필요
  - 하이퍼 캐주얼 → 다양한 기기 지원 중요

  어떤 방식이 프로젝트에 가장 적합하다고 생각하시나요?

**A: 그러면 혹시 60fps와 40fps를 setting으로 선택할 수 있는 방안에 대해서는 어떻게 생각하시나요?**

🎯 아키텍트 답변:

  훌륭한 아이디어입니다! "60fps/40fps 설정 선택" 방식은 방과후생존 게임에 매우 적합한 접근법입니다.

  설정 기반 FPS 선택 방식의 장점:

  ✅ 구현 측면:
  - 초보 개발자에게 친화적 - 고정 프레임 방식이므로 delta time 복잡도 없음
  - 디버깅 용이 - 두 가지 고정 시나리오만 테스트
  - 점진적 구현 - 먼저 60fps로 개발 후 40fps 모드 추가

  ✅ 사용자 측면:
  - 선택권 제공 - 성능 vs 품질 트레이드오프를 사용자가 결정
  - 명확한 기대치 - "40fps = 저사양 모드", "60fps = 고품질 모드"
  - 즉시 체감 가능 - 설정 변경 후 바로 차이를 느낄 수 있음

  ✅ 비즈니스 측면:
  - 더 넓은 기기 지원 - 저사양 기기도 40fps로 플레이 가능
  - 사용자 만족도 - 각자 기기에 맞는 최적 경험 제공

  구현 고려사항:

  - 게임 밸런싱을 FPS에 독립적으로 설계 (시간 기반 계산)
  - 아이템 획득 빈도, 적 등장 주기 등을 초 단위로 관리
  - 두 모드 간 공정한 게임플레이 보장

  이 방식으로 진행하시겠습니까?

**Q10: 설정 기반 FPS 선택을 채택한다면, "게임 밸런싱"을 FPS에 독립적으로 만들기 위해 시간 기반 로직이 필요합니다. 다음 요소들을 절대 시간으로 관리해야 할지, 상대적 조정이 가능한지 구분해주실 수 있나요?**

- 플레이어 공격 속도 (예: 0.5초마다 공격)
  - 적 등장 주기 (예: 2초마다 새로운 적)
  - 아이템 드롭 확률 계산
  - 보스 등장 타이밍 (1분 30초)
  - 디버프 지속 시간

  이 중에서 절대 시간으로 고정되어야 하는 것과 상대적 조정이 가능한 것을 구분해주실 수 있나요?

**A: 전부 절대 시간으로 관리가 필요합니다.**

### 5. 데이터 관리 및 확장성

**Q11: 지금까지의 논의를 종합해보면 다음과 같은 "외부 데이터 파일들"이 필요할 것 같습니다. 이 데이터 파일들의 "실시간 수정"이 가능했으면 하시나요?**
- items.json (아이템 정보 + 시너지 규칙)
  - enemies.json (적 정보 + AI 패턴)
  - bosses.json (보스 패턴 + 디버프 규칙)
  - game_balance.json (시간 기반 밸런싱 값들)

  **이 데이터 파일들의 **"실시간 수정"이 가능했으면 하시나요?

  예를 들어:
  - 개발 모드: 게임 실행 중에 JSON 파일 수정하면 즉시 반영 (빠른 밸런싱)
  - 배포 모드: 게임 시작 시에만 로딩 (안정성 우선)

  개발 효율성을 위해 "핫 리로딩(Hot Reloading)" 기능이 있으면 유용할까요, 아니면 복잡도 증가 대비 불필요할까요?

**A: 핫 리로딩은 불필요 합니다.**

**Q12: 그렇다면 "모듈화 수준"은 어느 정도로 설정하시겠습니까? ECS 기반의 아키텍쳐는 어떤 모듈화에 특화 되어 있나요?**
현재 상황: MVP에서 캐릭터 1종, 적 3종, 아이템 7종
  확장 계획: 캐릭터 추가, 적 확장, 아이템 20+ 종

  모듈화 옵션:
  - A. 최소 모듈화: 현재 필요한 것만 분리 (Player, Enemy, Item, Game 클래스)
  - B. 중간 모듈화: 확장 가능한 기본 구조 (PlayerSystem, EnemyFactory, ItemRegistry 등)
  - C. 고도 모듈화: 완전한 플러그인 아키텍처 (새 캐릭터를 별도 모듈로 추가 가능)

  초보 개발자 + MVP 우선이라는 제약 조건에서, 어느 수준의 모듈화가 **"과도하지 않으면서도 확장성"**을 확보할 수 있을까요?

PM : ECS 기반의 아키텍쳐는 어떤 모듈화에 특화 되어 있나요?

🎯 아키텍트 답변:

  ECS(Entity-Component-System) 아키텍처는 B. 중간 모듈화에 최적화되어 있습니다.

  ECS의 모듈화 특성:

  ✅ ECS가 제공하는 자연스러운 모듈화:

  🔹 Component 레벨 모듈화:
  # 각 컴포넌트가 독립적 모듈
  class HealthComponent: pass
  class MovementComponent: pass
  class WeaponComponent: pass
  - 새 기능 추가 = 새 컴포넌트 추가
  - 기존 코드 수정 없이 확장 가능

  🔹 System 레벨 모듈화:
  class MovementSystem: pass
  class CollisionSystem: pass
  class RenderSystem: pass
  - 각 시스템이 독립적으로 동작
  - 시스템 간 결합도 최소화

  🔹 Entity 레벨 조합:
  # 플레이어 = 컴포넌트 조합
  player = Entity([HealthComponent, MovementComponent, WeaponComponent])
  # 새 캐릭터 = 다른 컴포넌트 조합  
  boss = Entity([HealthComponent, AIComponent, SpecialAttackComponent])

  🎯 방과후생존 게임에서의 ECS 모듈화 예시:

  현재 MVP:
  - PlayerEntity = Health + Movement + AutoAttack
  - EnemyEntity = Health + Movement + AI
  - ItemEntity = Pickup + Effect

  확장 시:
  - 새 캐릭터 = 기존 컴포넌트 재조합
  - 새 아이템 = Effect 컴포넌트만 추가
  - 새 적 = AI 컴포넌트 교체

  결론: ECS는 **"컴포넌트 단위 모듈화"**를 통해 B. 중간 모듈화를 자연스럽게 달성하면서도, 필요시 C. 고도 모듈화로 확장 가능합니다.

**A: ECS가 제공하는 자연스러운 모듈화를 활용하여 B. 중간 모듈화 수준 선택**

**Q13: ECS 아키텍처를 채택한다면, "성능 최적화 추상화"와 어떻게 결합할 계획인가요? 시스템 교체 시의 영향에 대해 성능, 확장성, 복잡성 세 가지 요소로 알려주세요.**

앞서 "충돌감지 → 렌더링 → AI → 물리" 순으로 최적화 우선순위를 정하셨는데, ECS에서는:

  - CollisionSystem을 나중에 Spatial Partitioning으로 교체
  - RenderSystem을 Sprite Group 최적화로 교체
  - AISystem을 Behavior Tree로 교체

  이런 시스템 교체가 가능하도록 설계하시겠습니까?

**A: 교체할때 어떤 영향이 있나요? 변경 전과 변경후의 영향에 대해서 성능, 확장성, 복잡성 세가지의 요소를 포함하여 알려주세요.**

🎯 아키텍트 답변:
ECS 시스템 교체 시 영향 분석:

  1️⃣ CollisionSystem 교체 (단순 → Spatial Partitioning)

  | 요소  | 변경 전 (단순)              | 변경 후 (최적화)                    | 영향도       |
  |-----|------------------------|-------------------------------|-----------|
  | 성능  | O(n²) - 모든 객체끼리 충돌 검사  | O(n log n) - 공간 분할로 근접 객체만 검사 | 🟢 극대 향상  |
  | 확장성 | 객체 100개 이상 시 급격한 성능 저하 | 객체 1000개도 안정적 처리 가능           | 🟢 크게 향상  |
  | 복잡성 | 간단한 거리 계산 (20줄)        | QuadTree 구현 + 경계 처리 (200줄)    | 🔴 10배 증가 |

  ---
  2️⃣ RenderSystem 교체 (개별 → Sprite Group 최적화)

  | 요소  | 변경 전 (개별)           | 변경 후 (최적화)            | 영향도      |
  |-----|---------------------|-----------------------|----------|
  | 성능  | 객체별 개별 draw() 호출    | 배치 렌더링 + 더티 렉트        | 🟡 중간 향상 |
  | 확장성 | 화면 객체 50개 한계        | 화면 객체 200개 처리 가능      | 🟡 적당 향상 |
  | 복잡성 | pygame.draw() 직접 호출 | SpriteGroup 관리 + 레이어링 | 🟡 2배 증가 |

  ---
  3️⃣ AISystem 교체 (단순 → Behavior Tree)

  | 요소  | 변경 전 (단순)          | 변경 후 (최적화)            | 영향도      |
  |-----|--------------------|-----------------------|----------|
  | 성능  | if-else 체인으로 AI 결정 | 트리 탐색 + 조건 평가         | 🔴 약간 저하 |
  | 확장성 | 새 AI 패턴 추가 시 코드 수정 | 데이터로 AI 패턴 정의 가능      | 🟢 크게 향상 |
  | 복잡성 | 간단한 상태 체크 (50줄)    | BT 노드 + 평가기 구현 (300줄) | 🔴 6배 증가 |

  ---
  4️⃣ PhysicsSystem 교체 (단순 → Pymunk 통합)

  | 요소  | 변경 전 (단순)            | 변경 후 (최적화)           | 영향도      |
  |-----|----------------------|----------------------|----------|
  | 성능  | 기본 벡터 연산             | C 기반 물리 엔진           | 🟢 향상    |
  | 확장성 | 기본 이동만 가능            | 복잡한 물리 효과 가능         | 🟢 크게 향상 |
  | 복잡성 | position += velocity | Pymunk Body/Shape 관리 | 🔴 3배 증가 |

  ---
  💡 전략적 권장사항:

  🎯 MVP 단계 (초보 개발자 고려):

  1. CollisionSystem만 인터페이스 준비 - 성능 임팩트가 가장 큼
  2. 나머지는 단순 구현 - 복잡도 최소화

  🚀 확장 단계:

  1. CollisionSystem 교체 (필수) - 게임성에 직접 영향
  2. RenderSystem 교체 (선택) - 시각적 품질 향상
  3. AISystem, PhysicsSystem (후순위) - 기능 확장 시에만

  📊 교체 우선순위 결정 기준:

  - 성능 개선폭 > 구현 복잡도 인 경우만 교체
  - CollisionSystem: 개선폭 극대, 복잡도 높지만 투자 가치 있음
  - AISystem: 개선폭 중간, 복잡도 매우 높음 → 신중 검토 필요

  어떤 시스템부터 교체 가능한 구조로 설계하시겠습니까?

**A: 전부 인터페이스를 준비해줘요. 실제 구현은 나중에 하더라도 추상화는 해야한다고 생각합니다.**

### 6. 개발 우선순위 및 MVP 범위

**Q14: 지금까지 논의한 모든 시스템을 고려할 때, "MVP 개발 순서"를 어떻게 설정하시겠습니까?**

**A: 순서가 적절합니다. 다만 우선순위에 추가할 것은 단위 테스트 입니다. 상태변화와 계산하는 함수를 명확히 분리하여 코드를 작성하며, 각 단계에서 순수 객체 혹은 함수를 사용하여 데이터 기반의 테스트 혹은 시나리오 기반의 테스트를 통하여 유닛테스트를 통해 각 함수 혹은 객체의 스팩을 명확히 하는 것이 중요합니다. pytest를 사용하여 특정 단일 테스트를 하는 것과 모든 테스트를 하는것 혹은 특정 도메인(혹은 카테고리)으로 묶이는 테스트 들만 테스트 할수 있는 환경도 구축할 필요가 있습니다.**
🎯 아키텍트 답변:

  정말 훌륭한 추가입니다! 단위 테스트 중심 개발과 순수 함수/객체 분리 전략은 방과후생존 게임의 품질과 유지보수성을 크게 향상시킬
  것입니다.

  특히 상태변화와 계산 함수 분리는:
  - ECS 아키텍처와 완벽하게 조화 (컴포넌트 = 상태, 시스템 = 순수 계산)
  - 추상화 인터페이스 교체 시 안전성 보장
  - 게임 밸런싱 테스트 (데미지 계산, 시너지 효과 등)

  pytest 도메인 분류 예시:
  - pytest -m "collision" (충돌감지 테스트)
  - pytest -m "items" (아이템 시스템 테스트)
  - pytest -m "boss" (보스 패턴 테스트)

  ---
  🎉 인터뷰 완료!

  지금까지의 논의로 방과후생존 게임의 기술 아키텍처 설계 방향이 매우 명확해졌습니다:

  🏗️ 핵심 아키텍처 결정:
  - ECS 기반 + 추상화 인터페이스
  - 60fps/40fps 설정 선택
  - JSON 기반 룰 엔진
  - pytest 단위 테스트 중심

  📋 개발 우선순위:
  1. 핵심 인프라 + 테스트 프레임워크
  2. 기본 게임플레이 + 유닛 테스트
  3. 아이템 시스템 + 시너지 테스트
  4. 보스 시스템 + 통합 테스트

  이제 수집된 모든 정보를 바탕으로 개발 중심의 상세 PRD를 작성할 준비가 완료되었습니다!