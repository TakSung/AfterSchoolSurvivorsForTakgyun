# ECS ì•„í‚¤í…ì²˜ ë¦¬íŒ©í† ë§ ì‘ì—… ê³„íšì„œ
**ë‚ ì§œ**: 2025-08-17  
**ëª©í‘œ**: Design2.md ê¸°ë°˜ Producer-Consumer ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ë° ì „ëµ íŒ¨í„´ ì ìš©

## ğŸ“ ìµœì¢… í´ë” êµ¬ì¡°

### ì „ì²´ êµ¬ì¡° ê°œìš”
```
src/
â”œâ”€â”€ ecs/                          # ECS Framework (ìµœí•˜ìœ„ ê³„ì¸µ)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ entity.py                 # Entity í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ component.py              # Component ABC
â”‚   â”œâ”€â”€ system.py                 # ISystem, System ABC
â”‚   â””â”€â”€ component_registry.py     # IComponentRegistry, ComponentRegistry
â”‚
â”œâ”€â”€ managers/                     # íŠ¹í™”ëœ ë„ë©”ì¸ ê´€ë¦¬ìë“¤
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ i_entity_manager.py       # IEntityManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_enemy_manager.py        # IEnemyManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_weapon_manager.py       # IWeaponManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_projectile_manager.py   # IProjectileManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_experience_manager.py   # IExperienceManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_coordinate_manager.py   # ICoordinateManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_game_state_manager.py   # IGameStateManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_difficulty_manager.py   # IDifficultyManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”œâ”€â”€ i_time_manager.py         # ITimeManager ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”‚
â”‚   â”œâ”€â”€ entity/                   # EntityManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ crud_entity_manager.py       # ìˆœìˆ˜ CRUD êµ¬í˜„
â”‚   â”‚   â””â”€â”€ cached_entity_manager.py     # ìºì‹œ ìµœì í™” êµ¬í˜„
â”‚   â”‚
â”‚   â”œâ”€â”€ enemy/                    # EnemyManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ basic_enemy_manager.py       # ê¸°ë³¸ ì  ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ boss_enemy_manager.py        # ë³´ìŠ¤ íŠ¹í™” ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ spawning_enemy_manager.py    # ìŠ¤í¬ë‹ íŠ¹í™” ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ weapon/                   # WeaponManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ basic_weapon_manager.py      # ê¸°ë³¸ ë¬´ê¸° ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ synergy_weapon_manager.py    # ì‹œë„ˆì§€ íŠ¹í™” ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ upgrade_weapon_manager.py    # ì—…ê·¸ë ˆì´ë“œ íŠ¹í™” ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ projectile/               # ProjectileManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ physics_projectile_manager.py # ë¬¼ë¦¬ ê¸°ë°˜ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ collision_projectile_manager.py # ì¶©ëŒ íŠ¹í™” ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ experience/               # ExperienceManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ basic_experience_manager.py  # ê¸°ë³¸ ê²½í—˜ì¹˜ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ leveling_experience_manager.py # ë ˆë²¨ë§ íŠ¹í™” ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ coordinate/               # CoordinateManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ basic_coordinate_manager.py    # ê¸°ë³¸ ì¢Œí‘œ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ cached_coordinate_manager.py   # ìºì‹œ ìµœì í™” ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ game_state/               # GameStateManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ basic_game_state_manager.py    # ê¸°ë³¸ ìƒíƒœ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ persistent_game_state_manager.py # ì˜ì†ì„± ìƒíƒœ ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ difficulty/               # DifficultyManager êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ linear_difficulty_manager.py   # ì„ í˜• ë‚œì´ë„ ì¦ê°€
â”‚   â”‚   â””â”€â”€ adaptive_difficulty_manager.py # ì ì‘í˜• ë‚œì´ë„ ì¡°ì •
â”‚   â”‚
â”‚   â””â”€â”€ time/                     # TimeManager êµ¬í˜„ì²´ë“¤
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ basic_time_manager.py          # ê¸°ë³¸ ì‹œê°„ ê´€ë¦¬
â”‚       â””â”€â”€ scaled_time_manager.py         # ì‹œê°„ ë°°ìœ¨ ê´€ë¦¬
â”‚
â”œâ”€â”€ systems/                      # ê²Œì„ ë¡œì§ + ì „ëµ íŒ¨í„´
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ strategies/               # ì „ëµ íŒ¨í„´ êµ¬í˜„ì²´ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ i_attack_strategy.py      # IAttackStrategy ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”‚   â”œâ”€â”€ i_spawn_strategy.py       # ISpawnStrategy ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”‚   â”œâ”€â”€ i_movement_strategy.py    # IMovementStrategy ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”‚   â”œâ”€â”€ i_coordinate_transform_strategy.py  # ICoordinateTransformStrategy ì¸í„°í˜ì´ìŠ¤ (ìƒë‹¨)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ attack/               # ê³µê²© ì „ëµë“¤
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ direct_attack_strategy.py
â”‚   â”‚   â”‚   â”œâ”€â”€ area_attack_strategy.py
â”‚   â”‚   â”‚   â””â”€â”€ homing_attack_strategy.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ spawn/                # ìŠ¤í° ì „ëµë“¤
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ random_spawn_strategy.py
â”‚   â”‚   â”‚   â”œâ”€â”€ wave_spawn_strategy.py
â”‚   â”‚   â”‚   â””â”€â”€ boss_spawn_strategy.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ movement/             # ì´ë™ ì „ëµë“¤
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ player_movement_strategy.py
â”‚   â”‚   â”‚   â””â”€â”€ ai_movement_strategy.py
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ coordinate_transform/ # ì¢Œí‘œ ë³€í™˜ ì „ëµë“¤
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ basic_transform_strategy.py      # ê¸°ë³¸ ë³€í™˜
â”‚   â”‚       â”œâ”€â”€ camera_based_transform_strategy.py # ì¹´ë©”ë¼ ê¸°ë°˜ ë³€í™˜
â”‚   â”‚       â”œâ”€â”€ cached_transform_strategy.py     # ìºì‹œ ìµœì í™” ë³€í™˜
â”‚   â”‚       â””â”€â”€ spatial_transform_strategy.py    # ê³µê°„ ë¶„í•  ìµœì í™” ë³€í™˜
â”‚   â”‚
â”‚   â”œâ”€â”€ enemy_system.py           # EnemySystem
â”‚   â”œâ”€â”€ weapon_system.py          # WeaponSystem
â”‚   â”œâ”€â”€ projectile_system.py      # ProjectileSystem
â”‚   â”œâ”€â”€ player_movement_system.py # PlayerMovementSystem
â”‚   â”œâ”€â”€ render_system.py          # RenderSystem
â”‚   â”œâ”€â”€ camera_system.py          # CameraSystem
â”‚   â””â”€â”€ collision_system.py       # CollisionSystem
â”‚
â”œâ”€â”€ events/                       # Producer-Consumer ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/                     # ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì½”ì–´
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base_event.py         # BaseEvent ABC - ëª¨ë“  ì´ë²¤íŠ¸ì˜ ê¸°ë³¸ êµ¬ì¡°
â”‚   â”‚   â”œâ”€â”€ event_producer.py     # EventProducer<T> - íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìƒì‚°ì
â”‚   â”‚   â”œâ”€â”€ event_consumer.py     # EventConsumer<T> - íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ì†Œë¹„ì  
â”‚   â”‚   â”œâ”€â”€ event_tunnel_manager.py # EventTunnelManager - Producer/Consumer ìŒ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ event_types.py        # EventType Enum - ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
â”‚   â”‚
â”‚   â”œâ”€â”€ types/                    # êµ¬ì²´ì ì¸ ì´ë²¤íŠ¸ íƒ€ì…ë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ enemy_death_event.py
â”‚   â”‚   â”œâ”€â”€ level_up_event.py
â”‚   â”‚   â”œâ”€â”€ experience_gain_event.py
â”‚   â”‚   â”œâ”€â”€ projectile_hit_event.py
â”‚   â”‚   â””â”€â”€ camera_offset_changed_event.py
â”‚   â”‚
â”‚   â””â”€â”€ consumers/                # ì´ë²¤íŠ¸ ì»¨ìŠˆë¨¸ë“¤
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ experience_consumer.py
â”‚       â”œâ”€â”€ weapon_upgrade_consumer.py
â”‚       â””â”€â”€ damage_consumer.py
â”‚
â”œâ”€â”€ components/                   # ê²Œì„ ì»´í¬ë„ŒíŠ¸ë“¤
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/                     # í•µì‹¬ ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ position_component.py
â”‚   â”‚   â”œâ”€â”€ velocity_component.py
â”‚   â”‚   â”œâ”€â”€ health_component.py
â”‚   â”‚   â””â”€â”€ render_component.py
â”‚   â”‚
â”‚   â”œâ”€â”€ gameplay/                 # ê²Œì„í”Œë ˆì´ ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ player_component.py
â”‚   â”‚   â”œâ”€â”€ enemy_component.py
â”‚   â”‚   â”œâ”€â”€ weapon_component.py
â”‚   â”‚   â”œâ”€â”€ projectile_component.py
â”‚   â”‚   â””â”€â”€ experience_component.py
â”‚   â”‚
â”‚   â””â”€â”€ systems/                  # ì‹œìŠ¤í…œë³„ ì»´í¬ë„ŒíŠ¸
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ camera_component.py
â”‚       â”œâ”€â”€ collision_component.py
â”‚       â””â”€â”€ player_movement_component.py
â”‚
â”œâ”€â”€ dto/                          # ë°ì´í„° ì „ì†¡ ê°ì²´ë“¤ (íƒ€ì… ì•ˆì „ì„±)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ creation/                 # ìƒì„± DTOë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ enemy_create_dto.py
â”‚   â”‚   â”œâ”€â”€ weapon_create_dto.py
â”‚   â”‚   â”œâ”€â”€ projectile_create_dto.py
â”‚   â”‚   â””â”€â”€ player_create_dto.py
â”‚   â”‚
â”‚   â”œâ”€â”€ update/                   # ì—…ë°ì´íŠ¸ DTOë“¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ enemy_update_dto.py
â”‚   â”‚   â”œâ”€â”€ weapon_update_dto.py
â”‚   â”‚   â””â”€â”€ experience_update_dto.py
â”‚   â”‚
â”‚   â””â”€â”€ query/                    # ì¡°íšŒ DTOë“¤
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ spawn_query_dto.py
â”‚       â””â”€â”€ target_query_dto.py
â”‚
â”œâ”€â”€ utils/                        # ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ë“¤
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ vector2.py                # Vector2 í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ math_utils.py             # ìˆ˜í•™ ìœ í‹¸ë¦¬í‹°
â”‚   â”œâ”€â”€ collision_utils.py        # ì¶©ëŒ ê³„ì‚° ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ performance_utils.py      # ì„±ëŠ¥ ì¸¡ì • ìœ í‹¸ë¦¬í‹°
â”‚
â”œâ”€â”€ factories/                    # íŒ©í† ë¦¬ íŒ¨í„´ (ë³µì¡í•œ ê°ì²´ ìƒì„±)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ entity_factory.py         # ì—”í‹°í‹° íŒ©í† ë¦¬
â”‚   â”œâ”€â”€ system_factory.py         # ì‹œìŠ¤í…œ íŒ©í† ë¦¬
â”‚   â””â”€â”€ manager_factory.py        # ë§¤ë‹ˆì € íŒ©í† ë¦¬
â”‚
â”œâ”€â”€ orchestration/                # ì‹œìŠ¤í…œ ì¡°ìœ¨ ë° ê²Œì„ ë£¨í”„
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ system_orchestrator.py    # SystemOrchestrator
â”‚   â”œâ”€â”€ game_loop.py              # GameLoop
â”‚   â””â”€â”€ application.py            # Application (ì§„ì…ì )
â”‚
â””â”€â”€ config/                       # ì„¤ì • ë° ìƒìˆ˜ë“¤
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ game_config.py            # ê²Œì„ ì„¤ì •ê°’ë“¤
    â”œâ”€â”€ system_priorities.py      # ì‹œìŠ¤í…œ ìš°ì„ ìˆœìœ„ ìƒìˆ˜
    â””â”€â”€ enums.py                  # ê²Œì„ ì—´ê±°í˜•ë“¤ (WeaponType, EnemyType ë“±)
```

## ğŸ“ ì½”ë”© íŒ¨í„´ ë° ê·œì¹™

### 1. ì¸í„°í˜ì´ìŠ¤ ì •ì˜ ê·œì¹™

#### **Manager ì¸í„°í˜ì´ìŠ¤ íŒ¨í„´**
```python
# managers/i_enemy_manager.py
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..dto.creation.enemy_create_dto import EnemyCreateDTO
    from ..dto.update.enemy_update_dto import EnemyUpdateDTO
    from ..ecs.entity import Entity

class IEnemyManager(ABC):
    """ì  ê´€ë¦¬ì ì¸í„°í˜ì´ìŠ¤ - ë‹¤í˜•ì„±ê³¼ ìº¡ìŠí™” ë³´ì¥"""
    
    # ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œ (êµ¬í˜„ì²´ ìˆ¨ê¹€)
    @staticmethod
    def create_basic() -> 'IEnemyManager':
        """ê¸°ë³¸ ì  ê´€ë¦¬ì ìƒì„± (êµ¬í˜„ì²´ ìˆ¨ê¹€)"""
        from .enemy.basic_enemy_manager import BasicEnemyManager
        return BasicEnemyManager()
    
    @staticmethod  
    def create_boss() -> 'IEnemyManager':
        """ë³´ìŠ¤ íŠ¹í™” ê´€ë¦¬ì ìƒì„± (êµ¬í˜„ì²´ ìˆ¨ê¹€)"""
        from .enemy.boss_enemy_manager import BossEnemyManager
        return BossEnemyManager()
    
    @staticmethod
    def create_spawning() -> 'IEnemyManager':
        """ìŠ¤í¬ë‹ íŠ¹í™” ê´€ë¦¬ì ìƒì„± (êµ¬í˜„ì²´ ìˆ¨ê¹€)"""
        from .enemy.spawning_enemy_manager import SpawningEnemyManager
        return SpawningEnemyManager()
    
    # ì¶”ìƒ ë©”ì„œë“œë“¤
    @abstractmethod
    def create_enemy(self, dto: 'EnemyCreateDTO') -> 'Entity':
        """ì  ì—”í‹°í‹° ìƒì„±"""
        pass
    
    @abstractmethod
    def update_enemy_stats(self, entity: 'Entity', dto: 'EnemyUpdateDTO') -> None:
        """ì  ìƒíƒœ ì—…ë°ì´íŠ¸"""
        pass
    
    @abstractmethod
    def get_enemy_count(self) -> int:
        """í™œì„± ì  ìˆ˜ ì¡°íšŒ"""
        pass
    
    @abstractmethod
    def cleanup_dead_enemies(self) -> list['Entity']:
        """ì£½ì€ ì ë“¤ ì •ë¦¬"""
        pass
```

#### **Strategy ì¸í„°í˜ì´ìŠ¤ íŒ¨í„´**
```python
# systems/strategies/i_attack_strategy.py
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ...dto.creation.projectile_create_dto import ProjectileCreateDTO
    from ...ecs.entity import Entity
    from ...utils.vector2 import Vector2

class IAttackStrategy(ABC):
    """ê³µê²© ì „ëµ ì¸í„°í˜ì´ìŠ¤"""
    
    # ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œ
    @staticmethod
    def create_direct() -> 'IAttackStrategy':
        """ì§ì ‘ ê³µê²© ì „ëµ ìƒì„±"""
        from .attack.direct_attack_strategy import DirectAttackStrategy
        return DirectAttackStrategy()
    
    @staticmethod
    def create_area(radius: float) -> 'IAttackStrategy':
        """ê´‘ì—­ ê³µê²© ì „ëµ ìƒì„±"""
        from .attack.area_attack_strategy import AreaAttackStrategy
        return AreaAttackStrategy(radius)
    
    @staticmethod
    def create_homing(strength: float) -> 'IAttackStrategy':
        """ìœ ë„ ê³µê²© ì „ëµ ìƒì„±"""
        from .attack.homing_attack_strategy import HomingAttackStrategy
        return HomingAttackStrategy(strength)
    
    # ì¶”ìƒ ë©”ì„œë“œë“¤
    @abstractmethod
    def find_target(self, attacker: 'Entity', available_targets: list['Entity']) -> 'Entity | None':
        """ê³µê²© ëŒ€ìƒ ì„ íƒ"""
        pass
    
    @abstractmethod
    def create_attack_dto(self, attacker: 'Entity', target: 'Entity') -> 'ProjectileCreateDTO':
        """ê³µê²© DTO ìƒì„±"""
        pass
    
    @abstractmethod
    def get_strategy_name(self) -> str:
        """ì „ëµ ì´ë¦„ ë°˜í™˜"""
        pass
```

### 2. êµ¬í˜„ì²´ ì‘ì„± ê·œì¹™

#### **Manager êµ¬í˜„ì²´ íŒ¨í„´**
```python
# managers/enemy/basic_enemy_manager.py
from typing import TYPE_CHECKING

from ..i_enemy_manager import IEnemyManager

if TYPE_CHECKING:
    from ...dto.creation.enemy_create_dto import EnemyCreateDTO
    from ...dto.update.enemy_update_dto import EnemyUpdateDTO
    from ...ecs.entity import Entity
    from ...managers.i_entity_manager import IEntityManager

class BasicEnemyManager(IEnemyManager):
    """ê¸°ë³¸ ì  ê´€ë¦¬ì êµ¬í˜„ì²´ - ì¼ë°˜ì ì¸ ì  ê´€ë¦¬ ê¸°ëŠ¥ ì œê³µ"""
    
    def __init__(self, entity_manager: 'IEntityManager') -> None:
        """ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ EntityManager ë°›ê¸°"""
        # AI-NOTE : 2025-08-17 ì˜ì¡´ì„± ì£¼ì…ì„ í†µí•œ í…ŒìŠ¤íŠ¸ ìš©ì´ì„± í™•ë³´
        # - ì´ìœ : Mock EntityManager ì£¼ì…ìœ¼ë¡œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê²©ë¦¬
        # - ìš”êµ¬ì‚¬í•­: ManagerëŠ” EntityManager ì¸í„°í˜ì´ìŠ¤ë§Œ ì˜ì¡´
        # - ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜: ì•ˆì •ì ì¸ ì  ê´€ë¦¬ ë¡œì§ ë³´ì¥
        self._entity_manager = entity_manager
    
    def create_enemy(self, dto: 'EnemyCreateDTO') -> 'Entity':
        """ê¸°ë³¸ ì  ì—”í‹°í‹° ìƒì„±"""
        # 1. ì—”í‹°í‹° ìƒì„±
        entity = self._entity_manager.create_entity()
        
        # 2. ì»´í¬ë„ŒíŠ¸ ì¶”ê°€ (DTO ê¸°ë°˜)
        self._add_basic_components(entity, dto)
        self._add_ai_component(entity, dto)
        self._add_physics_components(entity, dto)
        
        return entity
    
    def update_enemy_stats(self, entity: 'Entity', dto: 'EnemyUpdateDTO') -> None:
        """ì  ìƒíƒœ ì—…ë°ì´íŠ¸"""
        # DTO ê¸°ë°˜ ìƒíƒœ ì—…ë°ì´íŠ¸ ë¡œì§
        pass
    
    def get_enemy_count(self) -> int:
        """í™œì„± ì  ìˆ˜ ì¡°íšŒ"""
        # EntityManagerë¥¼ í†µí•œ ì  ìˆ˜ ì¡°íšŒ
        pass
    
    def cleanup_dead_enemies(self) -> list['Entity']:
        """ì£½ì€ ì ë“¤ ì •ë¦¬"""
        # ì£½ì€ ì  ì •ë¦¬ ë¡œì§
        pass
    
    def _add_basic_components(self, entity: 'Entity', dto: 'EnemyCreateDTO') -> None:
        """ê¸°ë³¸ ì»´í¬ë„ŒíŠ¸ ì¶”ê°€ (private ë©”ì„œë“œ)"""
        pass
```

#### **Strategy êµ¬í˜„ì²´ íŒ¨í„´**
```python
# systems/strategies/attack/direct_attack_strategy.py
from typing import TYPE_CHECKING

from ..i_attack_strategy import IAttackStrategy

if TYPE_CHECKING:
    from ....dto.creation.projectile_create_dto import ProjectileCreateDTO
    from ....ecs.entity import Entity

class DirectAttackStrategy(IAttackStrategy):
    """ì§ì ‘ ê³µê²© ì „ëµ - ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ì§ì„ ìœ¼ë¡œ ê³µê²©"""
    
    def find_target(self, attacker: 'Entity', available_targets: list['Entity']) -> 'Entity | None':
        """ê°€ì¥ ê°€ê¹Œìš´ ì  ì„ íƒ"""
        # AI-NOTE : 2025-08-17 ê±°ë¦¬ ê¸°ë°˜ íƒ€ê²Ÿ ì„ íƒ ë¡œì§
        # - ì´ìœ : ì§ì ‘ ê³µê²©ì€ ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ìš°ì„  íƒ€ê²ŸíŒ…
        # - ìš”êµ¬ì‚¬í•­: ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚°ìœ¼ë¡œ ìµœê·¼ì ‘ ì  ì„ íƒ
        # - ìµœì í™”: ê±°ë¦¬ ì œê³± ë¹„êµë¡œ ì œê³±ê·¼ ì—°ì‚° ìƒëµ
        if not available_targets:
            return None
        
        attacker_pos = self._get_position(attacker)
        if not attacker_pos:
            return None
        
        closest_target = None
        min_distance_sq = float('inf')
        
        for target in available_targets:
            target_pos = self._get_position(target)
            if not target_pos:
                continue
            
            # ê±°ë¦¬ ì œê³± ê³„ì‚° (ì œê³±ê·¼ ì—°ì‚° ìƒëµ)
            distance_sq = (
                (target_pos.x - attacker_pos.x) ** 2 + 
                (target_pos.y - attacker_pos.y) ** 2
            )
            
            if distance_sq < min_distance_sq:
                min_distance_sq = distance_sq
                closest_target = target
        
        return closest_target
    
    def create_attack_dto(self, attacker: 'Entity', target: 'Entity') -> 'ProjectileCreateDTO':
        """ì§ì„  ê³µê²© DTO ìƒì„±"""
        # DTO ìƒì„± ë¡œì§
        pass
    
    def get_strategy_name(self) -> str:
        """ì „ëµ ì´ë¦„ ë°˜í™˜"""
        return "DirectAttack"
    
    def _get_position(self, entity: 'Entity') -> 'Vector2 | None':
        """ì—”í‹°í‹° ìœ„ì¹˜ ì¡°íšŒ (private í—¬í¼ ë©”ì„œë“œ)"""
        pass
```

### 3. System ì‘ì„± ê·œì¹™

#### **System êµ¬í˜„ íŒ¨í„´**
```python
# systems/weapon_system.py
from typing import TYPE_CHECKING

from ..ecs.system import System

if TYPE_CHECKING:
    from ..managers.i_weapon_manager import IWeaponManager
    from ..systems.strategies.i_attack_strategy import IAttackStrategy
    from ..events.core.event_producer import EventProducer
    from ..events.types.projectile_created_event import ProjectileCreatedEvent

class WeaponSystem(System):
    """ë¬´ê¸° ì‹œìŠ¤í…œ - ì „ëµ íŒ¨í„´ìœ¼ë¡œ ë‹¤ì–‘í•œ ê³µê²© ë°©ì‹ ì§€ì›"""
    
    def __init__(
        self, 
        weapon_manager: 'IWeaponManager',
        event_producer: 'EventProducer[ProjectileCreatedEvent]'
    ) -> None:
        """ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ Managerì™€ EventProducer ë°›ê¸°"""
        super().__init__(priority=10)
        
        # AI-NOTE : 2025-08-17 Systemì˜ Manager ì˜ì¡´ì„±ê³¼ ì „ëµ íŒ¨í„´ ì ìš©
        # - ì´ìœ : Systemì€ EntityManager ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šê³  Manager í†µí•´ ì¶”ìƒí™”
        # - ìš”êµ¬ì‚¬í•­: ëŸ°íƒ€ì„ì— ê³µê²© ì „ëµ êµì²´ ê°€ëŠ¥í•œ ìœ ì—°ì„± ì œê³µ
        # - ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜: ë‹¤ì–‘í•œ ë¬´ê¸° íƒ€ì…ê³¼ ê³µê²© íŒ¨í„´ ì§€ì›
        self._weapon_manager = weapon_manager
        self._event_producer = event_producer
        
        # ê¸°ë³¸ ì „ëµ ì„¤ì •
        from ..systems.strategies.i_attack_strategy import IAttackStrategy
        self._attack_strategy: 'IAttackStrategy' = IAttackStrategy.create_direct()
    
    def update(self, delta_time: float) -> None:
        """ë¬´ê¸° ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ (entity_manager ì—†ì´!)"""
        # 1. Managerë¥¼ í†µí•´ í™œì„± ë¬´ê¸° ì¡°íšŒ
        active_weapons = self._weapon_manager.get_active_weapons()
        
        # 2. ê° ë¬´ê¸°ë³„ ê³µê²© ì²˜ë¦¬
        for weapon_entity in active_weapons:
            if self._weapon_manager.can_attack(weapon_entity, delta_time):
                # 3. ì „ëµ íŒ¨í„´ìœ¼ë¡œ ê³µê²© ì‹¤í–‰
                self._execute_attack_with_strategy(weapon_entity)
    
    def set_attack_strategy(self, strategy: 'IAttackStrategy') -> None:
        """ê³µê²© ì „ëµ êµì²´ (ëŸ°íƒ€ì„ ë³€ê²½ ê°€ëŠ¥)"""
        self._attack_strategy = strategy
    
    def _execute_attack_with_strategy(self, weapon_entity: 'Entity') -> None:
        """ì „ëµ íŒ¨í„´ì„ ì‚¬ìš©í•œ ê³µê²© ì‹¤í–‰"""
        # 1. ì „ëµì„ í†µí•´ íƒ€ê²Ÿ ì„ íƒ
        available_targets = self._weapon_manager.get_targets_in_range(weapon_entity)
        target = self._attack_strategy.find_target(weapon_entity, available_targets)
        
        if target:
            # 2. ì „ëµì„ í†µí•´ ê³µê²© DTO ìƒì„±
            attack_dto = self._attack_strategy.create_attack_dto(weapon_entity, target)
            
            # 3. Managerë¥¼ í†µí•´ ê³µê²© ì‹¤í–‰
            projectile_entity = self._weapon_manager.execute_attack(attack_dto)
            
            # 4. ì´ë²¤íŠ¸ ë°œí–‰
            if projectile_entity:
                from ..events.types.projectile_created_event import ProjectileCreatedEvent
                event = ProjectileCreatedEvent(
                    projectile_entity_id=projectile_entity.entity_id,
                    weapon_entity_id=weapon_entity.entity_id,
                    timestamp=time.time()
                )
                self._event_producer.produce(event)
    
    def initialize(self) -> None:
        """ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
        super().initialize()
        # ì´ˆê¸°í™” ë¡œì§
    
    def get_required_components(self) -> list[type]:
        """ì´ ì‹œìŠ¤í…œì´ í•„ìš”ë¡œ í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ íƒ€ì…ë“¤"""
        from ..components.gameplay.weapon_component import WeaponComponent
        from ..components.core.position_component import PositionComponent
        return [WeaponComponent, PositionComponent]
```

### 4. Event ì‹œìŠ¤í…œ ìƒì„¸ ì„¤ëª…

#### **4.1. events/core/ êµ¬ì¡° ìƒì„¸**

**BaseEvent**: ëª¨ë“  ì´ë²¤íŠ¸ì˜ ê³µí†µ ì¸í„°í˜ì´ìŠ¤
```python
# events/core/base_event.py
from abc import ABC, abstractmethod
import time

class BaseEvent(ABC):
    """ëª¨ë“  ì´ë²¤íŠ¸ì˜ ê¸°ë³¸ êµ¬ì¡°"""
    
    def __init__(self) -> None:
        self.timestamp: float = time.time()
    
    @abstractmethod
    def get_event_type(self) -> 'EventType':
        """ì´ë²¤íŠ¸ íƒ€ì… ë°˜í™˜ (Enum ì‚¬ìš©)"""
        pass
    
    @abstractmethod
    def validate(self) -> bool:
        """ì´ë²¤íŠ¸ ë°ì´í„° ê²€ì¦"""
        pass
```

**EventProducer**: íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìƒì‚°ì
```python
# events/core/event_producer.py  
from collections import deque
from typing import Generic, TypeVar

T = TypeVar('T', bound='BaseEvent')

class EventProducer(Generic[T]):
    """íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìƒì‚°ì"""
    
    def __init__(self, event_type: type[T], max_queue_size: int = 1000) -> None:
        self._event_type = event_type
        self._queue: deque[T] = deque(maxlen=max_queue_size)
    
    def produce(self, event: T) -> bool:
        """ì´ë²¤íŠ¸ ìƒì‚° (íƒ€ì… ê²€ì¦ í¬í•¨)"""
        if not isinstance(event, self._event_type):
            raise TypeError(f"Expected {self._event_type.__name__}, got {type(event).__name__}")
        
        self._queue.append(event)
        return True
```

**EventConsumer**: íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ì†Œë¹„ì
```python
# events/core/event_consumer.py
from collections import deque  
from typing import Generic, TypeVar

T = TypeVar('T', bound='BaseEvent')

class EventConsumer(Generic[T]):
    """íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ì†Œë¹„ì"""
    
    def __init__(self, event_type: type[T]) -> None:
        self._event_type = event_type
        self._queue: deque[T] = deque()
    
    def consume_next(self) -> T | None:
        """ë‹¤ìŒ ì´ë²¤íŠ¸ ì†Œë¹„"""
        try:
            return self._queue.popleft()
        except IndexError:
            return None
    
    def is_empty(self) -> bool:
        """íê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸"""
        return len(self._queue) == 0
```

**EventTunnelManager**: Producer/Consumer ìŒ ê´€ë¦¬
```python
# events/core/event_tunnel_manager.py
from typing import TypeVar, Generic

T = TypeVar('T', bound='BaseEvent')

class EventTunnelManager:
    """Producerì™€ Consumer ìŒì„ ê´€ë¦¬í•˜ëŠ” í„°ë„ ë§¤ë‹ˆì €"""
    PRODUCER = 1
    CONSUMER = 1
    
    def __init__(self) -> None:
        self._tunnels: dict[type, tuple[EventProducer, EventConsumer]] = {}
    
    def create_tunnel[T](self, event_type: type[T]) -> tuple[EventProducer[T], EventConsumer[T]]:
        """ì´ë²¤íŠ¸ íƒ€ì…ë³„ Producer/Consumer ìŒ ìƒì„±"""
        producer = EventProducer(event_type)
        consumer = EventConsumer(event_type)
        self._tunnels[event_type] = (producer, consumer)
        return producer, consumer
    
    def get_producer[T](self, event_type: type[T]) -> EventProducer[T]:
        """Producer ì¡°íšŒ"""
        if event_type not in self._tunnels:
            self.create_tunnel(event_type)
        return self._tunnels[event_type][self.PRODUCER]
    
    def get_consumer[T](self, event_type: type[T]) -> EventConsumer[T]:
        """Consumer ì¡°íšŒ"""
        if event_type not in self._tunnels:
            self.create_tunnel(event_type)
        return self._tunnels[event_type][self.CONSUMER]
    
    def process_all_tunnels(self) -> dict[type, int]:
        """ëª¨ë“  í„°ë„ì˜ ì´ë²¤íŠ¸ ì „ì†¡ (Producer â†’ Consumer)"""
        processed_counts = {}
        
        for event_type, (producer, consumer) in self._tunnels.items():
            count = 0
            while not producer.is_empty():
                event = producer.consume_next()
                if event:
                    consumer._queue.append(event)  # Producerì—ì„œ Consumerë¡œ ì „ì†¡
                    count += 1
            processed_counts[event_type] = count
        
        return processed_counts
```

**EventType Enum**: ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
```python
# events/core/event_types.py
from enum import IntEnum

class EventType(IntEnum):
    """ì´ë²¤íŠ¸ íƒ€ì… ì—´ê±°í˜•"""
    ENEMY_DEATH = 0
    LEVEL_UP = 1
    EXPERIENCE_GAIN = 2
    PROJECTILE_HIT = 3
    CAMERA_OFFSET_CHANGED = 4
    WEAPON_UPGRADE = 5
    
    @property
    def display_name(self) -> str:
        """ì´ë²¤íŠ¸ íƒ€ì… í‘œì‹œëª…"""
        names = {
            self.ENEMY_DEATH: "ì  ì‚¬ë§",
            self.LEVEL_UP: "ë ˆë²¨ì—…",
            self.EXPERIENCE_GAIN: "ê²½í—˜ì¹˜ íšë“",
            self.PROJECTILE_HIT: "íˆ¬ì‚¬ì²´ ëª…ì¤‘",
            self.CAMERA_OFFSET_CHANGED: "ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ë³€ê²½",
            self.WEAPON_UPGRADE: "ë¬´ê¸° ì—…ê·¸ë ˆì´ë“œ"
        }
        return names.get(self, "ì•Œ ìˆ˜ ì—†ëŠ” ì´ë²¤íŠ¸")
```

### 5. Event ì‹œìŠ¤í…œ ì‘ì„± ê·œì¹™

#### **Event íƒ€ì… ì •ì˜**
```python
# events/types/enemy_death_event.py
import time
from dataclasses import dataclass
from typing import TYPE_CHECKING

from ..core.base_event import BaseEvent

if TYPE_CHECKING:
    from ...utils.vector2 import Vector2

@dataclass
class EnemyDeathEvent(BaseEvent):
    """ì  ì‚¬ë§ ì´ë²¤íŠ¸"""
    
    enemy_entity_id: str
    death_position: 'Vector2'
    experience_reward: int
    killer_entity_id: str | None = None
    
    def __post_init__(self) -> None:
        """ì´ë²¤íŠ¸ ì´ˆê¸°í™” í›„ íƒ€ì„ìŠ¤íƒ¬í”„ ì„¤ì •"""
        if not hasattr(self, 'timestamp'):
            self.timestamp = time.time()
    
    def validate(self) -> bool:
        """ì´ë²¤íŠ¸ ë°ì´í„° ê²€ì¦"""
        return (
            bool(self.enemy_entity_id) and
            self.death_position is not None and
            self.experience_reward >= 0
        )
    
    def get_event_type(self) -> 'EventType':
        """ì´ë²¤íŠ¸ íƒ€ì… ë°˜í™˜"""
        from ...config.enums import EventType
        return EventType.ENEMY_DEATH
```

#### **Event Consumer ì •ì˜ (System ê¸°ë°˜)**
```python
# events/consumers/experience_consumer.py
from typing import TYPE_CHECKING

from ...ecs.system import System
from ..core.event_consumer import EventConsumer
from ..types.enemy_death_event import EnemyDeathEvent

if TYPE_CHECKING:
    from ...managers.i_experience_manager import IExperienceManager

class ExperienceConsumerSystem(System):
    """ê²½í—˜ì¹˜ ì²˜ë¦¬ ì „ìš© ì»¨ìŠˆë¨¸ ì‹œìŠ¤í…œ - Systemì„ ìƒì†í•˜ì—¬ ì‹œìŠ¤í…œìœ¼ë¡œ ë™ì‘"""
    
    def __init__(self, experience_manager: 'IExperienceManager') -> None:
        """ê²½í—˜ì¹˜ ê´€ë¦¬ì ì˜ì¡´ì„± ì£¼ì…"""
        super().__init__(priority=20)  # Experience ì²˜ë¦¬ëŠ” í›„ìˆœìœ„
        self._experience_manager = experience_manager
        self._event_consumer: EventConsumer[EnemyDeathEvent] = EventConsumer(EnemyDeathEvent)
    
    def update(self, delta_time: float) -> None:
        """System ì—…ë°ì´íŠ¸ - ì´ë²¤íŠ¸ ì»¨ìŠˆë¨¸ë¡œ ë™ì‘"""
        # EventConsumerë¥¼ í†µí•´ ì´ë²¤íŠ¸ ì²˜ë¦¬
        while not self._event_consumer.is_empty():
            event = self._event_consumer.consume_next()
            if event:
                self._process_enemy_death_event(event)
    
    def _process_enemy_death_event(self, event: EnemyDeathEvent) -> None:
        """ì  ì‚¬ë§ ì´ë²¤íŠ¸ ì²˜ë¦¬ - ê²½í—˜ì¹˜ ì§€ê¸‰"""
        # AI-NOTE : 2025-08-17 ê²½í—˜ì¹˜ ì§€ê¸‰ ë¡œì§
        # - ì´ìœ : ì  ì‚¬ë§ ì‹œ í”Œë ˆì´ì–´ì—ê²Œ ê²½í—˜ì¹˜ ì§€ê¸‰í•˜ì—¬ ì„±ì¥ ìš”ì†Œ ì œê³µ
        # - ìš”êµ¬ì‚¬í•­: ì´ë²¤íŠ¸ ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©ìœ¼ë¡œ ì‹œìŠ¤í…œ ë…ë¦½ì„± í™•ë³´
        # - ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜: í”Œë ˆì´ì–´ ì§„í–‰ë„ì™€ ì„±ì·¨ê° í–¥ìƒ
        try:
            self._experience_manager.grant_experience(
                amount=event.experience_reward,
                position=event.death_position,
                killer_entity_id=event.killer_entity_id
            )
        except Exception as e:
            # ë¡œê¹…í•˜ë˜ ë‹¤ë¥¸ ì»¨ìŠˆë¨¸ì— ì˜í–¥ ì£¼ì§€ ì•ŠìŒ
            import logging
            logging.error(f"Failed to grant experience: {e}")
    
    def initialize(self) -> None:
        """ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
        super().initialize()
        # EventTunnelManagerì— Consumer ë“±ë¡
        # (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” EventTunnelManager.register_consumer() í˜¸ì¶œ)
    
    def get_required_components(self) -> list[type]:
        """ì´ ì‹œìŠ¤í…œì´ í•„ìš”ë¡œ í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ (ì—†ìŒ - ì´ë²¤íŠ¸ë§Œ ì²˜ë¦¬)"""
        return []
```

### 5. DTO ì‘ì„± ê·œì¹™

#### **Creation DTO íŒ¨í„´**
```python
# dto/creation/enemy_create_dto.py
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ...utils.vector2 import Vector2
    from ...config.enums import EnemyType, AIType

@dataclass
class EnemyCreateDTO:
    """ì  ìƒì„± ë°ì´í„° ì „ì†¡ ê°ì²´"""
    
    spawn_position: 'Vector2'
    enemy_type: 'EnemyType'
    difficulty_scale: float = 1.0
    ai_type: 'AIType | None' = None
    base_health: int = 100
    base_speed: float = 80.0
    experience_reward: int = 10
    
    def validate(self) -> bool:
        """DTO ë°ì´í„° ê²€ì¦"""
        return (
            self.spawn_position is not None and
            self.difficulty_scale > 0 and
            self.base_health > 0 and
            self.base_speed > 0 and
            self.experience_reward >= 0
        )
    
    def get_scaled_health(self) -> int:
        """ë‚œì´ë„ ìŠ¤ì¼€ì¼ ì ìš©ëœ ì²´ë ¥ ë°˜í™˜"""
        return int(self.base_health * self.difficulty_scale)
    
    def get_scaled_speed(self) -> float:
        """ë‚œì´ë„ ìŠ¤ì¼€ì¼ ì ìš©ëœ ì†ë„ ë°˜í™˜"""
        return self.base_speed * self.difficulty_scale
    
    def get_additional_data(self, key: str, default_value=None):
        """ì¶”ê°€ ë°ì´í„° ì¡°íšŒ (í™•ì¥ì„±ì„ ìœ„í•œ ë©”ì„œë“œ)"""
        # í•„ìš”ì‹œ ì¶”ê°€ ì†ì„±ë“¤ì„ ìœ„í•œ í™•ì¥ í¬ì¸íŠ¸
        return default_value
```

## ğŸ”„ ë§ˆì´ê·¸ë ˆì´ì…˜ ë‹¨ê³„ë³„ ì‘ì—… ê³„íš

### Phase 1: ê¸°ë°˜ êµ¬ì¡° êµ¬ì¶• (1-2ì¼)
1. **ECS Framework ìˆœìˆ˜í™”**
   - `src/ecs/` í´ë” ìƒì„±
   - ê¸°ì¡´ `src/core/entity.py`, `component.py`, `system.py` ì´ë™
   - `System.update()` ì¸í„°í˜ì´ìŠ¤ ë³€ê²½ (entity_manager ì œê±°)

2. **Manager ì¸í„°í˜ì´ìŠ¤ ì¶”ì¶œ**
   - `src/managers/` í´ë” êµ¬ì¡° ìƒì„±
   - ê° Managerì˜ ì¸í„°í˜ì´ìŠ¤ íŒŒì¼ ìƒì„±
   - ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œ íŒ¨í„´ ì ìš©

3. **DTO ê³„ì¸µ êµ¬ì¶•**
   - `src/dto/` í´ë” êµ¬ì¡° ìƒì„±
   - Creation, Update, Query DTO ì •ì˜

### Phase 2: Event ì‹œìŠ¤í…œ êµì²´ (2-3ì¼)
1. **Producer-Consumer êµ¬í˜„**
   - `src/events/core/` EventProducer, EventConsumer, EventTunnelManager êµ¬í˜„
   - íƒ€ì… ì•ˆì „ì„± ë³´ì¥ì„ ìœ„í•œ Generic í´ë˜ìŠ¤ ì„¤ê³„

2. **Event íƒ€ì… ë§ˆì´ê·¸ë ˆì´ì…˜**
   - ê¸°ì¡´ `src/core/events/` â†’ `src/events/types/` ì´ë™
   - BaseEvent ì¸í„°í˜ì´ìŠ¤ í‘œì¤€í™”

3. **Consumer êµ¬í˜„**
   - `src/events/consumers/` ìƒì„±
   - ExperienceConsumer, WeaponUpgradeConsumer ë“± êµ¬í˜„

### Phase 3: Strategy íŒ¨í„´ ì ìš© (2-3ì¼)
1. **Strategy ì¸í„°í˜ì´ìŠ¤ ì •ì˜**
   - `src/systems/strategies/` êµ¬ì¡° ìƒì„±
   - Attack, Spawn, Movement, CoordinateTransform ì „ëµ ì¸í„°í˜ì´ìŠ¤

2. **System ë¦¬íŒ©í† ë§**
   - ê¸°ì¡´ Systemë“¤ì„ Strategy íŒ¨í„´ìœ¼ë¡œ ë³€ê²½
   - Manager ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ EntityManager ì§ì ‘ ì ‘ê·¼ ì œê±°

3. **Coordinate ì‹œìŠ¤í…œ í†µí•©**
   - ê¸°ì¡´ `coordination/` í´ë” í•´ì²´
   - Managerì™€ Strategy ê³„ì¸µìœ¼ë¡œ ì¬ë°°ì¹˜

### Phase 4: Manager êµ¬í˜„ì²´ ë¶„ë¦¬ (1-2ì¼)
1. **ê¸°ëŠ¥ë³„ Manager êµ¬í˜„ì²´ ìƒì„±**
   - Basic, Boss, Synergy ë“± íŠ¹í™”ëœ êµ¬í˜„ì²´ ìƒì„±
   - ê° êµ¬í˜„ì²´ì˜ ë‹¨ì¼ ì±…ì„ ì›ì¹™ ì ìš©

2. **Factory íŒ¨í„´ êµ¬í˜„**
   - `src/factories/` ë³µì¡í•œ ê°ì²´ ìƒì„± ë¡œì§ ë¶„ë¦¬
   - System, Manager íŒ©í† ë¦¬ êµ¬í˜„

### Phase 5: í†µí•© ë° í…ŒìŠ¤íŠ¸ (1-2ì¼)
1. **Orchestration ê³„ì¸µ êµ¬ì„±**
   - `src/orchestration/` ìµœìƒìœ„ ì¡°ìœ¨ ê³„ì¸µ
   - SystemOrchestrator, GameLoop, Application êµ¬í˜„

2. **ì¢…í•© í…ŒìŠ¤íŠ¸ ë° ìµœì í™”**
   - ì „ì²´ ì‹œìŠ¤í…œ í†µí•© í…ŒìŠ¤íŠ¸
   - ì„±ëŠ¥ ì¸¡ì • ë° ìµœì í™”

## ğŸ“‹ ì½”ë”© í‘œì¤€ ë° ì£¼ì˜ì‚¬í•­

### 1. ëª…ëª… ê·œì¹™
- **ì¸í„°í˜ì´ìŠ¤**: `I` ì ‘ë‘ì‚¬ (`IEnemyManager`, `IAttackStrategy`)
- **êµ¬í˜„ì²´**: ê¸°ëŠ¥ ëª…ì‹œ (`BasicEnemyManager`, `DirectAttackStrategy`)
- **DTO**: ìš©ë„ ëª…ì‹œ (`EnemyCreateDTO`, `WeaponUpdateDTO`)
- **Event**: ë™ì‘ ëª…ì‹œ (`EnemyDeathEvent`, `LevelUpEvent`)

### 2. ì˜ì¡´ì„± ê·œì¹™
- **ìƒìœ„ ê³„ì¸µ â†’ í•˜ìœ„ ê³„ì¸µ**: í—ˆìš©
- **í•˜ìœ„ ê³„ì¸µ â†’ ìƒìœ„ ê³„ì¸µ**: ê¸ˆì§€
- **ì¸í„°í˜ì´ìŠ¤ ì˜ì¡´**: ê¶Œì¥
- **êµ¬ì²´ í´ë˜ìŠ¤ ì˜ì¡´**: ìµœì†Œí™”

### 3. AI ì£¼ì„ ê·œì¹™
```python
# AI-NOTE : ë‚ ì§œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì„¤ëª…
# - ì´ìœ : ì™œ ì´ë ‡ê²Œ êµ¬í˜„í–ˆëŠ”ì§€
# - ìš”êµ¬ì‚¬í•­: ì–´ë–¤ ìš”êµ¬ì‚¬í•­ì„ ë°˜ì˜í–ˆëŠ”ì§€
# - ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜: ê²Œì„ì—ì„œì˜ ì˜ë¯¸ì™€ íš¨ê³¼

# AI-DEV : ê¸°ìˆ ì  í•´ê²°ì±… ì„¤ëª…  
# - ë¬¸ì œ: ì–´ë–¤ ê¸°ìˆ ì  ë¬¸ì œê°€ ìˆì—ˆëŠ”ì§€
# - í•´ê²°ì±…: ì–´ë–»ê²Œ í•´ê²°í–ˆëŠ”ì§€
# - ì£¼ì˜ì‚¬í•­: ìœ ì§€ë³´ìˆ˜ ì‹œ ì£¼ì˜í•  ì 
```

### 4. íƒ€ì… íŒíŠ¸ ê·œì¹™
- **Python 3.13+ ë„¤ì´í‹°ë¸Œ ë¬¸ë²•** ì‚¬ìš©
- **TYPE_CHECKING** ê°€ë“œë¡œ ìˆœí™˜ ì˜ì¡´ì„± ë°©ì§€
- **ì œë„¤ë¦­** íƒ€ì… ì ê·¹ í™œìš© (`EventProducer[T]`, `EventConsumer[T]`)

### 5. í…ŒìŠ¤íŠ¸ ì „ëµ
- **ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ Mock** ê°ì²´ í™œìš©
- **DTO ê¸°ë°˜ í…ŒìŠ¤íŠ¸ ë°ì´í„°** ê´€ë¦¬
- **Strategy íŒ¨í„´ë³„ ë…ë¦½ í…ŒìŠ¤íŠ¸**
- **Event ì‹œìŠ¤í…œ ê²©ë¦¬ í…ŒìŠ¤íŠ¸**

## ğŸ¯ ì„±ê³µ ì§€í‘œ

### 1. ì•„í‚¤í…ì²˜ í’ˆì§ˆ
- [ ] ëª¨ë“  Systemì´ EntityManager ì§ì ‘ ì ‘ê·¼ ì œê±°
- [ ] Manager ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ ë‹¤í˜•ì„± êµ¬í˜„
- [ ] Producer-Consumer ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì™„ì „ ì „í™˜
- [ ] Strategy íŒ¨í„´ìœ¼ë¡œ ëŸ°íƒ€ì„ í–‰ë™ ë³€ê²½ ê°€ëŠ¥

### 2. ì½”ë“œ í’ˆì§ˆ
- [ ] íƒ€ì… íŒíŠ¸ 100% ì ìš©
- [ ] ìˆœí™˜ ì˜ì¡´ì„± 0ê°œ
- [ ] AI ì£¼ì„ìœ¼ë¡œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë¬¸ì„œí™”
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ 80% ì´ìƒ ì»¤ë²„ë¦¬ì§€

### 3. ì„±ëŠ¥ ëª©í‘œ
- [ ] ê²Œì„ ì‹¤í–‰ ì‹œ 40+ FPS ìœ ì§€
- [ ] Event ì²˜ë¦¬ ì§€ì—°ì‹œê°„ 1ms ì´í•˜
- [ ] Manager êµì²´ ì‹œ ì„±ëŠ¥ ì˜í–¥ 5% ì´í•˜

---

**ì‘ì„±ì**: Claude Code Assistant  
**ìŠ¹ì¸ì**: ê°œë°œíŒ€  
**ê²€í†  ì£¼ê¸°**: ë§¤ì¼ ì§„í–‰ìƒí™© ì²´í¬  
**ì™„ë£Œ ì˜ˆì •ì¼**: 2025-08-24