# ECS 아키텍처 리팩토링 작업 계획서
**날짜**: 2025-08-17  
**목표**: Design2.md 기반 Producer-Consumer 이벤트 시스템 및 전략 패턴 적용

## 📁 최종 폴더 구조

### 전체 구조 개요
```
src/
├── ecs/                          # ECS Framework (최하위 계층)
│   ├── __init__.py
│   ├── entity.py                 # Entity 클래스
│   ├── component.py              # Component ABC
│   ├── system.py                 # ISystem, System ABC
│   └── component_registry.py     # IComponentRegistry, ComponentRegistry
│
├── managers/                     # 특화된 도메인 관리자들
│   ├── __init__.py
│   ├── i_entity_manager.py       # IEntityManager 인터페이스 (상단)
│   ├── i_enemy_manager.py        # IEnemyManager 인터페이스 (상단)
│   ├── i_weapon_manager.py       # IWeaponManager 인터페이스 (상단)
│   ├── i_projectile_manager.py   # IProjectileManager 인터페이스 (상단)
│   ├── i_experience_manager.py   # IExperienceManager 인터페이스 (상단)
│   ├── i_coordinate_manager.py   # ICoordinateManager 인터페이스 (상단)
│   ├── i_game_state_manager.py   # IGameStateManager 인터페이스 (상단)
│   ├── i_difficulty_manager.py   # IDifficultyManager 인터페이스 (상단)
│   ├── i_time_manager.py         # ITimeManager 인터페이스 (상단)
│   │
│   ├── entity/                   # EntityManager 구현체들
│   │   ├── __init__.py
│   │   ├── crud_entity_manager.py       # 순수 CRUD 구현
│   │   └── cached_entity_manager.py     # 캐시 최적화 구현
│   │
│   ├── enemy/                    # EnemyManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_enemy_manager.py       # 기본 적 관리
│   │   ├── boss_enemy_manager.py        # 보스 특화 관리
│   │   └── spawning_enemy_manager.py    # 스포닝 특화 관리
│   │
│   ├── weapon/                   # WeaponManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_weapon_manager.py      # 기본 무기 관리
│   │   ├── synergy_weapon_manager.py    # 시너지 특화 관리
│   │   └── upgrade_weapon_manager.py    # 업그레이드 특화 관리
│   │
│   ├── projectile/               # ProjectileManager 구현체들
│   │   ├── __init__.py
│   │   ├── physics_projectile_manager.py # 물리 기반 관리
│   │   └── collision_projectile_manager.py # 충돌 특화 관리
│   │
│   ├── experience/               # ExperienceManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_experience_manager.py  # 기본 경험치 관리
│   │   └── leveling_experience_manager.py # 레벨링 특화 관리
│   │
│   ├── coordinate/               # CoordinateManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_coordinate_manager.py    # 기본 좌표 관리
│   │   └── cached_coordinate_manager.py   # 캐시 최적화 관리
│   │
│   ├── game_state/               # GameStateManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_game_state_manager.py    # 기본 상태 관리
│   │   └── persistent_game_state_manager.py # 영속성 상태 관리
│   │
│   ├── difficulty/               # DifficultyManager 구현체들
│   │   ├── __init__.py
│   │   ├── linear_difficulty_manager.py   # 선형 난이도 증가
│   │   └── adaptive_difficulty_manager.py # 적응형 난이도 조정
│   │
│   └── time/                     # TimeManager 구현체들
│       ├── __init__.py
│       ├── basic_time_manager.py          # 기본 시간 관리
│       └── scaled_time_manager.py         # 시간 배율 관리
│
├── systems/                      # 게임 로직 + 전략 패턴
│   ├── __init__.py
│   ├── strategies/               # 전략 패턴 구현체들
│   │   ├── __init__.py
│   │   ├── i_attack_strategy.py      # IAttackStrategy 인터페이스 (상단)
│   │   ├── i_spawn_strategy.py       # ISpawnStrategy 인터페이스 (상단)
│   │   ├── i_movement_strategy.py    # IMovementStrategy 인터페이스 (상단)
│   │   ├── i_coordinate_transform_strategy.py  # ICoordinateTransformStrategy 인터페이스 (상단)
│   │   │
│   │   ├── attack/               # 공격 전략들
│   │   │   ├── __init__.py
│   │   │   ├── direct_attack_strategy.py
│   │   │   ├── area_attack_strategy.py
│   │   │   └── homing_attack_strategy.py
│   │   │
│   │   ├── spawn/                # 스폰 전략들
│   │   │   ├── __init__.py
│   │   │   ├── random_spawn_strategy.py
│   │   │   ├── wave_spawn_strategy.py
│   │   │   └── boss_spawn_strategy.py
│   │   │
│   │   ├── movement/             # 이동 전략들
│   │   │   ├── __init__.py
│   │   │   ├── player_movement_strategy.py
│   │   │   └── ai_movement_strategy.py
│   │   │
│   │   └── coordinate_transform/ # 좌표 변환 전략들
│   │       ├── __init__.py
│   │       ├── basic_transform_strategy.py      # 기본 변환
│   │       ├── camera_based_transform_strategy.py # 카메라 기반 변환
│   │       ├── cached_transform_strategy.py     # 캐시 최적화 변환
│   │       └── spatial_transform_strategy.py    # 공간 분할 최적화 변환
│   │
│   ├── enemy_system.py           # EnemySystem
│   ├── weapon_system.py          # WeaponSystem
│   ├── projectile_system.py      # ProjectileSystem
│   ├── player_movement_system.py # PlayerMovementSystem
│   ├── render_system.py          # RenderSystem
│   ├── camera_system.py          # CameraSystem
│   └── collision_system.py       # CollisionSystem
│
├── events/                       # Producer-Consumer 이벤트 시스템
│   ├── __init__.py
│   ├── core/                     # 이벤트 시스템 코어
│   │   ├── __init__.py
│   │   ├── base_event.py         # BaseEvent ABC - 모든 이벤트의 기본 구조
│   │   ├── event_producer.py     # EventProducer<T> - 타입 안전한 이벤트 생산자
│   │   ├── event_consumer.py     # EventConsumer<T> - 타입 안전한 이벤트 소비자  
│   │   ├── event_tunnel_manager.py # EventTunnelManager - Producer/Consumer 쌍 관리
│   │   └── event_types.py        # EventType Enum - 이벤트 타입 정의
│   │
│   ├── types/                    # 구체적인 이벤트 타입들
│   │   ├── __init__.py
│   │   ├── enemy_death_event.py
│   │   ├── level_up_event.py
│   │   ├── experience_gain_event.py
│   │   ├── projectile_hit_event.py
│   │   └── camera_offset_changed_event.py
│   │
│   └── consumers/                # 이벤트 컨슈머들
│       ├── __init__.py
│       ├── experience_consumer.py
│       ├── weapon_upgrade_consumer.py
│       └── damage_consumer.py
│
├── components/                   # 게임 컴포넌트들
│   ├── __init__.py
│   ├── core/                     # 핵심 컴포넌트
│   │   ├── __init__.py
│   │   ├── position_component.py
│   │   ├── velocity_component.py
│   │   ├── health_component.py
│   │   └── render_component.py
│   │
│   ├── gameplay/                 # 게임플레이 컴포넌트
│   │   ├── __init__.py
│   │   ├── player_component.py
│   │   ├── enemy_component.py
│   │   ├── weapon_component.py
│   │   ├── projectile_component.py
│   │   └── experience_component.py
│   │
│   └── systems/                  # 시스템별 컴포넌트
│       ├── __init__.py
│       ├── camera_component.py
│       ├── collision_component.py
│       └── player_movement_component.py
│
├── dto/                          # 데이터 전송 객체들 (타입 안전성)
│   ├── __init__.py
│   ├── creation/                 # 생성 DTO들
│   │   ├── __init__.py
│   │   ├── enemy_create_dto.py
│   │   ├── weapon_create_dto.py
│   │   ├── projectile_create_dto.py
│   │   └── player_create_dto.py
│   │
│   ├── update/                   # 업데이트 DTO들
│   │   ├── __init__.py
│   │   ├── enemy_update_dto.py
│   │   ├── weapon_update_dto.py
│   │   └── experience_update_dto.py
│   │
│   └── query/                    # 조회 DTO들
│       ├── __init__.py
│       ├── spawn_query_dto.py
│       └── target_query_dto.py
│
├── utils/                        # 유틸리티 클래스들
│   ├── __init__.py
│   ├── vector2.py                # Vector2 클래스
│   ├── math_utils.py             # 수학 유틸리티
│   ├── collision_utils.py        # 충돌 계산 유틸리티
│   └── performance_utils.py      # 성능 측정 유틸리티
│
├── factories/                    # 팩토리 패턴 (복잡한 객체 생성)
│   ├── __init__.py
│   ├── entity_factory.py         # 엔티티 팩토리
│   ├── system_factory.py         # 시스템 팩토리
│   └── manager_factory.py        # 매니저 팩토리
│
├── orchestration/                # 시스템 조율 및 게임 루프
│   ├── __init__.py
│   ├── system_orchestrator.py    # SystemOrchestrator
│   ├── game_loop.py              # GameLoop
│   └── application.py            # Application (진입점)
│
└── config/                       # 설정 및 상수들
    ├── __init__.py
    ├── game_config.py            # 게임 설정값들
    ├── system_priorities.py      # 시스템 우선순위 상수
    └── enums.py                  # 게임 열거형들 (WeaponType, EnemyType 등)
```

## 📝 코딩 패턴 및 규칙

### 1. 인터페이스 정의 규칙

#### **Manager 인터페이스 패턴**
```python
# managers/i_enemy_manager.py
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..dto.creation.enemy_create_dto import EnemyCreateDTO
    from ..dto.update.enemy_update_dto import EnemyUpdateDTO
    from ..ecs.entity import Entity

class IEnemyManager(ABC):
    """적 관리자 인터페이스 - 다형성과 캡슐화 보장"""
    
    # 정적 팩토리 메서드 (구현체 숨김)
    @staticmethod
    def create_basic() -> 'IEnemyManager':
        """기본 적 관리자 생성 (구현체 숨김)"""
        from .enemy.basic_enemy_manager import BasicEnemyManager
        return BasicEnemyManager()
    
    @staticmethod  
    def create_boss() -> 'IEnemyManager':
        """보스 특화 관리자 생성 (구현체 숨김)"""
        from .enemy.boss_enemy_manager import BossEnemyManager
        return BossEnemyManager()
    
    @staticmethod
    def create_spawning() -> 'IEnemyManager':
        """스포닝 특화 관리자 생성 (구현체 숨김)"""
        from .enemy.spawning_enemy_manager import SpawningEnemyManager
        return SpawningEnemyManager()
    
    # 추상 메서드들
    @abstractmethod
    def create_enemy(self, dto: 'EnemyCreateDTO') -> 'Entity':
        """적 엔티티 생성"""
        pass
    
    @abstractmethod
    def update_enemy_stats(self, entity: 'Entity', dto: 'EnemyUpdateDTO') -> None:
        """적 상태 업데이트"""
        pass
    
    @abstractmethod
    def get_enemy_count(self) -> int:
        """활성 적 수 조회"""
        pass
    
    @abstractmethod
    def cleanup_dead_enemies(self) -> list['Entity']:
        """죽은 적들 정리"""
        pass
```

#### **Strategy 인터페이스 패턴**
```python
# systems/strategies/i_attack_strategy.py
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ...dto.creation.projectile_create_dto import ProjectileCreateDTO
    from ...ecs.entity import Entity
    from ...utils.vector2 import Vector2

class IAttackStrategy(ABC):
    """공격 전략 인터페이스"""
    
    # 정적 팩토리 메서드
    @staticmethod
    def create_direct() -> 'IAttackStrategy':
        """직접 공격 전략 생성"""
        from .attack.direct_attack_strategy import DirectAttackStrategy
        return DirectAttackStrategy()
    
    @staticmethod
    def create_area(radius: float) -> 'IAttackStrategy':
        """광역 공격 전략 생성"""
        from .attack.area_attack_strategy import AreaAttackStrategy
        return AreaAttackStrategy(radius)
    
    @staticmethod
    def create_homing(strength: float) -> 'IAttackStrategy':
        """유도 공격 전략 생성"""
        from .attack.homing_attack_strategy import HomingAttackStrategy
        return HomingAttackStrategy(strength)
    
    # 추상 메서드들
    @abstractmethod
    def find_target(self, attacker: 'Entity', available_targets: list['Entity']) -> 'Entity | None':
        """공격 대상 선택"""
        pass
    
    @abstractmethod
    def create_attack_dto(self, attacker: 'Entity', target: 'Entity') -> 'ProjectileCreateDTO':
        """공격 DTO 생성"""
        pass
    
    @abstractmethod
    def get_strategy_name(self) -> str:
        """전략 이름 반환"""
        pass
```

### 2. 구현체 작성 규칙

#### **Manager 구현체 패턴**
```python
# managers/enemy/basic_enemy_manager.py
from typing import TYPE_CHECKING

from ..i_enemy_manager import IEnemyManager

if TYPE_CHECKING:
    from ...dto.creation.enemy_create_dto import EnemyCreateDTO
    from ...dto.update.enemy_update_dto import EnemyUpdateDTO
    from ...ecs.entity import Entity
    from ...managers.i_entity_manager import IEntityManager

class BasicEnemyManager(IEnemyManager):
    """기본 적 관리자 구현체 - 일반적인 적 관리 기능 제공"""
    
    def __init__(self, entity_manager: 'IEntityManager') -> None:
        """의존성 주입으로 EntityManager 받기"""
        # AI-NOTE : 2025-08-17 의존성 주입을 통한 테스트 용이성 확보
        # - 이유: Mock EntityManager 주입으로 단위 테스트 격리
        # - 요구사항: Manager는 EntityManager 인터페이스만 의존
        # - 비즈니스 가치: 안정적인 적 관리 로직 보장
        self._entity_manager = entity_manager
    
    def create_enemy(self, dto: 'EnemyCreateDTO') -> 'Entity':
        """기본 적 엔티티 생성"""
        # 1. 엔티티 생성
        entity = self._entity_manager.create_entity()
        
        # 2. 컴포넌트 추가 (DTO 기반)
        self._add_basic_components(entity, dto)
        self._add_ai_component(entity, dto)
        self._add_physics_components(entity, dto)
        
        return entity
    
    def update_enemy_stats(self, entity: 'Entity', dto: 'EnemyUpdateDTO') -> None:
        """적 상태 업데이트"""
        # DTO 기반 상태 업데이트 로직
        pass
    
    def get_enemy_count(self) -> int:
        """활성 적 수 조회"""
        # EntityManager를 통한 적 수 조회
        pass
    
    def cleanup_dead_enemies(self) -> list['Entity']:
        """죽은 적들 정리"""
        # 죽은 적 정리 로직
        pass
    
    def _add_basic_components(self, entity: 'Entity', dto: 'EnemyCreateDTO') -> None:
        """기본 컴포넌트 추가 (private 메서드)"""
        pass
```

#### **Strategy 구현체 패턴**
```python
# systems/strategies/attack/direct_attack_strategy.py
from typing import TYPE_CHECKING

from ..i_attack_strategy import IAttackStrategy

if TYPE_CHECKING:
    from ....dto.creation.projectile_create_dto import ProjectileCreateDTO
    from ....ecs.entity import Entity

class DirectAttackStrategy(IAttackStrategy):
    """직접 공격 전략 - 가장 가까운 적을 직선으로 공격"""
    
    def find_target(self, attacker: 'Entity', available_targets: list['Entity']) -> 'Entity | None':
        """가장 가까운 적 선택"""
        # AI-NOTE : 2025-08-17 거리 기반 타겟 선택 로직
        # - 이유: 직접 공격은 가장 가까운 적을 우선 타겟팅
        # - 요구사항: 유클리드 거리 계산으로 최근접 적 선택
        # - 최적화: 거리 제곱 비교로 제곱근 연산 생략
        if not available_targets:
            return None
        
        attacker_pos = self._get_position(attacker)
        if not attacker_pos:
            return None
        
        closest_target = None
        min_distance_sq = float('inf')
        
        for target in available_targets:
            target_pos = self._get_position(target)
            if not target_pos:
                continue
            
            # 거리 제곱 계산 (제곱근 연산 생략)
            distance_sq = (
                (target_pos.x - attacker_pos.x) ** 2 + 
                (target_pos.y - attacker_pos.y) ** 2
            )
            
            if distance_sq < min_distance_sq:
                min_distance_sq = distance_sq
                closest_target = target
        
        return closest_target
    
    def create_attack_dto(self, attacker: 'Entity', target: 'Entity') -> 'ProjectileCreateDTO':
        """직선 공격 DTO 생성"""
        # DTO 생성 로직
        pass
    
    def get_strategy_name(self) -> str:
        """전략 이름 반환"""
        return "DirectAttack"
    
    def _get_position(self, entity: 'Entity') -> 'Vector2 | None':
        """엔티티 위치 조회 (private 헬퍼 메서드)"""
        pass
```

### 3. System 작성 규칙

#### **System 구현 패턴**
```python
# systems/weapon_system.py
from typing import TYPE_CHECKING

from ..ecs.system import System

if TYPE_CHECKING:
    from ..managers.i_weapon_manager import IWeaponManager
    from ..systems.strategies.i_attack_strategy import IAttackStrategy
    from ..events.core.event_producer import EventProducer
    from ..events.types.projectile_created_event import ProjectileCreatedEvent

class WeaponSystem(System):
    """무기 시스템 - 전략 패턴으로 다양한 공격 방식 지원"""
    
    def __init__(
        self, 
        weapon_manager: 'IWeaponManager',
        event_producer: 'EventProducer[ProjectileCreatedEvent]'
    ) -> None:
        """의존성 주입으로 Manager와 EventProducer 받기"""
        super().__init__(priority=10)
        
        # AI-NOTE : 2025-08-17 System의 Manager 의존성과 전략 패턴 적용
        # - 이유: System은 EntityManager 직접 사용하지 않고 Manager 통해 추상화
        # - 요구사항: 런타임에 공격 전략 교체 가능한 유연성 제공
        # - 비즈니스 가치: 다양한 무기 타입과 공격 패턴 지원
        self._weapon_manager = weapon_manager
        self._event_producer = event_producer
        
        # 기본 전략 설정
        from ..systems.strategies.i_attack_strategy import IAttackStrategy
        self._attack_strategy: 'IAttackStrategy' = IAttackStrategy.create_direct()
    
    def update(self, delta_time: float) -> None:
        """무기 시스템 업데이트 (entity_manager 없이!)"""
        # 1. Manager를 통해 활성 무기 조회
        active_weapons = self._weapon_manager.get_active_weapons()
        
        # 2. 각 무기별 공격 처리
        for weapon_entity in active_weapons:
            if self._weapon_manager.can_attack(weapon_entity, delta_time):
                # 3. 전략 패턴으로 공격 실행
                self._execute_attack_with_strategy(weapon_entity)
    
    def set_attack_strategy(self, strategy: 'IAttackStrategy') -> None:
        """공격 전략 교체 (런타임 변경 가능)"""
        self._attack_strategy = strategy
    
    def _execute_attack_with_strategy(self, weapon_entity: 'Entity') -> None:
        """전략 패턴을 사용한 공격 실행"""
        # 1. 전략을 통해 타겟 선택
        available_targets = self._weapon_manager.get_targets_in_range(weapon_entity)
        target = self._attack_strategy.find_target(weapon_entity, available_targets)
        
        if target:
            # 2. 전략을 통해 공격 DTO 생성
            attack_dto = self._attack_strategy.create_attack_dto(weapon_entity, target)
            
            # 3. Manager를 통해 공격 실행
            projectile_entity = self._weapon_manager.execute_attack(attack_dto)
            
            # 4. 이벤트 발행
            if projectile_entity:
                from ..events.types.projectile_created_event import ProjectileCreatedEvent
                event = ProjectileCreatedEvent(
                    projectile_entity_id=projectile_entity.entity_id,
                    weapon_entity_id=weapon_entity.entity_id,
                    timestamp=time.time()
                )
                self._event_producer.produce(event)
    
    def initialize(self) -> None:
        """시스템 초기화"""
        super().initialize()
        # 초기화 로직
    
    def get_required_components(self) -> list[type]:
        """이 시스템이 필요로 하는 컴포넌트 타입들"""
        from ..components.gameplay.weapon_component import WeaponComponent
        from ..components.core.position_component import PositionComponent
        return [WeaponComponent, PositionComponent]
```

### 4. Event 시스템 상세 설명

#### **4.1. events/core/ 구조 상세**

**BaseEvent**: 모든 이벤트의 공통 인터페이스
```python
# events/core/base_event.py
from abc import ABC, abstractmethod
import time

class BaseEvent(ABC):
    """모든 이벤트의 기본 구조"""
    
    def __init__(self) -> None:
        self.timestamp: float = time.time()
    
    @abstractmethod
    def get_event_type(self) -> 'EventType':
        """이벤트 타입 반환 (Enum 사용)"""
        pass
    
    @abstractmethod
    def validate(self) -> bool:
        """이벤트 데이터 검증"""
        pass
```

**EventProducer**: 타입 안전한 이벤트 생산자
```python
# events/core/event_producer.py  
from collections import deque
from typing import Generic, TypeVar

T = TypeVar('T', bound='BaseEvent')

class EventProducer(Generic[T]):
    """타입 안전한 이벤트 생산자"""
    
    def __init__(self, event_type: type[T], max_queue_size: int = 1000) -> None:
        self._event_type = event_type
        self._queue: deque[T] = deque(maxlen=max_queue_size)
    
    def produce(self, event: T) -> bool:
        """이벤트 생산 (타입 검증 포함)"""
        if not isinstance(event, self._event_type):
            raise TypeError(f"Expected {self._event_type.__name__}, got {type(event).__name__}")
        
        self._queue.append(event)
        return True
```

**EventConsumer**: 타입 안전한 이벤트 소비자
```python
# events/core/event_consumer.py
from collections import deque  
from typing import Generic, TypeVar

T = TypeVar('T', bound='BaseEvent')

class EventConsumer(Generic[T]):
    """타입 안전한 이벤트 소비자"""
    
    def __init__(self, event_type: type[T]) -> None:
        self._event_type = event_type
        self._queue: deque[T] = deque()
    
    def consume_next(self) -> T | None:
        """다음 이벤트 소비"""
        try:
            return self._queue.popleft()
        except IndexError:
            return None
    
    def is_empty(self) -> bool:
        """큐가 비어있는지 확인"""
        return len(self._queue) == 0
```

**EventTunnelManager**: Producer/Consumer 쌍 관리
```python
# events/core/event_tunnel_manager.py
from typing import TypeVar, Generic

T = TypeVar('T', bound='BaseEvent')

class EventTunnelManager:
    """Producer와 Consumer 쌍을 관리하는 터널 매니저"""
    PRODUCER = 1
    CONSUMER = 1
    
    def __init__(self) -> None:
        self._tunnels: dict[type, tuple[EventProducer, EventConsumer]] = {}
    
    def create_tunnel[T](self, event_type: type[T]) -> tuple[EventProducer[T], EventConsumer[T]]:
        """이벤트 타입별 Producer/Consumer 쌍 생성"""
        producer = EventProducer(event_type)
        consumer = EventConsumer(event_type)
        self._tunnels[event_type] = (producer, consumer)
        return producer, consumer
    
    def get_producer[T](self, event_type: type[T]) -> EventProducer[T]:
        """Producer 조회"""
        if event_type not in self._tunnels:
            self.create_tunnel(event_type)
        return self._tunnels[event_type][self.PRODUCER]
    
    def get_consumer[T](self, event_type: type[T]) -> EventConsumer[T]:
        """Consumer 조회"""
        if event_type not in self._tunnels:
            self.create_tunnel(event_type)
        return self._tunnels[event_type][self.CONSUMER]
    
    def process_all_tunnels(self) -> dict[type, int]:
        """모든 터널의 이벤트 전송 (Producer → Consumer)"""
        processed_counts = {}
        
        for event_type, (producer, consumer) in self._tunnels.items():
            count = 0
            while not producer.is_empty():
                event = producer.consume_next()
                if event:
                    consumer._queue.append(event)  # Producer에서 Consumer로 전송
                    count += 1
            processed_counts[event_type] = count
        
        return processed_counts
```

**EventType Enum**: 이벤트 타입 정의
```python
# events/core/event_types.py
from enum import IntEnum

class EventType(IntEnum):
    """이벤트 타입 열거형"""
    ENEMY_DEATH = 0
    LEVEL_UP = 1
    EXPERIENCE_GAIN = 2
    PROJECTILE_HIT = 3
    CAMERA_OFFSET_CHANGED = 4
    WEAPON_UPGRADE = 5
    
    @property
    def display_name(self) -> str:
        """이벤트 타입 표시명"""
        names = {
            self.ENEMY_DEATH: "적 사망",
            self.LEVEL_UP: "레벨업",
            self.EXPERIENCE_GAIN: "경험치 획득",
            self.PROJECTILE_HIT: "투사체 명중",
            self.CAMERA_OFFSET_CHANGED: "카메라 오프셋 변경",
            self.WEAPON_UPGRADE: "무기 업그레이드"
        }
        return names.get(self, "알 수 없는 이벤트")
```

### 5. Event 시스템 작성 규칙

#### **Event 타입 정의**
```python
# events/types/enemy_death_event.py
import time
from dataclasses import dataclass
from typing import TYPE_CHECKING

from ..core.base_event import BaseEvent

if TYPE_CHECKING:
    from ...utils.vector2 import Vector2

@dataclass
class EnemyDeathEvent(BaseEvent):
    """적 사망 이벤트"""
    
    enemy_entity_id: str
    death_position: 'Vector2'
    experience_reward: int
    killer_entity_id: str | None = None
    
    def __post_init__(self) -> None:
        """이벤트 초기화 후 타임스탬프 설정"""
        if not hasattr(self, 'timestamp'):
            self.timestamp = time.time()
    
    def validate(self) -> bool:
        """이벤트 데이터 검증"""
        return (
            bool(self.enemy_entity_id) and
            self.death_position is not None and
            self.experience_reward >= 0
        )
    
    def get_event_type(self) -> 'EventType':
        """이벤트 타입 반환"""
        from ...config.enums import EventType
        return EventType.ENEMY_DEATH
```

#### **Event Consumer 정의 (System 기반)**
```python
# events/consumers/experience_consumer.py
from typing import TYPE_CHECKING

from ...ecs.system import System
from ..core.event_consumer import EventConsumer
from ..types.enemy_death_event import EnemyDeathEvent

if TYPE_CHECKING:
    from ...managers.i_experience_manager import IExperienceManager

class ExperienceConsumerSystem(System):
    """경험치 처리 전용 컨슈머 시스템 - System을 상속하여 시스템으로 동작"""
    
    def __init__(self, experience_manager: 'IExperienceManager') -> None:
        """경험치 관리자 의존성 주입"""
        super().__init__(priority=20)  # Experience 처리는 후순위
        self._experience_manager = experience_manager
        self._event_consumer: EventConsumer[EnemyDeathEvent] = EventConsumer(EnemyDeathEvent)
    
    def update(self, delta_time: float) -> None:
        """System 업데이트 - 이벤트 컨슈머로 동작"""
        # EventConsumer를 통해 이벤트 처리
        while not self._event_consumer.is_empty():
            event = self._event_consumer.consume_next()
            if event:
                self._process_enemy_death_event(event)
    
    def _process_enemy_death_event(self, event: EnemyDeathEvent) -> None:
        """적 사망 이벤트 처리 - 경험치 지급"""
        # AI-NOTE : 2025-08-17 경험치 지급 로직
        # - 이유: 적 사망 시 플레이어에게 경험치 지급하여 성장 요소 제공
        # - 요구사항: 이벤트 기반 느슨한 결합으로 시스템 독립성 확보
        # - 비즈니스 가치: 플레이어 진행도와 성취감 향상
        try:
            self._experience_manager.grant_experience(
                amount=event.experience_reward,
                position=event.death_position,
                killer_entity_id=event.killer_entity_id
            )
        except Exception as e:
            # 로깅하되 다른 컨슈머에 영향 주지 않음
            import logging
            logging.error(f"Failed to grant experience: {e}")
    
    def initialize(self) -> None:
        """시스템 초기화"""
        super().initialize()
        # EventTunnelManager에 Consumer 등록
        # (실제 구현에서는 EventTunnelManager.register_consumer() 호출)
    
    def get_required_components(self) -> list[type]:
        """이 시스템이 필요로 하는 컴포넌트 (없음 - 이벤트만 처리)"""
        return []
```

### 5. DTO 작성 규칙

#### **Creation DTO 패턴**
```python
# dto/creation/enemy_create_dto.py
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ...utils.vector2 import Vector2
    from ...config.enums import EnemyType, AIType

@dataclass
class EnemyCreateDTO:
    """적 생성 데이터 전송 객체"""
    
    spawn_position: 'Vector2'
    enemy_type: 'EnemyType'
    difficulty_scale: float = 1.0
    ai_type: 'AIType | None' = None
    base_health: int = 100
    base_speed: float = 80.0
    experience_reward: int = 10
    
    def validate(self) -> bool:
        """DTO 데이터 검증"""
        return (
            self.spawn_position is not None and
            self.difficulty_scale > 0 and
            self.base_health > 0 and
            self.base_speed > 0 and
            self.experience_reward >= 0
        )
    
    def get_scaled_health(self) -> int:
        """난이도 스케일 적용된 체력 반환"""
        return int(self.base_health * self.difficulty_scale)
    
    def get_scaled_speed(self) -> float:
        """난이도 스케일 적용된 속도 반환"""
        return self.base_speed * self.difficulty_scale
    
    def get_additional_data(self, key: str, default_value=None):
        """추가 데이터 조회 (확장성을 위한 메서드)"""
        # 필요시 추가 속성들을 위한 확장 포인트
        return default_value
```

## 🔄 마이그레이션 단계별 작업 계획

### Phase 1: 기반 구조 구축 (1-2일)
1. **ECS Framework 순수화**
   - `src/ecs/` 폴더 생성
   - 기존 `src/core/entity.py`, `component.py`, `system.py` 이동
   - `System.update()` 인터페이스 변경 (entity_manager 제거)

2. **Manager 인터페이스 추출**
   - `src/managers/` 폴더 구조 생성
   - 각 Manager의 인터페이스 파일 생성
   - 정적 팩토리 메서드 패턴 적용

3. **DTO 계층 구축**
   - `src/dto/` 폴더 구조 생성
   - Creation, Update, Query DTO 정의

### Phase 2: Event 시스템 교체 (2-3일)
1. **Producer-Consumer 구현**
   - `src/events/core/` EventProducer, EventConsumer, EventTunnelManager 구현
   - 타입 안전성 보장을 위한 Generic 클래스 설계

2. **Event 타입 마이그레이션**
   - 기존 `src/core/events/` → `src/events/types/` 이동
   - BaseEvent 인터페이스 표준화

3. **Consumer 구현**
   - `src/events/consumers/` 생성
   - ExperienceConsumer, WeaponUpgradeConsumer 등 구현

### Phase 3: Strategy 패턴 적용 (2-3일)
1. **Strategy 인터페이스 정의**
   - `src/systems/strategies/` 구조 생성
   - Attack, Spawn, Movement, CoordinateTransform 전략 인터페이스

2. **System 리팩토링**
   - 기존 System들을 Strategy 패턴으로 변경
   - Manager 의존성 주입으로 EntityManager 직접 접근 제거

3. **Coordinate 시스템 통합**
   - 기존 `coordination/` 폴더 해체
   - Manager와 Strategy 계층으로 재배치

### Phase 4: Manager 구현체 분리 (1-2일)
1. **기능별 Manager 구현체 생성**
   - Basic, Boss, Synergy 등 특화된 구현체 생성
   - 각 구현체의 단일 책임 원칙 적용

2. **Factory 패턴 구현**
   - `src/factories/` 복잡한 객체 생성 로직 분리
   - System, Manager 팩토리 구현

### Phase 5: 통합 및 테스트 (1-2일)
1. **Orchestration 계층 구성**
   - `src/orchestration/` 최상위 조율 계층
   - SystemOrchestrator, GameLoop, Application 구현

2. **종합 테스트 및 최적화**
   - 전체 시스템 통합 테스트
   - 성능 측정 및 최적화

## 📋 코딩 표준 및 주의사항

### 1. 명명 규칙
- **인터페이스**: `I` 접두사 (`IEnemyManager`, `IAttackStrategy`)
- **구현체**: 기능 명시 (`BasicEnemyManager`, `DirectAttackStrategy`)
- **DTO**: 용도 명시 (`EnemyCreateDTO`, `WeaponUpdateDTO`)
- **Event**: 동작 명시 (`EnemyDeathEvent`, `LevelUpEvent`)

### 2. 의존성 규칙
- **상위 계층 → 하위 계층**: 허용
- **하위 계층 → 상위 계층**: 금지
- **인터페이스 의존**: 권장
- **구체 클래스 의존**: 최소화

### 3. AI 주석 규칙
```python
# AI-NOTE : 날짜 비즈니스 로직 설명
# - 이유: 왜 이렇게 구현했는지
# - 요구사항: 어떤 요구사항을 반영했는지
# - 비즈니스 가치: 게임에서의 의미와 효과

# AI-DEV : 기술적 해결책 설명  
# - 문제: 어떤 기술적 문제가 있었는지
# - 해결책: 어떻게 해결했는지
# - 주의사항: 유지보수 시 주의할 점
```

### 4. 타입 힌트 규칙
- **Python 3.13+ 네이티브 문법** 사용
- **TYPE_CHECKING** 가드로 순환 의존성 방지
- **제네릭** 타입 적극 활용 (`EventProducer[T]`, `EventConsumer[T]`)

### 5. 테스트 전략
- **인터페이스 기반 Mock** 객체 활용
- **DTO 기반 테스트 데이터** 관리
- **Strategy 패턴별 독립 테스트**
- **Event 시스템 격리 테스트**

## 🎯 성공 지표

### 1. 아키텍처 품질
- [ ] 모든 System이 EntityManager 직접 접근 제거
- [ ] Manager 인터페이스 기반 다형성 구현
- [ ] Producer-Consumer 이벤트 시스템 완전 전환
- [ ] Strategy 패턴으로 런타임 행동 변경 가능

### 2. 코드 품질
- [ ] 타입 힌트 100% 적용
- [ ] 순환 의존성 0개
- [ ] AI 주석으로 비즈니스 로직 문서화
- [ ] 단위 테스트 80% 이상 커버리지

### 3. 성능 목표
- [ ] 게임 실행 시 40+ FPS 유지
- [ ] Event 처리 지연시간 1ms 이하
- [ ] Manager 교체 시 성능 영향 5% 이하

---

**작성자**: Claude Code Assistant  
**승인자**: 개발팀  
**검토 주기**: 매일 진행상황 체크  
**완료 예정일**: 2025-08-24