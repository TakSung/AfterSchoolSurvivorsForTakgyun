# ECS 아키텍처 리팩토링 작업 계획서
**날짜**: 2025-08-17  
**목표**: Design2.md 기반 Producer-Consumer 이벤트 시스템 및 전략 패턴 적용

## 📁 최종 폴더 구조

### 전체 구조 개요
```
src/
├── ecs/                          # ECS Framework (최하위 계층)
│   ├── __init__.py
│   ├── entity.py                 # Entity 클래스
│   ├── component.py              # Component ABC
│   ├── system.py                 # ISystem, System ABC
│   └── component_registry.py     # IComponentRegistry, ComponentRegistry
│
├── managers/                     # 특화된 도메인 관리자들
│   ├── __init__.py
│   ├── i_entity_manager.py       # IEntityManager 인터페이스 (상단)
│   ├── i_enemy_manager.py        # IEnemyManager 인터페이스 (상단)
│   ├── i_weapon_manager.py       # IWeaponManager 인터페이스 (상단)
│   ├── i_projectile_manager.py   # IProjectileManager 인터페이스 (상단)
│   ├── i_experience_manager.py   # IExperienceManager 인터페이스 (상단)
│   ├── i_coordinate_manager.py   # ICoordinateManager 인터페이스 (상단)
│   ├── i_game_state_manager.py   # IGameStateManager 인터페이스 (상단)
│   ├── i_difficulty_manager.py   # IDifficultyManager 인터페이스 (상단)
│   ├── i_time_manager.py         # ITimeManager 인터페이스 (상단)
│   │
│   ├── entity/                   # EntityManager 구현체들
│   │   ├── __init__.py
│   │   ├── crud_entity_manager.py       # 순수 CRUD 구현
│   │   └── cached_entity_manager.py     # 캐시 최적화 구현
│   │
│   ├── enemy/                    # EnemyManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_enemy_manager.py       # 기본 적 관리
│   │   ├── boss_enemy_manager.py        # 보스 특화 관리
│   │   └── spawning_enemy_manager.py    # 스포닝 특화 관리
│   │
│   ├── weapon/                   # WeaponManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_weapon_manager.py      # 기본 무기 관리
│   │   ├── synergy_weapon_manager.py    # 시너지 특화 관리
│   │   └── upgrade_weapon_manager.py    # 업그레이드 특화 관리
│   │
│   ├── projectile/               # ProjectileManager 구현체들
│   │   ├── __init__.py
│   │   ├── physics_projectile_manager.py # 물리 기반 관리
│   │   └── collision_projectile_manager.py # 충돌 특화 관리
│   │
│   ├── experience/               # ExperienceManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_experience_manager.py  # 기본 경험치 관리
│   │   └── leveling_experience_manager.py # 레벨링 특화 관리
│   │
│   ├── coordinate/               # CoordinateManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_coordinate_manager.py    # 기본 좌표 관리
│   │   └── cached_coordinate_manager.py   # 캐시 최적화 관리
│   │
│   ├── game_state/               # GameStateManager 구현체들
│   │   ├── __init__.py
│   │   ├── basic_game_state_manager.py    # 기본 상태 관리
│   │   └── persistent_game_state_manager.py # 영속성 상태 관리
│   │
│   ├── difficulty/               # DifficultyManager 구현체들
│   │   ├── __init__.py
│   │   ├── linear_difficulty_manager.py   # 선형 난이도 증가
│   │   └── adaptive_difficulty_manager.py # 적응형 난이도 조정
│   │
│   └── time/                     # TimeManager 구현체들
│       ├── __init__.py
│       ├── basic_time_manager.py          # 기본 시간 관리
│       └── scaled_time_manager.py         # 시간 배율 관리
│
├── systems/                      # 게임 로직 + 전략 패턴
│   ├── __init__.py
│   ├── strategies/               # 전략 패턴 구현체들
│   │   ├── __init__.py
│   │   ├── i_attack_strategy.py      # IAttackStrategy 인터페이스 (상단)
│   │   ├── i_spawn_strategy.py       # ISpawnStrategy 인터페이스 (상단)
│   │   ├── i_movement_strategy.py    # IMovementStrategy 인터페이스 (상단)
│   │   ├── i_coordinate_transform_strategy.py  # ICoordinateTransformStrategy 인터페이스 (상단)
│   │   │
│   │   ├── attack/               # 공격 전략들
│   │   │   ├── __init__.py
│   │   │   ├── direct_attack_strategy.py
│   │   │   ├── area_attack_strategy.py
│   │   │   └── homing_attack_strategy.py
│   │   │
│   │   ├── spawn/                # 스폰 전략들
│   │   │   ├── __init__.py
│   │   │   ├── random_spawn_strategy.py
│   │   │   ├── wave_spawn_strategy.py
│   │   │   └── boss_spawn_strategy.py
│   │   │
│   │   ├── movement/             # 이동 전략들
│   │   │   ├── __init__.py
│   │   │   ├── player_movement_strategy.py
│   │   │   └── ai_movement_strategy.py
│   │   │
│   │   └── coordinate_transform/ # 좌표 변환 전략들
│   │       ├── __init__.py
│   │       ├── basic_transform_strategy.py      # 기본 변환
│   │       ├── camera_based_transform_strategy.py # 카메라 기반 변환
│   │       ├── cached_transform_strategy.py     # 캐시 최적화 변환
│   │       └── spatial_transform_strategy.py    # 공간 분할 최적화 변환
│   │
│   ├── enemy_system.py           # EnemySystem
│   ├── weapon_system.py          # WeaponSystem
│   ├── projectile_system.py      # ProjectileSystem
│   ├── player_movement_system.py # PlayerMovementSystem
│   ├── render_system.py          # RenderSystem
│   ├── camera_system.py          # CameraSystem
│   ├── collision_system.py       # CollisionSystem
│   │
│   ├── events/                   # 이벤트 처리 시스템들 (Consumer HAS-A)
│   │   ├── __init__.py
│   │   ├── experience_system.py  # ExperienceSystem (EventConsumer를 HAS-A)
│   │   ├── weapon_upgrade_system.py # WeaponUpgradeSystem (EventConsumer를 HAS-A)
│   │   └── damage_system.py      # DamageSystem (EventConsumer를 HAS-A)
│   │
│   └── coordination/             # 좌표 및 조정 시스템들 (기존 coordination/ 이동)
│
├── events/                       # Producer-Consumer 이벤트 시스템
│   ├── __init__.py
│   ├── core/                     # 이벤트 시스템 코어
│   │   ├── __init__.py
│   │   ├── base_event.py         # BaseEvent ABC - 모든 이벤트의 기본 구조
│   │   ├── event_producer.py     # EventProducer<T> - 타입 안전한 이벤트 생산자
│   │   ├── event_consumer.py     # EventConsumer<T> - 타입 안전한 이벤트 소비자  
│   │   ├── event_tunnel_manager.py # EventTunnelManager - Producer/Consumer 쌍 관리
│   │   └── event_types.py        # EventType Enum - 이벤트 타입 정의
│   │
│   ├── types/                    # 구체적인 이벤트 타입들
│   │   ├── __init__.py
│   │   ├── enemy_death_event.py
│   │   ├── level_up_event.py
│   │   ├── experience_gain_event.py
│   │   ├── projectile_hit_event.py
│   │   └── camera_offset_changed_event.py
│   │
│   └── consumers/                # 순수 EventConsumer만 (큐 처리)
│       └── __init__.py           # Consumer는 core/event_consumer.py만 사용
│
├── components/                   # 게임 컴포넌트들
│   ├── __init__.py
│   ├── core/                     # 핵심 컴포넌트
│   │   ├── __init__.py
│   │   ├── position_component.py
│   │   ├── velocity_component.py
│   │   ├── health_component.py
│   │   └── render_component.py
│   │
│   ├── gameplay/                 # 게임플레이 컴포넌트
│   │   ├── __init__.py
│   │   ├── player_component.py
│   │   ├── enemy_component.py
│   │   ├── weapon_component.py
│   │   ├── projectile_component.py
│   │   └── experience_component.py
│   │
│   └── systems/                  # 시스템별 컴포넌트
│       ├── __init__.py
│       ├── camera_component.py
│       ├── collision_component.py
│       └── player_movement_component.py
│
├── dto/                          # 데이터 전송 객체들 (타입 안전성)
│   ├── __init__.py
│   ├── creation/                 # 생성 DTO들
│   │   ├── __init__.py
│   │   ├── enemy_create_dto.py
│   │   ├── weapon_create_dto.py
│   │   ├── projectile_create_dto.py
│   │   └── player_create_dto.py
│   │
│   ├── update/                   # 업데이트 DTO들
│   │   ├── __init__.py
│   │   ├── enemy_update_dto.py
│   │   ├── weapon_update_dto.py
│   │   └── experience_update_dto.py
│   │
│   └── query/                    # 조회 DTO들
│       ├── __init__.py
│       ├── spawn_query_dto.py
│       └── target_query_dto.py
│
├── utils/                        # 유틸리티 클래스들
│   ├── __init__.py
│   ├── vector2.py                # Vector2 클래스
│   ├── math_utils.py             # 수학 유틸리티
│   ├── collision_utils.py        # 충돌 계산 유틸리티
│   └── performance_utils.py      # 성능 측정 유틸리티
│
├── factories/                    # 팩토리 패턴 (복잡한 객체 생성)
│   ├── __init__.py
│   ├── entity_factory.py         # 엔티티 팩토리
│   ├── system_factory.py         # 시스템 팩토리
│   └── manager_factory.py        # 매니저 팩토리
│
├── orchestration/                # 시스템 조율 및 게임 루프
│   ├── __init__.py
│   ├── system_orchestrator.py    # SystemOrchestrator
│   ├── game_loop.py              # GameLoop
│   └── application.py            # Application (진입점)
│
└── config/                       # 설정 및 상수들
    ├── __init__.py
    ├── game_config.py            # 게임 설정값들
    ├── system_priorities.py      # 시스템 우선순위 상수
    └── enums.py                  # 게임 열거형들 (WeaponType, EnemyType 등)
```

## 📝 코딩 패턴 및 규칙

### 1. 인터페이스 정의 규칙

#### **Manager 인터페이스 패턴**
```python
# managers/i_enemy_manager.py
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..dto.creation.enemy_create_dto import EnemyCreateDTO
    from ..dto.update.enemy_update_dto import EnemyUpdateDTO
    from ..ecs.entity import Entity

class IEnemyManager(ABC):
    """적 관리자 인터페이스 - 다형성과 캡슐화 보장"""
    
    # 정적 팩토리 메서드 (구현체 숨김)
    @staticmethod
    def create_basic() -> 'IEnemyManager':
        """기본 적 관리자 생성 (구현체 숨김)"""
        from .enemy.basic_enemy_manager import BasicEnemyManager
        return BasicEnemyManager()
    
    @staticmethod  
    def create_boss() -> 'IEnemyManager':
        """보스 특화 관리자 생성 (구현체 숨김)"""
        from .enemy.boss_enemy_manager import BossEnemyManager
        return BossEnemyManager()
    
    @staticmethod
    def create_spawning() -> 'IEnemyManager':
        """스포닝 특화 관리자 생성 (구현체 숨김)"""
        from .enemy.spawning_enemy_manager import SpawningEnemyManager
        return SpawningEnemyManager()
    
    # 추상 메서드들
    @abstractmethod
    def create_enemy(self, dto: 'EnemyCreateDTO') -> 'Entity':
        """적 엔티티 생성"""
        pass
    
    @abstractmethod
    def update_enemy_stats(self, entity: 'Entity', dto: 'EnemyUpdateDTO') -> None:
        """적 상태 업데이트"""
        pass
    
    @abstractmethod
    def get_enemy_count(self) -> int:
        """활성 적 수 조회"""
        pass
    
    @abstractmethod
    def cleanup_dead_enemies(self) -> list['Entity']:
        """죽은 적들 정리"""
        pass
```

#### **Strategy 인터페이스 패턴**
```python
# systems/strategies/i_attack_strategy.py
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ...dto.creation.projectile_create_dto import ProjectileCreateDTO
    from ...ecs.entity import Entity
    from ...utils.vector2 import Vector2

class IAttackStrategy(ABC):
    """공격 전략 인터페이스"""
    
    # 정적 팩토리 메서드
    @staticmethod
    def create_direct() -> 'IAttackStrategy':
        """직접 공격 전략 생성"""
        from .attack.direct_attack_strategy import DirectAttackStrategy
        return DirectAttackStrategy()
    
    @staticmethod
    def create_area(radius: float) -> 'IAttackStrategy':
        """광역 공격 전략 생성"""
        from .attack.area_attack_strategy import AreaAttackStrategy
        return AreaAttackStrategy(radius)
    
    @staticmethod
    def create_homing(strength: float) -> 'IAttackStrategy':
        """유도 공격 전략 생성"""
        from .attack.homing_attack_strategy import HomingAttackStrategy
        return HomingAttackStrategy(strength)
    
    # 추상 메서드들
    @abstractmethod
    def find_target(self, attacker: 'Entity', available_targets: list['Entity']) -> 'Entity | None':
        """공격 대상 선택"""
        pass
    
    @abstractmethod
    def create_attack_dto(self, attacker: 'Entity', target: 'Entity') -> 'ProjectileCreateDTO':
        """공격 DTO 생성"""
        pass
    
    @abstractmethod
    def get_strategy_name(self) -> str:
        """전략 이름 반환"""
        pass
```

### 2. 구현체 작성 규칙

#### **Manager 구현체 패턴**
```python
# managers/enemy/basic_enemy_manager.py
from typing import TYPE_CHECKING

from ..i_enemy_manager import IEnemyManager

if TYPE_CHECKING:
    from ...dto.creation.enemy_create_dto import EnemyCreateDTO
    from ...dto.update.enemy_update_dto import EnemyUpdateDTO
    from ...ecs.entity import Entity
    from ...managers.i_entity_manager import IEntityManager

class BasicEnemyManager(IEnemyManager):
    """기본 적 관리자 구현체 - 일반적인 적 관리 기능 제공"""
    
    def __init__(self, entity_manager: 'IEntityManager') -> None:
        """의존성 주입으로 EntityManager 받기"""
        # AI-NOTE : 2025-08-17 의존성 주입을 통한 테스트 용이성 확보
        # - 이유: Mock EntityManager 주입으로 단위 테스트 격리
        # - 요구사항: Manager는 EntityManager 인터페이스만 의존
        # - 비즈니스 가치: 안정적인 적 관리 로직 보장
        self._entity_manager = entity_manager
    
    def create_enemy(self, dto: 'EnemyCreateDTO') -> 'Entity':
        """기본 적 엔티티 생성"""
        # 1. 엔티티 생성
        entity = self._entity_manager.create_entity()
        
        # 2. 컴포넌트 추가 (DTO 기반)
        self._add_basic_components(entity, dto)
        self._add_ai_component(entity, dto)
        self._add_physics_components(entity, dto)
        
        return entity
    
    def update_enemy_stats(self, entity: 'Entity', dto: 'EnemyUpdateDTO') -> None:
        """적 상태 업데이트"""
        # DTO 기반 상태 업데이트 로직
        pass
    
    def get_enemy_count(self) -> int:
        """활성 적 수 조회"""
        # EntityManager를 통한 적 수 조회
        pass
    
    def cleanup_dead_enemies(self) -> list['Entity']:
        """죽은 적들 정리"""
        # 죽은 적 정리 로직
        pass
    
    def _add_basic_components(self, entity: 'Entity', dto: 'EnemyCreateDTO') -> None:
        """기본 컴포넌트 추가 (private 메서드)"""
        pass
```

#### **Strategy 구현체 패턴**
```python
# systems/strategies/attack/direct_attack_strategy.py
from typing import TYPE_CHECKING

from ..i_attack_strategy import IAttackStrategy

if TYPE_CHECKING:
    from ....dto.creation.projectile_create_dto import ProjectileCreateDTO
    from ....ecs.entity import Entity

class DirectAttackStrategy(IAttackStrategy):
    """직접 공격 전략 - 가장 가까운 적을 직선으로 공격"""
    
    def find_target(self, attacker: 'Entity', available_targets: list['Entity']) -> 'Entity | None':
        """가장 가까운 적 선택"""
        # AI-NOTE : 2025-08-17 거리 기반 타겟 선택 로직
        # - 이유: 직접 공격은 가장 가까운 적을 우선 타겟팅
        # - 요구사항: 유클리드 거리 계산으로 최근접 적 선택
        # - 최적화: 거리 제곱 비교로 제곱근 연산 생략
        if not available_targets:
            return None
        
        attacker_pos = self._get_position(attacker)
        if not attacker_pos:
            return None
        
        closest_target = None
        min_distance_sq = float('inf')
        
        for target in available_targets:
            target_pos = self._get_position(target)
            if not target_pos:
                continue
            
            # 거리 제곱 계산 (제곱근 연산 생략)
            distance_sq = (
                (target_pos.x - attacker_pos.x) ** 2 + 
                (target_pos.y - attacker_pos.y) ** 2
            )
            
            if distance_sq < min_distance_sq:
                min_distance_sq = distance_sq
                closest_target = target
        
        return closest_target
    
    def create_attack_dto(self, attacker: 'Entity', target: 'Entity') -> 'ProjectileCreateDTO':
        """직선 공격 DTO 생성"""
        # DTO 생성 로직
        pass
    
    def get_strategy_name(self) -> str:
        """전략 이름 반환"""
        return "DirectAttack"
    
    def _get_position(self, entity: 'Entity') -> 'Vector2 | None':
        """엔티티 위치 조회 (private 헬퍼 메서드)"""
        pass
```

### 3. System 작성 규칙

#### **System 구현 패턴**
```python
# systems/weapon_system.py
from typing import TYPE_CHECKING

from ..ecs.system import System

if TYPE_CHECKING:
    from ..managers.i_weapon_manager import IWeaponManager
    from ..systems.strategies.i_attack_strategy import IAttackStrategy
    from ..events.core.event_producer import EventProducer
    from ..events.types.projectile_created_event import ProjectileCreatedEvent

class WeaponSystem(System):
    """무기 시스템 - 전략 패턴으로 다양한 공격 방식 지원"""
    
    def __init__(
        self, 
        weapon_manager: 'IWeaponManager',
        event_producer: 'EventProducer[ProjectileCreatedEvent]'
    ) -> None:
        """의존성 주입으로 Manager와 EventProducer 받기"""
        super().__init__(priority=10)
        
        # AI-NOTE : 2025-08-17 System의 Manager 의존성과 전략 패턴 적용
        # - 이유: System은 EntityManager 직접 사용하지 않고 Manager 통해 추상화
        # - 요구사항: 런타임에 공격 전략 교체 가능한 유연성 제공
        # - 비즈니스 가치: 다양한 무기 타입과 공격 패턴 지원
        self._weapon_manager = weapon_manager
        self._event_producer = event_producer
        
        # 기본 전략 설정
        from ..systems.strategies.i_attack_strategy import IAttackStrategy
        self._attack_strategy: 'IAttackStrategy' = IAttackStrategy.create_direct()
    
    def update(self, delta_time: float) -> None:
        """무기 시스템 업데이트 (entity_manager 없이!)"""
        # 1. Manager를 통해 활성 무기 조회
        active_weapons = self._weapon_manager.get_active_weapons()
        
        # 2. 각 무기별 공격 처리
        for weapon_entity in active_weapons:
            if self._weapon_manager.can_attack(weapon_entity, delta_time):
                # 3. 전략 패턴으로 공격 실행
                self._execute_attack_with_strategy(weapon_entity)
    
    def set_attack_strategy(self, strategy: 'IAttackStrategy') -> None:
        """공격 전략 교체 (런타임 변경 가능)"""
        self._attack_strategy = strategy
    
    def _execute_attack_with_strategy(self, weapon_entity: 'Entity') -> None:
        """전략 패턴을 사용한 공격 실행"""
        # 1. 전략을 통해 타겟 선택
        available_targets = self._weapon_manager.get_targets_in_range(weapon_entity)
        target = self._attack_strategy.find_target(weapon_entity, available_targets)
        
        if target:
            # 2. 전략을 통해 공격 DTO 생성
            attack_dto = self._attack_strategy.create_attack_dto(weapon_entity, target)
            
            # 3. Manager를 통해 공격 실행
            projectile_entity = self._weapon_manager.execute_attack(attack_dto)
            
            # 4. 이벤트 발행
            if projectile_entity:
                from ..events.types.projectile_created_event import ProjectileCreatedEvent
                event = ProjectileCreatedEvent(
                    projectile_entity_id=projectile_entity.entity_id,
                    weapon_entity_id=weapon_entity.entity_id,
                    timestamp=time.time()
                )
                self._event_producer.produce(event)
    
    def initialize(self) -> None:
        """시스템 초기화"""
        super().initialize()
        # 초기화 로직
    
    def get_required_components(self) -> list[type]:
        """이 시스템이 필요로 하는 컴포넌트 타입들"""
        from ..components.gameplay.weapon_component import WeaponComponent
        from ..components.core.position_component import PositionComponent
        return [WeaponComponent, PositionComponent]
```

### 4. Event 시스템 상세 설명

#### **4.1. events/core/ 구조 상세**

**BaseEvent**: 모든 이벤트의 공통 인터페이스
```python
# events/core/base_event.py
from abc import ABC, abstractmethod
import time

class BaseEvent(ABC):
    """모든 이벤트의 기본 구조"""
    
    def __init__(self) -> None:
        self.timestamp: float = time.time()
    
    @abstractmethod
    def get_event_type(self) -> 'EventType':
        """이벤트 타입 반환 (Enum 사용)"""
        pass
    
    @abstractmethod
    def validate(self) -> bool:
        """이벤트 데이터 검증"""
        pass
```

**SharedEventQueue**: 공유 이벤트 큐 (Producer와 Consumer 연결고리)
```python
# events/core/shared_event_queue.py
from collections import deque
from typing import Generic, TypeVar

T = TypeVar('T', bound='BaseEvent')

class SharedEventQueue(Generic[T]):
    """Producer와 Consumer가 공유하는 이벤트 큐"""
    
    def __init__(self, event_type: type[T], max_queue_size: int = 1000) -> None:
        self._event_type = event_type
        self._queue: deque[T] = deque(maxlen=max_queue_size)
    
    def enqueue(self, event: T) -> bool:
        """이벤트 큐에 추가 (Producer 호출)"""
        if not isinstance(event, self._event_type):
            raise TypeError(f"Expected {self._event_type.__name__}, got {type(event).__name__}")
        
        if len(self._queue) >= self._queue.maxlen:
            return False  # 큐 가득 참
        
        self._queue.append(event)
        return True
    
    def dequeue(self) -> T | None:
        """이벤트 큐에서 제거 (Consumer 호출)"""
        try:
            return self._queue.popleft()
        except IndexError:
            return None
    
    def is_empty(self) -> bool:
        """큐가 비어있는지 확인"""
        return len(self._queue) == 0
    
    def size(self) -> int:
        """현재 큐 크기"""
        return len(self._queue)
```

**EventProducer**: 공유 큐를 참조하는 이벤트 생산자
```python
# events/core/event_producer.py  
from typing import Generic, TypeVar

T = TypeVar('T', bound='BaseEvent')

class EventProducer(Generic[T]):
    """타입 안전한 이벤트 생산자 - 공유 큐 참조"""
    
    def __init__(self, shared_queue: 'SharedEventQueue[T]') -> None:
        """공유 큐 의존성 주입"""
        # AI-NOTE : 2025-08-17 공유 큐 기반 Producer-Consumer 연결
        # - 이유: Producer와 Consumer가 동일한 큐를 공유하여 직접 연결
        # - 요구사항: 타입 안전성 유지하면서 메모리 효율적인 이벤트 전달
        # - 비즈니스 가치: 실시간 이벤트 처리로 게임 반응성 향상
        self._shared_queue = shared_queue
    
    def produce(self, event: T) -> bool:
        """이벤트 생산 (공유 큐에 추가)"""
        return self._shared_queue.enqueue(event)
    
    def get_queue_size(self) -> int:
        """현재 큐 크기 조회"""
        return self._shared_queue.size()
    
    def is_queue_full(self) -> bool:
        """큐가 가득 찼는지 확인"""
        return self._shared_queue.size() >= self._shared_queue._queue.maxlen
```

**EventConsumer**: 공유 큐를 참조하는 이벤트 소비자
```python
# events/core/event_consumer.py
from typing import Generic, TypeVar

T = TypeVar('T', bound='BaseEvent')

class EventConsumer(Generic[T]):
    """타입 안전한 이벤트 소비자 - 공유 큐 참조"""
    
    def __init__(self, shared_queue: 'SharedEventQueue[T]') -> None:
        """공유 큐 의존성 주입"""
        self._shared_queue = shared_queue
    
    def consume_next(self) -> T | None:
        """다음 이벤트 소비 (공유 큐에서 제거)"""
        return self._shared_queue.dequeue()
    
    def is_empty(self) -> bool:
        """큐가 비어있는지 확인"""
        return self._shared_queue.is_empty()
    
    def get_queue_size(self) -> int:
        """현재 큐 크기 조회"""
        return self._shared_queue.size()
```

**EventTunnelManager**: Producer/Consumer 쌍 관리 (SharedEventQueue 기반)
```python
# events/core/event_tunnel_manager.py
from typing import TypeVar, Generic

T = TypeVar('T', bound='BaseEvent')

class EventTunnelManager:
    """Producer와 Consumer 쌍을 관리하는 터널 매니저 - SharedEventQueue 기반"""
    PRODUCER = 0
    CONSUMER = 1
    
    def __init__(self) -> None:
        # AI-NOTE : 2025-08-17 SharedEventQueue 기반 Producer-Consumer 연결 해결
        # - 이유: Producer와 Consumer가 동일한 큐를 공유하여 실제 이벤트 전달 구현
        # - 요구사항: create_tunnel 시 공유 큐 생성하여 Producer/Consumer에 주입
        # - 비즈니스 가치: 타입 안전한 실시간 이벤트 처리로 시스템 반응성 향상
        self._tunnels: dict[type, tuple[EventProducer, EventConsumer]] = {}
        self._shared_queues: dict[type, SharedEventQueue] = {}
    
    def create_tunnel[T](self, event_type: type[T]) -> tuple[EventProducer[T], EventConsumer[T]]:
        """이벤트 타입별 Producer/Consumer 쌍 생성 - 공유 큐 기반"""
        # 1. 공유 큐 생성
        shared_queue = SharedEventQueue(event_type, max_queue_size=1000)
        self._shared_queues[event_type] = shared_queue
        
        # 2. Producer와 Consumer에 동일한 공유 큐 주입
        producer = EventProducer(shared_queue)
        consumer = EventConsumer(shared_queue)
        
        # 3. 터널 등록
        self._tunnels[event_type] = (producer, consumer)
        return producer, consumer
    
    def get_producer[T](self, event_type: type[T]) -> EventProducer[T]:
        """Producer 조회 (지연 생성)"""
        if event_type not in self._tunnels:
            self.create_tunnel(event_type)
        return self._tunnels[event_type][self.PRODUCER]
    
    def get_consumer[T](self, event_type: type[T]) -> EventConsumer[T]:
        """Consumer 조회 (지연 생성)"""
        if event_type not in self._tunnels:
            self.create_tunnel(event_type)
        return self._tunnels[event_type][self.CONSUMER]
    
    def get_shared_queue[T](self, event_type: type[T]) -> SharedEventQueue[T]:
        """공유 큐 직접 조회 (디버깅 및 모니터링용)"""
        if event_type not in self._shared_queues:
            self.create_tunnel(event_type)
        return self._shared_queues[event_type]
    
    def process_all_tunnels(self) -> dict[type, int]:
        """모든 터널의 큐 상태 조회 (실제 전송은 Producer/Consumer가 직접 처리)"""
        # AI-DEV : 공유 큐 기반에서는 Producer/Consumer가 직접 큐를 사용
        # - 변경사항: 기존의 수동 전송 대신 큐 상태만 모니터링
        # - 이유: SharedEventQueue를 통해 Producer→Consumer 전송이 자동으로 처리됨
        queue_states = {}
        
        for event_type, shared_queue in self._shared_queues.items():
            queue_states[event_type] = shared_queue.size()
        
        return queue_states
    
    def register_event_system(self, event_system: 'System', event_type: type[T]) -> None:
        """이벤트 처리 System에 EventConsumer 주입"""
        # AI-NOTE : 2025-08-17 System이 EventConsumer를 HAS-A로 주입받는 구조
        # - 이유: System은 비즈니스 로직, EventConsumer는 순수 큐 처리만 담당
        # - 요구사항: EventTunnelManager가 EventConsumer를 생성하여 System에 주입
        # - 구조: EventTunnelManager → EventConsumer → System (HAS-A)
        
        # 1. 터널에서 EventConsumer 가져오기 (Producer는 다른 System이 사용)
        event_consumer = self.get_consumer(event_type)
        
        # 2. Event System에 EventConsumer 주입
        if hasattr(event_system, '_event_consumer'):
            event_system._event_consumer = event_consumer
        
        # 3. 등록 로깅
        print(f"Registered {event_system.__class__.__name__} for {event_type.__name__}")
    
    def get_tunnel_stats(self) -> dict[str, any]:
        """터널 통계 정보 조회"""
        total_events = sum(queue.size() for queue in self._shared_queues.values())
        tunnel_count = len(self._tunnels)
        
        return {
            'tunnel_count': tunnel_count,
            'total_queued_events': total_events,
            'event_types': list(self._shared_queues.keys()),
            'queue_states': self.process_all_tunnels()
        }
```

**올바른 System HAS-A Consumer 구조 사용 예시**:
```python
# EventTunnelManager 사용 예시 - System이 Consumer를 HAS-A로 포함
tunnel_manager = EventTunnelManager()
experience_manager = ExperienceManager()

# 1. Event 처리 System 생성 (비즈니스 로직)
experience_system = ExperienceSystem(experience_manager)

# 2. EventTunnelManager에 Event System 등록
# - EventConsumer가 System에 주입됨 (HAS-A)
tunnel_manager.register_event_system(experience_system, EnemyDeathEvent)

# 3. Producer 가져오기 (다른 시스템에서 이벤트 발행용)
producer = tunnel_manager.get_producer(EnemyDeathEvent)

# 4. 다른 System에서 이벤트 생산 (예: ProjectileSystem)
death_event = EnemyDeathEvent(
    enemy_entity_id="enemy_123", 
    death_position=Vector2(100, 200),
    experience_value=50
)
success = producer.produce(death_event)  # SharedEventQueue에 추가

# 5. ExperienceSystem이 자동으로 처리 (System.update() 호출 시)
experience_system.update(delta_time=0.016)
# → 내부 EventConsumer가 SharedEventQueue에서 이벤트 소비
# → ExperienceManager.grant_experience() 호출

# 6. 구조 확인
print("=== System HAS-A Consumer 구조 ===")
print(f"System: {type(experience_system).__name__}")
print(f"Consumer (HAS-A): {type(experience_system._event_consumer).__name__}")
print(f"공유 큐 크기: {tunnel_manager.get_shared_queue(EnemyDeathEvent).size()}")
```

**올바른 구조 정리**:
```
EventTunnelManager
├── SharedEventQueue[EnemyDeathEvent]  ← 실제 이벤트 저장소
│   ├── Producer.produce() → enqueue()
│   └── Consumer.consume_next() → dequeue()
│
├── EventConsumer (순수 큐 처리)       ← events/core/event_consumer.py
└── ExperienceSystem (비즈니스 로직)   ← systems/events/experience_system.py
    └── HAS-A: EventConsumer           ← 의존성 주입으로 Consumer 포함
```

**EventType Enum**: 이벤트 타입 정의
```python
# events/core/event_types.py
from enum import IntEnum

class EventType(IntEnum):
    """이벤트 타입 열거형"""
    ENEMY_DEATH = 0
    LEVEL_UP = 1
    EXPERIENCE_GAIN = 2
    PROJECTILE_HIT = 3
    CAMERA_OFFSET_CHANGED = 4
    WEAPON_UPGRADE = 5
    
    @property
    def display_name(self) -> str:
        """이벤트 타입 표시명"""
        names = {
            self.ENEMY_DEATH: "적 사망",
            self.LEVEL_UP: "레벨업",
            self.EXPERIENCE_GAIN: "경험치 획득",
            self.PROJECTILE_HIT: "투사체 명중",
            self.CAMERA_OFFSET_CHANGED: "카메라 오프셋 변경",
            self.WEAPON_UPGRADE: "무기 업그레이드"
        }
        return names.get(self, "알 수 없는 이벤트")
```

### 5. Event 시스템 작성 규칙

#### **Event 타입 정의**
```python
# events/types/enemy_death_event.py
import time
from dataclasses import dataclass
from typing import TYPE_CHECKING

from ..core.base_event import BaseEvent

if TYPE_CHECKING:
    from ...utils.vector2 import Vector2

@dataclass
class EnemyDeathEvent(BaseEvent):
    """적 사망 이벤트"""
    
    enemy_entity_id: str
    death_position: 'Vector2'
    experience_reward: int
    killer_entity_id: str | None = None
    
    def __post_init__(self) -> None:
        """이벤트 초기화 후 타임스탬프 설정"""
        if not hasattr(self, 'timestamp'):
            self.timestamp = time.time()
    
    def validate(self) -> bool:
        """이벤트 데이터 검증"""
        return (
            bool(self.enemy_entity_id) and
            self.death_position is not None and
            self.experience_reward >= 0
        )
    
    def get_event_type(self) -> 'EventType':
        """이벤트 타입 반환"""
        from ...config.enums import EventType
        return EventType.ENEMY_DEATH
```

#### **Event 처리 System 정의 (Consumer HAS-A 구조)**

**올바른 구조: System이 EventConsumer를 HAS-A로 주입받음**
```python
# systems/events/experience_system.py
from typing import TYPE_CHECKING

from ...ecs.system import System
from ...events.core.event_consumer import EventConsumer
from ...events.types.enemy_death_event import EnemyDeathEvent

if TYPE_CHECKING:
    from ...managers.i_experience_manager import IExperienceManager

class ExperienceSystem(System):
    """경험치 처리 시스템 - EventConsumer를 HAS-A로 포함"""
    
    def __init__(self, experience_manager: 'IExperienceManager') -> None:
        """경험치 관리자 의존성 주입"""
        super().__init__(priority=20)  # Experience 처리는 후순위
        self._experience_manager = experience_manager
        
        # AI-NOTE : 2025-08-17 System이 EventConsumer를 HAS-A로 주입받는 구조
        # - 이유: Consumer는 순수 이벤트 큐 처리만, System이 비즈니스 로직 담당
        # - 요구사항: EventTunnelManager가 Consumer를 생성하여 System에 주입
        # - 구조: ExperienceSystem HAS-A EventConsumer (의존성 주입)
        self._event_consumer: EventConsumer[EnemyDeathEvent] = None  # EventTunnelManager가 주입
    
    def update(self, delta_time: float) -> None:
        """System 업데이트 - 이벤트 컨슈머로 동작"""
        # EventConsumer를 통해 이벤트 처리
        while not self._event_consumer.is_empty():
            event = self._event_consumer.consume_next()
            if event:
                self._process_enemy_death_event(event)
    
    def _process_enemy_death_event(self, event: EnemyDeathEvent) -> None:
        """적 사망 이벤트 처리 - 경험치 지급"""
        # AI-NOTE : 2025-08-17 경험치 지급 로직
        # - 이유: 적 사망 시 플레이어에게 경험치 지급하여 성장 요소 제공
        # - 요구사항: 이벤트 기반 느슨한 결합으로 시스템 독립성 확보
        # - 비즈니스 가치: 플레이어 진행도와 성취감 향상
        try:
            self._experience_manager.grant_experience(
                amount=event.experience_reward,
                position=event.death_position,
                killer_entity_id=event.killer_entity_id
            )
        except Exception as e:
            # 로깅하되 다른 컨슈머에 영향 주지 않음
            import logging
            logging.error(f"Failed to grant experience: {e}")
    
    def initialize(self) -> None:
        """시스템 초기화"""
        super().initialize()
        # EventTunnelManager에 Consumer 등록
        # (실제 구현에서는 EventTunnelManager.register_consumer() 호출)
    
    def get_required_components(self) -> list[type]:
        """이 시스템이 필요로 하는 컴포넌트 (없음 - 이벤트만 처리)"""
        return []
```

### 5. DTO 작성 규칙

#### **Creation DTO 패턴**
```python
# dto/creation/enemy_create_dto.py
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ...utils.vector2 import Vector2
    from ...config.enums import EnemyType, AIType

@dataclass
class EnemyCreateDTO:
    """적 생성 데이터 전송 객체"""
    
    spawn_position: 'Vector2'
    enemy_type: 'EnemyType'
    difficulty_scale: float = 1.0
    ai_type: 'AIType | None' = None
    base_health: int = 100
    base_speed: float = 80.0
    experience_reward: int = 10
    
    def validate(self) -> bool:
        """DTO 데이터 검증"""
        return (
            self.spawn_position is not None and
            self.difficulty_scale > 0 and
            self.base_health > 0 and
            self.base_speed > 0 and
            self.experience_reward >= 0
        )
    
    def get_scaled_health(self) -> int:
        """난이도 스케일 적용된 체력 반환"""
        return int(self.base_health * self.difficulty_scale)
    
    def get_scaled_speed(self) -> float:
        """난이도 스케일 적용된 속도 반환"""
        return self.base_speed * self.difficulty_scale
    
    def get_additional_data(self, key: str, default_value=None):
        """추가 데이터 조회 (확장성을 위한 메서드)"""
        # 필요시 추가 속성들을 위한 확장 포인트
        return default_value
```

## 🔄 마이그레이션 단계별 작업 계획

### Phase 1: 기반 구조 구축 (1-2일)
1. **ECS Framework 순수화**
   - `src/ecs/` 폴더 생성
   - 기존 `src/core/entity.py`, `component.py`, `system.py` 이동
   - `System.update()` 인터페이스 변경 (entity_manager 제거)

2. **Manager 인터페이스 추출**
   - `src/managers/` 폴더 구조 생성
   - 각 Manager의 인터페이스 파일 생성
   - 정적 팩토리 메서드 패턴 적용

3. **DTO 계층 구축**
   - `src/dto/` 폴더 구조 생성
   - Creation, Update, Query DTO 정의

### Phase 2: Event 시스템 교체 (2-3일)
1. **Producer-Consumer 구현**
   - `src/events/core/` EventProducer, EventConsumer, EventTunnelManager 구현
   - 타입 안전성 보장을 위한 Generic 클래스 설계

2. **Event 타입 마이그레이션**
   - 기존 `src/core/events/` → `src/events/types/` 이동
   - BaseEvent 인터페이스 표준화

3. **Consumer 구현**
   - `src/events/consumers/` 생성
   - ExperienceConsumer, WeaponUpgradeConsumer 등 구현

### Phase 3: Strategy 패턴 적용 (2-3일)
1. **Strategy 인터페이스 정의**
   - `src/systems/strategies/` 구조 생성
   - Attack, Spawn, Movement, CoordinateTransform 전략 인터페이스

2. **System 리팩토링**
   - 기존 System들을 Strategy 패턴으로 변경
   - Manager 의존성 주입으로 EntityManager 직접 접근 제거

3. **Coordinate 시스템 통합**
   - 기존 `coordination/` 폴더 해체
   - Manager와 Strategy 계층으로 재배치

### Phase 4: Manager 구현체 분리 (1-2일)
1. **기능별 Manager 구현체 생성**
   - Basic, Boss, Synergy 등 특화된 구현체 생성
   - 각 구현체의 단일 책임 원칙 적용

2. **Factory 패턴 구현**
   - `src/factories/` 복잡한 객체 생성 로직 분리
   - System, Manager 팩토리 구현

### Phase 5: 통합 및 테스트 (1-2일)
1. **Orchestration 계층 구성**
   - `src/orchestration/` 최상위 조율 계층
   - SystemOrchestrator, GameLoop, Application 구현

2. **종합 테스트 및 최적화**
   - 전체 시스템 통합 테스트
   - 성능 측정 및 최적화

## 📋 코딩 표준 및 주의사항

### 1. 명명 규칙
- **인터페이스**: `I` 접두사 (`IEnemyManager`, `IAttackStrategy`)
- **구현체**: 기능 명시 (`BasicEnemyManager`, `DirectAttackStrategy`)
- **DTO**: 용도 명시 (`EnemyCreateDTO`, `WeaponUpdateDTO`)
- **Event**: 동작 명시 (`EnemyDeathEvent`, `LevelUpEvent`)

### 2. 의존성 규칙
- **상위 계층 → 하위 계층**: 허용
- **하위 계층 → 상위 계층**: 금지
- **인터페이스 의존**: 권장
- **구체 클래스 의존**: 최소화

### 3. AI 주석 규칙
```python
# AI-NOTE : 날짜 비즈니스 로직 설명
# - 이유: 왜 이렇게 구현했는지
# - 요구사항: 어떤 요구사항을 반영했는지
# - 비즈니스 가치: 게임에서의 의미와 효과

# AI-DEV : 기술적 해결책 설명  
# - 문제: 어떤 기술적 문제가 있었는지
# - 해결책: 어떻게 해결했는지
# - 주의사항: 유지보수 시 주의할 점
```

### 4. 타입 힌트 규칙
- **Python 3.13+ 네이티브 문법** 사용
- **TYPE_CHECKING** 가드로 순환 의존성 방지
- **제네릭** 타입 적극 활용 (`EventProducer[T]`, `EventConsumer[T]`)

### 5. 테스트 전략
- **인터페이스 기반 Mock** 객체 활용
- **DTO 기반 테스트 데이터** 관리
- **Strategy 패턴별 독립 테스트**
- **Event 시스템 격리 테스트**

## 🎯 성공 지표

### 1. 아키텍처 품질
- [ ] 모든 System이 EntityManager 직접 접근 제거
- [ ] Manager 인터페이스 기반 다형성 구현
- [ ] Producer-Consumer 이벤트 시스템 완전 전환
- [ ] Strategy 패턴으로 런타임 행동 변경 가능

### 2. 코드 품질
- [ ] 타입 힌트 100% 적용
- [ ] 순환 의존성 0개
- [ ] AI 주석으로 비즈니스 로직 문서화
- [ ] 단위 테스트 80% 이상 커버리지

### 3. 성능 목표
- [ ] 게임 실행 시 40+ FPS 유지
- [ ] Event 처리 지연시간 1ms 이하
- [ ] Manager 교체 시 성능 영향 5% 이하

---

**작성자**: Claude Code Assistant  
**승인자**: 개발팀  
**검토 주기**: 매일 진행상황 체크  
**완료 예정일**: 2025-08-24