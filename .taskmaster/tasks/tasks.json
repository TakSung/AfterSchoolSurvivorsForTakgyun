{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "ECS 프레임워크 기반 구조 설정",
        "description": "Entity-Component-System 아키텍처 기반의 핵심 프레임워크를 구축하고 프로젝트 구조를 설정합니다.",
        "details": "src/core/ 디렉토리에 Entity, Component, System 추상 클래스들을 정의합니다. EntityManager 클래스로 엔티티 생명주기를 관리하고, ComponentRegistry로 컴포넌트 타입별 저장소를 구현합니다. SystemOrchestrator 클래스로 시스템 실행 순서를 제어하는 구조를 만듭니다. Python 3.13+ 환경에서 pygame 2.6.0+, numpy 2.2.4+, pytest 8.0.0+, ruff 0.6.0+ 의존성을 설정합니다.",
        "testStrategy": "각 ECS 컴포넌트의 기본 인터페이스가 정상 동작하는지 단위 테스트를 작성합니다. EntityManager의 엔티티 생성/삭제, ComponentRegistry의 컴포넌트 추가/제거, SystemOrchestrator의 시스템 등록/실행 순서를 검증합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "프로젝트 구조 및 기본 디렉토리 설정",
            "description": "src/core/, src/systems/, tests/ 등 ECS 아키텍처에 맞는 프로젝트 디렉토리 구조를 생성하고 초기 설정 파일들을 구성합니다.",
            "dependencies": [],
            "details": "src/core/, src/systems/, src/components/, src/entities/, tests/ 디렉토리를 생성하고, __init__.py 파일들을 추가합니다. pyproject.toml에 프로젝트 메타데이터와 의존성을 정의하고, .gitignore와 기본 설정 파일들을 생성합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "전체 시스템 구조 docs/design.md 문서를 작성",
            "description": "",
            "details": "<info added on 2025-08-07T19:17:29.270Z>\nECS 프레임워크의 전체 시스템 구조를 설계하고 docs/design.md에 문서화합니다. Entity-Component-System 아키텍처의 핵심 개념과 클래스 관계를 정의하며, 각 시스템 간의 상호작용을 머메이드 다이어그램으로 시각화합니다. 구현 전 모든 개발자가 참조할 수 있는 설계 청사진을 제공하여 일관된 아키텍처 구현을 보장합니다.\n</info added on 2025-08-07T19:17:29.270Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Entity, Component, System 추상 클래스 정의",
            "description": "ECS 아키텍처의 핵심인 Entity, Component, System의 기본 인터페이스와 추상 클래스를 정의합니다.",
            "dependencies": [
              "1.1"
            ],
            "details": "src/core/entity.py에 Entity 클래스, src/core/component.py에 Component 추상 클래스, src/core/system.py에 System 추상 클래스를 정의합니다. 각 클래스는 고유 ID, 생명주기 관리, 상속 가능한 인터페이스를 포함해야 합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EntityManager 클래스 구현",
            "description": "엔티티의 생성, 삭제, 관리를 담당하는 EntityManager 클래스를 구현합니다.",
            "dependencies": [
              "1.2"
            ],
            "details": "src/core/entity_manager.py에 EntityManager 클래스를 구현합니다. create_entity(), destroy_entity(), get_entity(), get_entities_with_component() 등의 메서드를 포함하며, 엔티티 ID 할당과 생명주기를 관리합니다. 약한 참조를 사용한 메모리 관리를 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ComponentRegistry 클래스 구현",
            "description": "컴포넌트 타입별 저장소와 관리 기능을 제공하는 ComponentRegistry를 구현합니다.",
            "dependencies": [
              "1.2"
            ],
            "details": "src/core/component_registry.py에 ComponentRegistry 클래스를 구현합니다. add_component(), remove_component(), get_component(), has_component() 메서드를 구현하고, 컴포넌트 타입별로 효율적인 저장 구조를 만듭니다. 타입 안전성과 빠른 조회를 위한 딕셔너리 기반 저장소를 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "SystemOrchestrator 클래스 구현",
            "description": "시스템들의 실행 순서를 제어하고 관리하는 SystemOrchestrator를 구현합니다.",
            "dependencies": [
              "1.2",
              "1.3",
              "1.4"
            ],
            "details": "src/core/system_orchestrator.py에 SystemOrchestrator 클래스를 구현합니다. register_system(), unregister_system(), update_systems() 메서드를 포함하며, 시스템 우선순위와 실행 순서를 관리합니다. 시스템 간 의존성과 실행 그룹을 고려한 스케줄링을 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "의존성 설정 및 환경 구성",
            "description": "Python 3.13+, pygame 2.6.0+, numpy 2.2.4+ 등 필요한 의존성을 설정하고 개발 환경을 구성합니다.",
            "dependencies": [
              "1.1"
            ],
            "details": "pyproject.toml에 pygame>=2.6.0, numpy>=2.2.4, pytest>=8.0.0, ruff>=0.6.0 의존성을 설정합니다. requirements.txt와 dev-requirements.txt를 생성하고, ruff와 pytest 설정 파일을 추가합니다. Python 가상환경 생성 스크립트와 설치 가이드를 작성합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "게임 루프 및 기본 렌더링 시스템 구현",
        "description": "60fps/40fps 게임 루프와 pygame 기반 기본 렌더링 시스템을 구현합니다.",
        "details": "src/core/game_loop.py에서 pygame.time.Clock을 사용한 고정 시간 간격 게임 루프를 구현합니다. RenderSystem 클래스에서 pygame.sprite.Group을 활용한 기본 스프라이트 렌더링을 구현합니다. 화면 해상도와 FPS 설정을 외부에서 조정 가능하도록 설정 파일을 만듭니다. 게임 상태 관리(RUNNING, PAUSED, STOPPED)를 포함합니다.",
        "testStrategy": "빈 게임 월드에서 40+ FPS가 안정적으로 유지되는지 성능 테스트를 실행합니다. 게임 루프의 시간 정확성과 렌더링 시스템의 기본 동작을 검증하는 통합 테스트를 작성합니다. 유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "pygame 기반 게임 루프 구현",
            "description": "pygame.time.Clock을 사용한 고정 시간 간격 게임 루프를 구현하고 FPS 제어 기능을 추가합니다.",
            "dependencies": [],
            "details": "src/core/game_loop.py에서 GameLoop 클래스를 구현합니다. pygame.time.Clock()을 사용하여 60fps/40fps 고정 시간 간격을 관리하고, delta time 계산을 통해 프레임률 독립적인 게임 로직을 지원합니다. 게임 루프의 초기화, 업데이트, 종료 메서드를 구현하며, FPS 모니터링 기능을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "고정 시간 간격 처리 시스템",
            "description": "프레임률 독립적인 시간 기반 게임 로직을 처리하는 시스템을 구현합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "delta time을 활용한 시간 기반 계산 유틸리티를 구현합니다. 고정 시간 간격(fixed timestep)과 가변 시간 간격(variable timestep) 처리 옵션을 제공하며, 시간 스케일링 기능(일시정지, 슬로우모션 등)을 지원합니다. TimeManager 클래스로 게임 내 시간 흐름을 중앙 관리합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "RenderSystem과 스프라이트 렌더링 구현",
            "description": "pygame.sprite.Group을 활용한 기본 렌더링 시스템과 스프라이트 관리 기능을 구현합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "src/systems/render_system.py에서 RenderSystem 클래스를 구현합니다. pygame.sprite.Group을 사용한 스프라이트 그룹 관리, 렌더링 레이어 시스템, 화면 클리어 및 더블 버퍼링 처리를 포함합니다. 스프라이트 정렬(z-order), 카메라 변환, 기본적인 렌더링 최적화 기능을 구현합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "게임 상태 관리 및 설정 파일 처리",
            "description": "게임 상태(RUNNING, PAUSED, STOPPED) 관리 시스템과 외부 설정 파일 처리를 구현합니다.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "GameStateManager 클래스로 게임 상태 전환을 관리하고, JSON 기반 설정 파일(config.json)에서 화면 해상도, FPS, 키 바인딩 등을 로드합니다. 런타임 중 설정 변경 기능과 설정 저장 기능을 구현하며, 상태별 렌더링 및 입력 처리 분기를 지원합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 5,
            "title": "고정 시간 간격 처리 시스템이 테스트",
            "description": "고정 시간 간격 처리 시스템이 60fps/40fps 모두 동일한 스팩으로 동작하는지 유닛 테스트를 진행합니다.",
            "details": "delta time 계산이 정확한지 테스트 케이스를 작성합니다. 테스트 케이스는 60fps, 40fps 모두 동일한 스팩으로 동작하는지 테스트합니다.",
            "status": "done",
            "dependencies": [
              "2.2"
            ],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "충돌감지 및 물리 시스템 구현",
        "description": "브루트포스 방식의 충돌감지 시스템과 기본 물리 계산 시스템을 구현합니다.",
        "details": "src/systems/collision_system.py에서 AABB(Axis-Aligned Bounding Box) 기반 충돌감지를 구현합니다. CollisionComponent에 hitbox 크기와 collision mask를 정의합니다. PhysicsSystem에서 기본 벡터 연산을 통한 이동과 속도 계산을 구현합니다. 초기에는 O(n²) 브루트포스 방식으로 구현하되, 추후 Spatial Partitioning으로 교체 가능하도록 인터페이스를 추상화합니다.",
        "testStrategy": "다양한 충돌 시나리오(정면 충돌, 모서리 충돌, 겹침)에 대한 단위 테스트를 작성합니다. 물리 계산의 정확성과 성능을 검증하는 테스트를 포함합니다.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "AABB 충돌감지 알고리즘 구현",
            "description": "Axis-Aligned Bounding Box 기반의 기본 충돌감지 로직을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/collision_system.py에서 CollisionSystem 클래스를 생성하고 AABB 충돌감지 함수를 구현합니다. 두 객체의 좌표와 크기를 비교하여 겹침을 판단하는 check_aabb_collision() 메서드를 작성합니다. x축과 y축 각각에서 겹침 여부를 확인하는 로직을 포함합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "CollisionComponent 설계 및 구현",
            "description": "충돌감지에 필요한 CollisionComponent를 설계하고 구현합니다.",
            "dependencies": [],
            "details": "src/components/collision_component.py에서 CollisionComponent 클래스를 정의합니다. hitbox 크기(width, height), collision mask(적 타입별 충돌 여부), collision layer(충돌 계층) 속성을 포함합니다. 컴포넌트 초기화 시 기본값 설정과 유효성 검증 로직을 추가합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "PhysicsSystem 벡터 연산 구현",
            "description": "기본 물리 계산을 위한 PhysicsSystem의 벡터 연산을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/physics_system.py에서 PhysicsSystem 클래스를 생성합니다. 속도 벡터 계산, 위치 업데이트, 기본 중력 적용 등의 메서드를 구현합니다. numpy를 활용한 2D 벡터 연산 함수들(덧셈, 곱셈, 정규화)을 포함하며, 프레임 독립적인 시간 기반 계산을 적용합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "브루트포스 충돌 처리 시스템 구현",
            "description": "O(n²) 브루트포스 방식의 충돌 처리 메인 로직을 구현합니다.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "CollisionSystem에서 모든 엔티티 쌍에 대해 충돌을 검사하는 process_collisions() 메서드를 구현합니다. 충돌 발생 시 적절한 반응(피해 적용, 아이템 획득 등)을 처리하는 로직을 포함합니다. 성능 모니터링을 위한 충돌 검사 횟수 카운터를 추가합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 5,
            "title": "확장성을 위한 인터페이스 추상화",
            "description": "추후 Spatial Partitioning 등으로 교체 가능한 추상 인터페이스를 구현합니다.",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "src/systems/collision_system.py에서 ICollisionDetector 추상 클래스를 정의하고, BruteForceCollisionDetector를 구체 구현체로 만듭니다. 충돌감지 알고리즘을 쉽게 교체할 수 있도록 Strategy 패턴을 적용합니다. 향후 QuadTree, SpatialHash 등의 최적화된 알고리즘 교체를 위한 인터페이스를 설계합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          }
        ]
      },
      {
        "id": 4,
        "title": "JSON 데이터 로딩 및 관리 시스템",
        "description": "게임 데이터(아이템, 적, 보스, 밸런스)를 JSON 파일로 관리하는 시스템을 구현합니다.",
        "details": "src/data/ 디렉토리에 DataLoader 클래스를 구현하여 items.json, enemies.json, bosses.json, game_balance.json을 로딩합니다. 각 데이터 타입별로 Pydantic 모델을 정의하여 타입 안전성을 보장합니다. 데이터 유효성 검증과 기본값 설정 로직을 포함합니다. 런타임 중 데이터 리로딩 기능을 지원하여 밸런싱 조정을 용이하게 만듭니다.",
        "testStrategy": "JSON 스키마 유효성 검증 테스트와 데이터 로딩 실패 시 적절한 에러 처리가 되는지 테스트합니다. 잘못된 JSON 형식이나 누락된 필드에 대한 예외 처리를 검증합니다.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "DataLoader 클래스 구현",
            "description": "JSON 파일을 로딩하고 관리하는 핵심 DataLoader 클래스를 구현합니다.",
            "dependencies": [],
            "details": "src/data/loader.py에 DataLoader 클래스를 구현하여 items.json, enemies.json, bosses.json, game_balance.json 파일을 비동기적으로 로딩하는 기능을 만듭니다. 파일 경로 관리, 캐싱 메커니즘, 에러 처리 로직을 포함하며, 싱글톤 패턴을 적용하여 데이터 로더의 유일성을 보장합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "Pydantic 모델 정의",
            "description": "각 데이터 타입별 Pydantic 모델을 정의하여 타입 안전성을 보장합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "src/data/models.py에 Item, Enemy, Boss, GameBalance 등의 Pydantic 모델을 정의합니다. 각 모델에는 필수 필드 검증, 기본값 설정, 타입 변환 로직을 포함하며, Field validator를 사용하여 데이터 범위와 형식을 검증하는 기능을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "JSON 스키마 검증 시스템",
            "description": "로딩된 JSON 데이터의 유효성을 검증하는 스키마 검증 시스템을 구현합니다.",
            "dependencies": [
              "4.2"
            ],
            "details": "src/data/validator.py에서 JSON 스키마 검증 시스템을 구현합니다. 잘못된 JSON 형식, 누락된 필드, 잘못된 데이터 타입에 대한 명확한 에러 메시지를 제공하며, 검증 실패 시 기본값으로 대체하거나 안전하게 종료하는 복구 전략을 포함합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "런타임 데이터 리로딩 기능 구현",
            "description": "게임 실행 중 데이터 파일을 다시 로딩할 수 있는 런타임 리로딩 기능을 구현합니다.",
            "dependencies": [
              "4.3"
            ],
            "details": "src/data/reload_manager.py에서 파일 변경 감지와 런타임 리로딩 기능을 구현합니다. watchdog 라이브러리를 사용한 파일 시스템 모니터링, 리로딩 시 게임 상태 보존, 리로딩 실패 시 이전 데이터 복구 메커니즘을 포함하며, 개발 모드에서만 활성화되는 안전 장치를 구현합니다.",
            "status": "deferred",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "플레이어 마우스 이동 시스템",
        "description": "마우스 커서를 향해 플레이어가 바라보지만 플레이어는 중앙에 고정되고 맵이 플레이어 반대 방향으로 움직이는 카메라 시스템을 구현합니다.",
        "status": "done",
        "dependencies": [
          2,
          3
        ],
        "priority": "high",
        "details": "src/systems/movement_system.py에서 pygame.mouse.get_pos()를 사용해 마우스 위치를 추적하고 플레이어가 마우스 방향을 바라보도록 합니다. 플레이어는 화면 중앙에 고정되고, CameraSystem을 통해 맵이 플레이어 이동의 역방향으로 움직입니다. PlayerMovementComponent에 이동 방향과 속도를 저장하고, MapSystem에서 배경과 오브젝트들을 카메라 오프셋에 따라 렌더링합니다. 맵 움직임을 시각적으로 확인할 수 있는 타일 패턴이나 그리드 배경을 구현합니다.",
        "testStrategy": "마우스 위치 변화에 따른 플레이어 회전 방향이 정확한지 테스트합니다. 카메라 이동에 따른 맵 오브젝트 위치 변화와 시각적 피드백이 올바르게 작동하는지 검증합니다. 맵 경계 처리와 카메라 제한 범위에 대한 테스트를 포함합니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "마우스 위치 추적 및 플레이어 회전 구현",
            "description": "pygame을 사용해 마우스 위치를 실시간으로 추적하고, 플레이어가 마우스 방향을 바라보도록 회전시키는 시스템을 구현합니다.",
            "status": "done",
            "dependencies": [],
            "details": "pygame.mouse.get_pos()를 사용하여 마우스 좌표를 획득하고, 플레이어 위치(화면 중앙)와의 방향각을 계산합니다. math.atan2를 활용한 각도 계산과 플레이어 스프라이트 회전 로직을 src/systems/movement_system.py에 구현합니다. 플레이어 회전 시 부드러운 회전 전환을 위한 각속도 제한을 적용합니다. 추가적으로 플레이어 위치를 획득하는 부분과 계산하는 부분을 분리하여 유닛테스트를 만들기 유용하게 작성합니다.",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "카메라 시스템과 맵 역방향 이동 구현",
            "description": "플레이어를 화면 중앙에 고정하고 맵이 플레이어 이동의 역방향으로 움직이는 카메라 시스템을 구현합니다.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "CameraSystem 클래스를 생성하여 카메라 오프셋을 관리합니다. 플레이어는 화면 중앙 고정 위치에 렌더링하고, 플레이어의 이동 입력에 따라 월드 좌표계를 역방향으로 이동시킵니다. PlayerMovementComponent에 이동 속도와 방향을 저장하여 카메라 오프셋 계산에 활용합니다. 모든 게임 오브젝트의 렌더링 시 카메라 오프셋을 적용하는 시스템을 구현합니다. UI부분과 객체 부분이 분리되어 유닛테스트가 쉽도록 작성합니다.",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "시각적 맵 시스템 및 경계 처리",
            "description": "맵 움직임을 확인할 수 있는 시각적 배경과 카메라 경계 처리 시스템을 구현합니다.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "타일 기반 배경 시스템이나 그리드 패턴을 구현하여 카메라 이동을 시각적으로 확인할 수 있게 합니다. 맵 경계를 설정하고 카메라가 맵 밖으로 나가지 않도록 제한하는 boundary checking을 구현합니다. 배경 타일의 무한 스크롤링 또는 맵 크기 제한 시스템을 추가하여 자연스러운 맵 탐색 경험을 제공합니다. 코드 디자인이 유닛테스트 하기 쉽도록, 위치가 주어질 때 어떤 타일을 제공해야하는 지에 대한 정보를 계산하는 함수(혹은 객체)를 분리해서 작성하여 타일 로드와 어떤 타일을 로드해야하는지 계산하는 로직을 분리합니다.",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          }
        ]
      },
      {
        "id": 6,
        "title": "자동 공격 및 투사체 시스템",
        "description": "시간 기반으로 가장 가까운 적을 자동 공격하는 시스템과 투사체를 구현합니다.",
        "details": "src/systems/weapon_system.py에서 WeaponComponent를 정의하여 공격 속도, 사거리, 데미지를 관리합니다. 가장 가까운 적을 찾기 위한 거리 계산 함수를 구현하고, ProjectileComponent로 투사체의 방향, 속도, 수명을 관리합니다. ProjectileSystem에서 투사체 이동과 충돌 처리를 담당하며, 화면 밖으로 나간 투사체는 자동으로 제거합니다.",
        "testStrategy": "자동 타겟팅이 정확히 가장 가까운 적을 선택하는지 테스트합니다. 투사체의 궤적과 충돌 감지, 수명 관리가 정상 동작하는지 검증합니다.",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "WeaponComponent와 자동 타겟팅 시스템 구현",
            "description": "WeaponComponent 클래스를 정의하고 가장 가까운 적을 찾는 자동 타겟팅 로직을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/weapon_system.py에서 WeaponComponent 클래스를 만들어 공격 속도(attack_speed), 사거리(range), 데미지(damage) 속성을 관리합니다. WeaponSystem 클래스에서 거리 계산 함수를 구현하여 지정된 사거리 내의 적 엔티티 중 가장 가까운 대상을 선택하는 자동 타겟팅 로직을 만듭니다. 시간 기반 쿨다운 시스템을 구현하여 attack_speed에 따라 공격 주기를 제어합니다. WeaponComponent.projectile_type 에 따라 각자 다른 방식으로 동작을 하도록 하며, State 패턴을 사용해서 WeaponComponent 가 projectile_type의 타입과 구현 내용을 몰라도 동작할 수 있도록 합니다. 처음 구현은 basic 만하여 동작하는지 확인합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "ProjectileComponent와 투사체 물리 처리",
            "description": "투사체의 이동과 물리적 특성을 관리하는 ProjectileComponent와 물리 시스템을 구현합니다.",
            "dependencies": [
              "6.1"
            ],
            "details": "src/components/projectile_component.py에서 ProjectileComponent 클래스를 정의하여 투사체의 방향(direction), 속도(velocity), 수명(lifetime), 데미지(damage) 등을 관리합니다. ProjectileSystem에서 매 프레임마다 투사체의 위치를 업데이트하는 물리 처리 로직을 구현합니다. 투사체 생성 시 타겟 방향으로의 벡터 계산과 정규화를 통해 일정한 속도로 이동하도록 설정합니다. ProjectileSystem에서 개별 투사체의 구현을 알지 않아도 되도록, 코드 구조를 설계하여 작성 합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "투사체 충돌 및 수명 관리",
            "description": "투사체와 적의 충돌 감지, 수명 관리, 그리고 충돌 시 효과 처리를 구현합니다.",
            "dependencies": [
              "6.2"
            ],
            "details": "ProjectileSystem에서 pygame.sprite.spritecollide를 활용한 투사체-적 충돌 감지를 구현합니다. 충돌 발생 시 적에게 데미지를 적용하고 투사체를 제거하는 로직을 만듭니다. 투사체 수명(lifetime)을 매 프레임마다 감소시켜 시간이 지나면 자동으로 제거되도록 구현합니다. 화면 경계를 벗어난 투사체도 자동 제거하여 메모리 누수를 방지합니다. 또한 해당 부분을 객체화 하여 효과적으로 유닛테스트를 할수 있도록 합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "거리 계산 및 최적화 로직",
            "description": "효율적인 거리 계산과 타겟팅 성능 최적화를 구현합니다.",
            "dependencies": [
              "6.1"
            ],
            "details": "numpy를 활용한 벡터화된 거리 계산 함수를 구현하여 다수의 적에 대한 거리 계산을 최적화합니다. 공간 분할(spatial partitioning) 기법을 적용하여 사거리 내의 적만 효율적으로 필터링하는 시스템을 만듭니다. 매 프레임마다 전체 적을 검색하는 대신 일정 간격(예: 0.1초)으로 타겟을 재선택하여 성능을 향상시킵니다. 거리 계산 시 제곱근 연산을 피하고 거리의 제곱값으로 비교하여 연산 비용을 절약합니다.",
            "status": "done",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 5,
            "title": "ProjectileComponent와 ProjectileSystem 유닛테스트 구현",
            "description": "ProjectileComponent와 ProjectileSystem에 대한 포괄적인 유닛테스트를 구현합니다.",
            "details": "구조화된 인터뷰 프로세스(@.claude/commands/interview-for-unit-test.md)를 통해 ProjectileComponent와 ProjectileSystem의 테스트 시나리오를 도출하고, 포괄적인 유닛테스트를 구현합니다. 투사체 생성, 이동, 충돌 처리, 수명 관리 등 모든 핵심 기능을 검증하는 테스트 케이스를 작성합니다. 개발자 가정은 assert로 처리하고, 비즈니스 로직은 테스트로 검증합니다. 한국어 테스트 메서드명과 상세한 docstring을 포함하여 프로젝트 표준을 준수합니다.",
            "status": "done",
            "dependencies": [
              "6.3"
            ],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "기본 적 AI 및 스포너 시스템",
        "description": "플레이어를 추격하고 공격하는 기본 적 AI와 적 생성 시스템을 구현합니다.",
        "details": "src/systems/ai_system.py에서 EnemyAIComponent를 정의하여 AI 상태(PATROL, CHASE, ATTACK)를 관리합니다. 적과 플레이어 사이의 거리에 따라 행동을 결정하는 상태 기반 AI를 구현합니다. EnemySpawner 클래스로 일정 시간마다 화면 가장자리에서 적을 생성하며, 시간 경과에 따라 난이도가 증가하도록 적 능력치를 조정합니다. 적의 체력, 공격력, 이동 속도를 JSON 데이터로 관리합니다.",
        "testStrategy": "AI 상태 전환 로직이 거리와 조건에 따라 정확히 동작하는지 테스트합니다. 적 스포너의 시간 기반 생성과 난이도 조정이 의도대로 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EnemyAIComponent와 AI 상태 구조 설계",
            "description": "AI 상태(PATROL, CHASE, ATTACK)를 관리하는 EnemyAIComponent 클래스를 설계하고 구현합니다.",
            "dependencies": [],
            "details": "src/systems/ai_system.py에 EnemyAIComponent 클래스를 생성하고, AI_STATE 열거형으로 PATROL, CHASE, ATTACK 상태를 정의합니다. 각 상태별 행동 로직을 위한 메서드 구조를 설계하고, 상태 전환을 위한 조건 검사 시스템을 구현합니다. 적의 현재 타겟, 상태, 이동 방향 등을 저장하는 데이터 구조를 만듭니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "거리 기반 AI 상태 전환 로직 구현",
            "description": "플레이어와의 거리에 따라 AI 상태가 자동으로 전환되는 로직을 구현합니다.",
            "dependencies": [
              "7.1"
            ],
            "details": "플레이어와 적 사이의 거리를 계산하는 함수를 구현하고, 거리에 따른 상태 전환 임계값(순찰 범위, 추격 시작 거리, 공격 범위)을 설정합니다. update_ai_state() 메서드에서 현재 거리를 확인하여 적절한 상태로 전환하는 로직을 구현합니다. 각 상태별 행동(순찰 이동, 플레이어 추격, 공격 실행)을 구현합니다. 상태를 변경하는 조건 계산과 계산 로직, 상태 변경 로직을 분리하여 유닛테스트를 할수 있도록 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "EnemySpawner와 시간 기반 생성 시스템 구현",
            "description": "일정 시간마다 화면 가장자리에서 적을 생성하는 EnemySpawner 시스템을 구현합니다.",
            "dependencies": [
              "7.1"
            ],
            "details": "EnemySpawner 클래스를 생성하고, 스폰 타이머와 스폰 간격을 관리하는 시스템을 구현합니다. 화면 가장자리의 랜덤한 위치에서 적을 생성하는 로직을 만들고, 화면 밖 영역에서 생성되도록 스폰 포인트를 계산합니다. 동시에 존재할 수 있는 최대 적 수 제한을 구현합니다. 동시에 적을 생성 할 수 있는지의 여부 판단 로직을 분리, 스폰 타임 측정하는 로직 분리 등 판단을 계산하는 로직과 실제 변경하는 로직을 분리하여 유닛테스트 하기 유용하도록 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "시간 기반 난이도 조정 메커니즘 구현",
            "description": "게임 진행 시간에 따라 적의 능력치와 스폰 빈도가 증가하는 난이도 조정 시스템을 구현합니다.",
            "dependencies": [
              "7.3"
            ],
            "details": "게임 경과 시간을 추적하는 시스템을 구현하고, 시간에 따른 난이도 계수를 계산하는 함수를 만듭니다. 적 생성 시 현재 난이도에 따라 체력, 공격력, 이동 속도를 조정하는 로직을 구현합니다. 스폰 간격도 시간이 지날수록 점차 단축되도록 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "JSON 기반 적 데이터 관리 시스템 구현",
            "description": "적의 기본 능력치와 AI 설정을 JSON 파일로 관리하는 데이터 시스템을 구현합니다.",
            "dependencies": [
              "7.2"
            ],
            "details": "data/enemies.json 파일을 생성하여 적 타입별 기본 스탯(체력, 공격력, 이동 속도, AI 임계값 등)을 정의합니다. JSON 데이터를 로드하고 적 생성 시 해당 데이터를 적용하는 DataManager 클래스를 구현합니다. 적 타입별로 다른 AI 행동 패턴을 설정할 수 있도록 확장 가능한 구조를 만듭니다. 팩토리 패턴을 사용해서 시간 대 별로 스폰 정책을 따로 설정할 수 있고, 개별의 스폰 정책에 대해서 스폰 시스템이 몰라도 되도록 추상화 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          }
        ]
      },
      {
        "id": 8,
        "title": "경험치 및 레벨업 시스템",
        "description": "적 처치 시 경험치 획득과 레벨업 메커니즘을 구현합니다.",
        "details": "src/systems/experience_system.py에서 ExperienceComponent를 정의하여 현재 경험치, 레벨, 필요 경험치를 관리합니다. 적 처치 시 경험치를 부여하는 이벤트 시스템을 구현하고, 레벨업 시 필요 경험치를 증가시키는 공식을 적용합니다. 레벨업 시 LEVEL_UP 이벤트를 발생시켜 다른 시스템에서 반응할 수 있도록 합니다. UI에서 경험치 바를 표시하기 위한 렌더링 컴포넌트를 구현합니다.",
        "testStrategy": "경험치 계산과 레벨업 조건이 정확한지 테스트합니다. 레벨업 이벤트가 적절히 발생하고 다른 시스템에 전달되는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ExperienceComponent와 경험치 관리 구조 구현",
            "description": "경험치, 레벨, 필요 경험치를 관리하는 ExperienceComponent와 기본 데이터 구조를 구현합니다.",
            "dependencies": [],
            "details": "src/systems/experience_system.py에 ExperienceComponent 클래스를 정의하여 current_exp, level, exp_to_next_level 속성을 관리합니다. 초기값 설정과 데이터 검증 로직을 포함하며, 경험치 관련 계산을 위한 헬퍼 메서드들을 구현합니다.\n<info added on 2025-08-09T06:05:55.142Z>\n기존 헬퍼 메서드 방식 대신 Strategy 패턴을 도입하여 ExperienceCalculationStrategy 추상 클래스를 생성하고 DefaultExperienceStrategy, LinearExperienceStrategy, ExponentialExperienceStrategy 등 구체적인 전략 클래스들을 구현합니다. ExperienceComponent에서 strategy 속성을 추가하여 런타임에 계산 전략을 교체할 수 있도록 합니다. 또한 IExperiencePolicy 인터페이스를 정의하여 레벨업 조건, 경험치 배율, 보상 정책 등을 추상화하고 정책 변경 시 코드 수정 없이 설정 파일이나 의존성 주입을 통해 정책을 교체할 수 있는 구조로 설계합니다.\n</info added on 2025-08-09T06:05:55.142Z>",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "이벤트 기반 경험치 부여 시스템 구현",
            "description": "적 처치 시 경험치를 부여하는 이벤트 시스템과 경험치 획득 로직을 구현합니다.",
            "dependencies": [
              "8.1"
            ],
            "details": "ENEMY_DEFEATED 이벤트를 수신하여 적 유형별 경험치를 부여하는 ExperienceSystem을 구현합니다. 이벤트 리스너를 등록하고, 적 처치 시 경험치 계산 및 ExperienceComponent 업데이트 로직을 작성합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "레벨업 공식과 LEVEL_UP 이벤트 처리 구현",
            "description": "레벨업 조건 확인, 필요 경험치 증가 공식, LEVEL_UP 이벤트 발생 로직을 구현합니다.",
            "dependencies": [
              "8.2"
            ],
            "details": "경험치가 필요 경험치에 도달했을 때 레벨업을 처리하는 로직을 구현합니다. 레벨별 필요 경험치 증가 공식(예: level * 100)을 적용하고, 레벨업 시 LEVEL_UP 이벤트를 발생시켜 다른 시스템에서 반응할 수 있도록 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "UI 렌더링용 경험치 컴포넌트 구현",
            "description": "경험치 바 표시를 위한 UI 렌더링 컴포넌트와 시각적 피드백을 구현합니다.",
            "dependencies": [
              "8.3"
            ],
            "details": "경험치 정보를 UI에 표시하기 위한 ExperienceRenderer를 구현합니다. 현재 경험치/최대 경험치 비율을 계산하여 프로그레스 바로 표시하고, 레벨업 시 시각적 이펙트와 경험치 획득 시 숫자 표시 효과를 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "JSON 기반 아이템 시스템 및 인벤토리",
        "description": "JSON 데이터 기반 아이템과 6슬롯 인벤토리, 레벨업 시 아이템 선택 UI를 구현합니다.",
        "details": "data/items.json에서 아이템 데이터(이름, 설명, 효과, 아이콘)를 정의합니다. src/systems/inventory_system.py에서 6슬롯 제한 인벤토리를 구현하고, ItemComponent로 아이템 효과를 관리합니다. 레벨업 시 2개 아이템 중 1개를 선택하는 UI를 구현하며, 아이템 효과를 즉시 플레이어에게 적용하는 시스템을 만듭니다. 아이템 효과는 가산 방식으로 중첩되도록 구현합니다.",
        "testStrategy": "아이템 데이터 로딩과 인벤토리 관리 로직을 테스트합니다. 아이템 효과 적용과 중첩 계산이 정확한지 검증하며, UI 상호작용이 올바르게 작동하는지 테스트합니다.",
        "priority": "high",
        "dependencies": [
          4,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "JSON 아이템 데이터 구조 설계 및 로딩 시스템 구현",
            "description": "data/items.json 파일 생성 및 ItemData 모델 정의, DataLoader를 통한 아이템 데이터 로딩 구현",
            "dependencies": [],
            "details": "data/items.json에서 아이템 속성(이름, 설명, 효과 타입, 효과 값, 아이콘 경로)을 정의합니다. Pydantic ItemData 모델로 타입 안전성을 보장하고, DataLoader 클래스에 load_items() 메서드를 추가하여 JSON 파일을 로딩합니다. 아이템 효과는 ATTACK_SPEED, DAMAGE, HEALTH 등 열거형으로 관리합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "6슬롯 인벤토리 관리 시스템 구현",
            "description": "InventoryComponent 및 InventorySystem 구현으로 6개 슬롯 제한 아이템 보관 시스템 개발",
            "dependencies": [
              "9.1"
            ],
            "details": "src/systems/inventory_system.py에서 InventoryComponent(최대 6개 슬롯)와 InventorySystem을 구현합니다. add_item(), remove_item(), is_full() 메서드로 인벤토리 관리를 담당하고, 아이템 중복 시 수량 증가 로직을 구현합니다. 인벤토리 상태 변화 시 INVENTORY_CHANGED 이벤트를 발생시킵니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "ItemComponent 및 아이템 효과 적용 메커니즘 구현",
            "description": "ItemComponent 정의 및 플레이어 스탯에 아이템 효과를 적용하는 시스템 구현",
            "dependencies": [
              "9.2"
            ],
            "details": "src/components/item_component.py에서 ItemComponent(아이템 ID, 수량, 효과 목록)를 정의합니다. ItemEffectSystem에서 인벤토리 아이템들의 효과를 플레이어 스탯에 가산 방식으로 적용하는 calculate_total_effects() 메서드를 구현합니다. 실시간으로 아이템 효과가 플레이어에게 반영되도록 합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "레벨업 시 아이템 선택 UI 시스템 구현",
            "description": "레벨업 이벤트 감지 및 2개 아이템 중 1개 선택하는 모달 UI 구현",
            "dependencies": [
              "9.3"
            ],
            "details": "src/ui/item_selection_ui.py에서 ItemSelectionUI 클래스를 구현합니다. LEVEL_UP 이벤트 수신 시 랜덤한 2개 아이템을 제시하고, 마우스 클릭으로 선택할 수 있는 모달 창을 표시합니다. 선택된 아이템은 즉시 인벤토리에 추가되고 효과가 적용됩니다. ESC 키로 선택을 취소할 수 있는 기능도 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "아이템 효과 중첩 계산 및 최적화 로직 구현",
            "description": "동일 아이템의 효과 중첩 계산과 성능 최적화를 위한 캐싱 시스템 구현",
            "dependencies": [
              "9.4"
            ],
            "details": "아이템 효과 중첩을 위한 EffectCalculator 클래스를 구현합니다. 동일 아이템 여러 개 보유 시 가산 방식으로 효과를 누적하고, 계산 결과를 캐싱하여 성능을 최적화합니다. 아이템 변경 시에만 효과를 재계산하도록 하고, 효과별 최대 한계치 설정 기능을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "룰 엔진 기반 시너지 시스템",
        "description": "특정 아이템 조합 시 추가 효과가 발생하는 룰 엔진 기반 시너지 시스템을 구현합니다.",
        "details": "src/systems/synergy_system.py에서 룰 엔진을 구현하여 아이템 조합 패턴을 검사합니다. data/synergies.json에서 시너지 규칙(조합 아이템 목록, 추가 효과)을 정의합니다. 인벤토리 변경 시마다 활성 시너지를 재계산하고, 시너지 효과를 플레이어 스탯에 적용합니다. 축구화+축구공=15% 데미지 증가 등의 기본 시너지를 구현하며, 시너지 효과에 최대치 제한(데미지 300%, 공격속도 200%)을 설정합니다.",
        "testStrategy": "다양한 아이템 조합에 대한 시너지 인식과 효과 적용을 테스트합니다. 시너지 규칙 변경 시 실시간 반영과 최대치 제한이 정상 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "룰 엔진 아키텍처 설계 및 기본 구조 구현",
            "description": "시너지 시스템의 핵심이 되는 룰 엔진의 기본 아키텍처를 설계하고 구현합니다.",
            "dependencies": [],
            "details": "src/systems/synergy_system.py에 SynergyRuleEngine 클래스를 생성하고, 규칙 로딩, 패턴 매칭, 효과 계산을 담당하는 기본 인터페이스를 정의합니다. Rule, Pattern, Effect 등의 기본 데이터 클래스들을 구현하여 시너지 규칙의 구조를 명확히 합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "시너지 패턴 매칭 알고리즘 구현",
            "description": "아이템 조합을 분석하여 시너지 패턴을 찾는 핵심 알고리즘을 구현합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "PatternMatcher 클래스를 구현하여 현재 인벤토리의 아이템들이 정의된 시너지 패턴과 일치하는지 효율적으로 검사합니다. 여러 시너지가 동시에 활성화될 수 있는 경우와 우선순위 처리 로직을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "JSON 기반 시너지 규칙 관리 시스템",
            "description": "data/synergies.json 파일을 통해 시너지 규칙을 관리하는 시스템을 구현합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "축구화+축구공=15% 데미지 증가 등의 기본 시너지 규칙을 JSON 형태로 정의하고, 런타임에 이를 로딩하여 룰 엔진에 적용하는 SynergyRuleLoader 클래스를 구현합니다. 규칙 검증 및 오류 처리 로직도 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "실시간 시너지 계산 및 효과 적용",
            "description": "인벤토리 변경 시마다 활성 시너지를 실시간으로 계산하고 플레이어 스탯에 적용합니다.",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "SynergyCalculator 클래스를 구현하여 인벤토리 변경 이벤트를 감지하고, 활성화된 시너지 효과를 플레이어의 스탯에 실시간으로 적용/해제합니다. 시너지 효과의 누적 계산과 스탯 수정자 시스템과의 연동을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "최대치 제한 및 밸런싱 시스템",
            "description": "시너지 효과에 최대치 제한을 적용하여 게임 밸런스를 유지합니다.",
            "dependencies": [
              "10.4"
            ],
            "details": "데미지 300%, 공격속도 200% 등의 시너지 효과 최대치 제한을 설정하고, BalancingManager 클래스를 통해 이를 관리합니다. 시너지 효과가 설정된 최대치를 넘지 않도록 하는 캡핑 로직과 경고 시스템을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "시너지 시스템 성능 최적화",
            "description": "룰 엔진의 패턴 매칭과 효과 계산 성능을 최적화합니다.",
            "dependencies": [
              "10.4",
              "10.5"
            ],
            "details": "시너지 패턴 매칭 알고리즘을 최적화하여 대량의 아이템과 복잡한 시너지 규칙에서도 60fps를 유지하도록 합니다. 캐싱 메커니즘, 지연 계산, 인덱싱 등의 기법을 적용하여 성능을 개선하고, 프로파일링을 통해 병목점을 식별하고 해결합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "교장선생님 보스 시스템",
        "description": "1분 30초마다 등장하는 교장선생님 보스와 훈화 말씀 패턴을 구현합니다.",
        "details": "src/systems/boss_system.py에서 BossSpawner를 구현하여 90초마다 교장선생님을 소환합니다. BossAI 클래스에서 훈화 말씀 알파(스턴) → 베타(광역 공격) 패턴을 구현합니다. 보스 공격 전 시각적 예고(경고 표시)와 디버프 적용 시스템을 만듭니다. 미션 시스템으로 디버프 해제 조건(특정 적 처치, 시간 경과 등)을 구현하며, 보스 처치 시 추가 보상을 제공합니다.",
        "testStrategy": "보스 등장 타이밍과 패턴 실행이 정확한지 테스트합니다. 디버프 적용과 미션 시스템 연동, 보스 AI 상태 전환이 의도대로 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "BossSpawner와 타이밍 관리 시스템 구현",
            "description": "90초마다 교장선생님 보스를 자동 소환하는 BossSpawner 클래스와 타이밍 관리 시스템을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/boss_system.py에서 BossSpawner 클래스를 구현하여 pygame.time.get_ticks()를 사용한 정확한 90초 간격 체크를 수행합니다. 보스 활성화 상태를 관리하고, 보스가 이미 존재할 때는 새로 소환하지 않는 로직을 포함합니다. 게임 일시정지 시에도 타이밍이 정확히 유지되도록 pause-aware 타이머를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "BossAI 패턴 시스템 (훈화 알파/베타) 구현",
            "description": "교장선생님의 훈화 말씀 패턴(알파: 스턴, 베타: 광역 공격)을 관리하는 BossAI 클래스를 구현합니다.",
            "dependencies": [
              "11.1"
            ],
            "details": "BossAI 클래스에서 상태 머신을 구현하여 IDLE → ALPHA_PATTERN → BETA_PATTERN → COOLDOWN 순서로 상태를 전환합니다. 알파 패턴에서는 전체 플레이어에게 2초간 스턴 디버프를 적용하고, 베타 패턴에서는 광역 데미지를 가하는 공격을 실행합니다. 패턴 간 적절한 쿨다운과 예측 가능한 타이밍을 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "디버프 시스템과 시각적 경고 표시 구현",
            "description": "보스 공격 전 시각적 예고와 디버프 적용/관리 시스템을 구현합니다.",
            "dependencies": [
              "11.2"
            ],
            "details": "src/systems/debuff_system.py에서 DebuffManager 클래스를 구현하여 스턴, 슬로우 등 다양한 디버프를 관리합니다. 보스 공격 3초 전부터 화면에 경고 표시(빨간 테두리, 경고 메시지)를 표시하고, 디버프 아이콘을 UI에 표시합니다. 디버프 지속시간과 효과 강도를 설정 가능하도록 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "미션 기반 디버프 해제 메커니즘 구현",
            "description": "특정 조건을 만족하면 디버프를 해제할 수 있는 미션 시스템을 구현합니다.",
            "dependencies": [
              "11.3"
            ],
            "details": "src/systems/mission_system.py에서 MissionManager 클래스를 구현하여 '특정 적 N마리 처치', '일정 시간 생존', '특정 위치 이동' 등의 미션 조건을 관리합니다. 미션 완료 시 활성 디버프를 제거하고 완료 알림을 표시합니다. 디버프 종류별로 다른 해제 미션을 설정할 수 있도록 data/boss_missions.json을 구성합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "보스 보상 시스템 구현",
            "description": "교장선생님 보스 처치 시 추가 경험치와 특별 아이템을 제공하는 보상 시스템을 구현합니다.",
            "dependencies": [
              "11.2",
              "11.4"
            ],
            "details": "BossRewardSystem 클래스에서 보스 처치 시 일반 적보다 5배 많은 경험치와 희귀 아이템(10% 확률)을 드롭하도록 구현합니다. 보스별 고유 드롭 테이블을 data/boss_rewards.json에 정의하고, 보상 획득 시 특별한 시각적 이펙트와 사운드를 재생합니다. 보스 처치 통계를 기록하여 누적 보상 시스템의 기초를 마련합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "UI 시스템 및 게임 상태 표시",
        "description": "체력바, 경험치바, 아이템 인벤토리 등 핵심 게임 UI를 구현합니다.",
        "details": "src/ui/ 디렉토리에 UISystem을 구현하여 HUD 요소들을 관리합니다. HealthBar, ExperienceBar, InventoryUI, ItemSelectionUI 클래스를 만들어 각각의 UI 요소를 담당하게 합니다. pygame을 사용한 텍스트 렌더링과 프로그레스 바 표시를 구현하며, 레벨업 시 아이템 선택 모달 UI를 만듭니다. 데미지 숫자와 레벨업 이펙트 등 시각적 피드백을 추가합니다.",
        "testStrategy": "UI 요소들이 게임 상태 변화에 따라 정확히 업데이트되는지 테스트합니다. 아이템 선택 UI의 상호작용과 시각적 피드백이 올바르게 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "UISystem 기본 구조와 HUD 관리 시스템 구현",
            "description": "UI 요소들을 통합 관리하는 UISystem 클래스와 기본 HUD 구조를 구현합니다.",
            "dependencies": [],
            "details": "src/ui/ui_system.py에 UISystem 클래스를 생성하여 모든 UI 요소들을 중앙에서 관리합니다. HUD 레이아웃 설정과 UI 요소들의 위치 계산을 담당하며, 게임 상태 변화에 따른 UI 업데이트 이벤트 처리 시스템을 구현합니다. pygame의 Surface와 Rect를 활용한 기본 렌더링 구조를 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "HealthBar와 ExperienceBar 프로그레스 바 구현",
            "description": "플레이어 체력과 경험치를 표시하는 프로그레스 바 UI를 구현합니다.",
            "dependencies": [
              "12.1"
            ],
            "details": "src/ui/health_bar.py와 experience_bar.py에 각각 HealthBar, ExperienceBar 클래스를 구현합니다. 현재값/최대값 비율에 따른 바 채우기 효과와 색상 변화를 구현하며, 부드러운 애니메이션 효과를 추가합니다. 체력 감소 시 빨간색 효과, 경험치 증가 시 파란색 효과 등 시각적 피드백을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "InventoryUI와 ItemSelectionUI 모달 시스템 구현",
            "description": "아이템 인벤토리와 레벨업 시 아이템 선택 모달 UI를 구현합니다.",
            "dependencies": [
              "12.1"
            ],
            "details": "src/ui/inventory_ui.py와 item_selection_ui.py를 구현합니다. InventoryUI는 현재 보유 아이템들을 격자 형태로 표시하고, ItemSelectionUI는 레벨업 시 3개 아이템 중 선택할 수 있는 모달을 구현합니다. 마우스 클릭 이벤트 처리와 아이템 아이콘, 설명 텍스트 렌더링을 포함하며, 모달 배경 어둡게 처리와 애니메이션 효과를 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "시각적 피드백과 이펙트 시스템 구현",
            "description": "데미지 숫자, 레벨업 효과 등 게임 내 시각적 피드백 시스템을 구현합니다.",
            "dependencies": [
              "12.2",
              "12.3"
            ],
            "details": "src/ui/visual_effects.py에 VisualEffects 클래스를 구현합니다. 플로팅 데미지 텍스트(위로 올라가며 페이드아웃), 레벨업 시 화면 전체 빛나는 효과, 아이템 획득 시 알림 메시지를 구현합니다. 파티클 시스템을 활용한 이펙트와 타이밍 기반 애니메이션 관리 시스템을 포함하며, 성능 최적화를 위한 이펙트 풀링 시스템을 적용합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "좌표 변환 시스템 인터페이스 설계 및 기본 구현",
        "description": "ICoordinateTransformer 인터페이스와 CameraBasedTransformer 기본 구현을 개발하여 월드-스크린 좌표 변환 시스템의 기반을 구축한다.",
        "details": "추상 베이스 클래스 ICoordinateTransformer를 정의하고 world_to_screen(), screen_to_world(), get_camera_offset() 메서드를 포함한다. CameraBasedTransformer 클래스로 초기 구현을 제공하며, 캐싱 메커니즘을 포함한다. 향후 OptimizedTransformer와 SpatialOptimizedTransformer로 확장 가능한 다형성 구조를 구현한다. Vector2 클래스 기반으로 좌표 계산을 수행하고, 성능을 위한 캐시 무효화 플래그를 관리한다.",
        "testStrategy": "단위 테스트로 world_to_screen과 screen_to_world 변환의 정확성을 검증하고, 왕복 변환 시 좌표 일관성을 확인한다. 다양한 카메라 오프셋 값에 대한 경계값 테스트를 수행하며, 캐싱 동작 테스트를 포함한다.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "ICoordinateTransformer 인터페이스 및 Vector2 수학 클래스 설계",
            "description": "좌표 변환 시스템의 핵심 인터페이스와 수학적 연산을 담당하는 Vector2 클래스를 설계하고 구현한다",
            "dependencies": [],
            "details": "src/core/coordinate_transformer.py에 ICoordinateTransformer ABC 클래스를 정의하여 world_to_screen(), screen_to_world(), get_camera_offset(), invalidate_cache() 메서드를 포함한다. src/utils/vector2.py에 Vector2 클래스를 구현하여 좌표 계산, 벡터 연산, 거리 계산 등을 지원한다. 모든 좌표 변환은 Vector2 타입으로 처리하며, 성능을 위한 __slots__ 최적화를 적용한다. 타입 힌트를 완전히 적용하고 IntEnum으로 좌표 타입을 정의한다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "CameraBasedTransformer 기본 구현",
            "description": "ICoordinateTransformer 인터페이스를 구현하는 CameraBasedTransformer 클래스를 개발한다",
            "dependencies": [
              "13.1"
            ],
            "details": "src/core/camera_based_transformer.py에 CameraBasedTransformer 클래스를 구현한다. 카메라 오프셋을 기반으로 한 기본적인 world_to_screen, screen_to_world 변환 로직을 구현한다. 카메라 중심점, 줌 레벨, 화면 크기를 고려한 변환 수식을 적용한다. 변환 매트릭스 개념을 도입하여 확장 가능성을 고려한다. 기존 PlayerMovementSystem, CameraSystem과의 통합을 위해 PositionComponent와 호환되는 구조로 설계한다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "좌표 변환 캐싱 메커니즘 구현",
            "description": "성능 최적화를 위한 좌표 변환 결과 캐싱 시스템을 구현한다",
            "dependencies": [
              "13.2"
            ],
            "details": "CameraBasedTransformer에 LRU 캐시를 적용하여 자주 사용되는 좌표 변환 결과를 저장한다. 카메라 위치나 줌 레벨 변경 시 캐시를 무효화하는 cache_dirty 플래그를 관리한다. 캐시 히트율 추적 기능을 구현하여 성능 모니터링을 지원한다. 메모리 사용량을 제한하는 최대 캐시 크기를 설정한다. 향후 Task 22의 성능 최적화와 연계하여 40+ FPS 목표 달성에 기여한다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "좌표 변환 시스템 통합 테스트 및 기존 시스템 영향도 분석",
            "description": "구현된 좌표 변환 시스템의 정확성을 검증하고 기존 시스템과의 통합 영향을 분석한다",
            "dependencies": [
              "13.3"
            ],
            "details": "tests/test_coordinate_transformer.py에 단위 테스트를 작성하여 world_to_screen과 screen_to_world의 왕복 변환 정확성을 검증한다. 다양한 카메라 오프셋과 줌 레벨에서의 경계값 테스트를 수행한다. 캐싱 메커니즘의 동작과 무효화 로직을 테스트한다. PlayerMovementSystem, EnemyAISystem, AutoAttackSystem에서 좌표 변환 사용 시 발생할 수 있는 영향을 분석하고 호환성을 확인한다. RenderSystem과의 연동을 위한 인터페이스 검증을 수행한다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "CoordinateManager 전역 관리자 구현",
        "description": "좌표 변환 시스템을 전역적으로 관리하고 런타임에 변환 구현체를 교체할 수 있는 CoordinateManager를 구현한다.",
        "details": "CoordinateManager 클래스를 구현하여 ICoordinateTransformer 인스턴스를 관리한다. set_transformer() 메서드로 런타임에 좌표 변환 구현체를 교체할 수 있도록 하고, 옵저버 패턴을 적용하여 변환기 변경 시 관련 시스템들에게 알림을 보낸다. 전역 싱글톤으로 관리하되 테스트를 위한 의존성 주입도 지원한다. world_to_screen, screen_to_world 래퍼 메서드를 제공한다.",
        "testStrategy": "좌표 변환기 교체 동작을 테스트하고, 옵저버 패턴 알림 기능을 검증한다. 싱글톤 동작과 스레드 안전성을 테스트하며, 다양한 변환기 구현체와의 호환성을 확인한다.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "CoordinateManager 싱글톤 패턴 구현",
            "description": "스레드 안전한 싱글톤 패턴으로 CoordinateManager 클래스를 구현하고, ICoordinateTransformer 인스턴스 관리 기능을 추가한다.",
            "dependencies": [],
            "details": "CoordinateManager 클래스에 싱글톤 패턴을 적용하여 전역 인스턴스 관리를 구현한다. _instance 클래스 변수와 threading.Lock을 사용하여 스레드 안전성을 보장한다. get_instance() 클래스 메서드로 싱글톤 인스턴스에 접근하고, _transformer 필드로 현재 좌표 변환기를 저장한다. 테스트를 위한 의존성 주입을 위해 set_instance() 메서드도 제공한다. world_to_screen, screen_to_world 래퍼 메서드를 구현하여 내부 변환기에 위임한다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "런타임 변환기 교체 시스템 구현",
            "description": "set_transformer() 메서드를 구현하여 런타임에 ICoordinateTransformer 구현체를 안전하게 교체할 수 있는 시스템을 구현한다.",
            "dependencies": [
              "14.1"
            ],
            "details": "set_transformer(transformer: ICoordinateTransformer) 메서드를 구현하여 현재 좌표 변환기를 교체한다. 변환기 교체 시 캐시 무효화 처리를 수행하고, 유효성 검사를 통해 올바른 ICoordinateTransformer 인터페이스 구현체인지 확인한다. get_transformer() 메서드로 현재 변환기 접근을 제공하며, 변환기가 설정되지 않은 경우 기본값으로 CameraBasedTransformer를 사용한다. 변환기 교체 과정에서 스레드 안전성을 보장한다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "옵저버 패턴 기반 알림 메커니즘 구현",
            "description": "변환기 변경 시 관련 시스템들에게 알림을 보내는 옵저버 패턴을 구현하고, CameraComponent와 MapRenderSystem 등의 좌표 의존 시스템과 연동한다.",
            "dependencies": [
              "14.2"
            ],
            "details": "ICoordinateObserver 인터페이스를 정의하고 on_transformer_changed() 메서드를 포함한다. CoordinateManager에 _observers 리스트를 추가하고, add_observer(), remove_observer() 메서드를 구현한다. set_transformer() 호출 시 모든 등록된 옵저버에게 notify_observers()를 통해 변경 사항을 알린다. CameraSystem과 MapRenderSystem이 옵저버로 등록하여 좌표 변환기 변경에 대응할 수 있도록 한다. 옵저버 알림 시 예외 처리를 포함하여 한 옵저버의 오류가 다른 옵저버에 영향을 주지 않도록 한다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 15,
        "title": "CameraComponent와 CameraSystem 구현",
        "description": "플레이어 중앙 고정을 위한 CameraComponent와 월드 오프셋을 관리하는 CameraSystem을 구현한다.",
        "details": "CameraComponent는 world_offset, screen_center, world_bounds, follow_target 필드를 포함한다. CameraSystem은 ISystem을 구현하여 플레이어 이동의 역방향으로 카메라 월드 오프셋을 업데이트한다. 마우스 추적을 위한 데드존 처리(10픽셀)와 월드 경계 처리를 포함한다. CoordinateManager와 연동하여 좌표 변환 캐시 무효화를 관리한다. 화면 중앙을 기준으로 SCREEN_WIDTH//2, SCREEN_HEIGHT//2 좌표를 사용한다.",
        "testStrategy": "카메라 오프셋 업데이트 로직을 테스트하고, 월드 경계 제한 동작을 검증한다. 플레이어 이동에 따른 역방향 카메라 이동을 테스트하며, CoordinateManager 연동 동작을 확인한다.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "CameraComponent 데이터 구조 설계 및 구현",
            "description": "카메라 시스템의 핵심 데이터를 저장하는 CameraComponent를 dataclass로 구현합니다.",
            "dependencies": [],
            "details": "CameraComponent는 world_offset(tuple[float, float]), screen_center(tuple[int, int]), world_bounds(dict), follow_target(Optional[Entity]) 필드를 포함합니다. world_offset은 월드 좌표계에서의 카메라 오프셋을, screen_center는 화면 중앙 좌표(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)를 저장합니다. world_bounds는 카메라 이동 제한 영역을 정의하고, follow_target은 추적 대상 엔티티를 참조합니다. 타입 힌트와 기본값을 완전히 지정하여 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "CameraSystem 업데이트 로직 구현",
            "description": "ISystem을 구현하는 CameraSystem 클래스를 작성하여 카메라 오프셋 업데이트 로직을 구현합니다.",
            "dependencies": [
              "15.1"
            ],
            "details": "CameraSystem은 플레이어 이동의 역방향으로 world_offset을 업데이트하여 플레이어가 화면 중앙에 고정되도록 합니다. 마우스 추적을 위한 10픽셀 데드존 처리를 구현하고, world_bounds를 사용한 월드 경계 제한을 적용합니다. update() 메서드에서 delta_time을 받아 부드러운 카메라 이동을 지원하며, 플레이어 위치 변화에 따른 즉시 오프셋 계산을 수행합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "CoordinateManager 연동 및 캐시 관리 구현",
            "description": "CameraSystem과 CoordinateManager 간의 연동을 구현하고 좌표 변환 캐시 무효화 메커니즘을 구축합니다.",
            "dependencies": [
              "15.2"
            ],
            "details": "CameraSystem에서 world_offset이 변경될 때 CoordinateManager의 캐시 무효화를 호출하여 좌표 변환 정확성을 보장합니다. screen_to_world(), world_to_screen() 변환 함수와의 연동을 구현하고, 카메라 이동 시 영향받는 모든 렌더링 시스템에 변경사항을 전파합니다. 성능 최적화를 위해 오프셋 변화량이 임계값(1픽셀) 미만일 경우 캐시 무효화를 생략하는 로직을 추가합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 16,
        "title": "PlayerMovementComponent 및 PlayerMovementSystem 재구현",
        "description": "플레이어 중앙 고정 방식에 맞춘 PlayerMovementComponent와 마우스 추적 기반 PlayerMovementSystem을 구현한다.",
        "details": "PlayerMovementComponent를 dataclass로 구현하여 world_position, direction, speed, rotation_angle, angular_velocity_limit 필드를 포함한다. PlayerMovementSystem에서 pygame.mouse.get_pos()로 마우스 위치를 추적하고, 화면 중앙 기준으로 방향을 계산한다. 10픽셀 데드존 처리와 부드러운 회전을 위한 각속도 제한을 적용한다. math.atan2를 사용한 각도 계산과 normalize()를 통한 방향 벡터 정규화를 구현한다.",
        "testStrategy": "마우스 위치에 따른 방향 계산 정확성을 테스트하고, 데드존 동작을 검증한다. 부드러운 회전 로직과 각속도 제한을 테스트하며, 월드 위치 업데이트를 확인한다.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "PlayerMovementComponent 데이터 구조 설계 및 구현",
            "description": "새로운 좌표계에 맞춘 PlayerMovementComponent를 dataclass로 구현하고, 필요한 데이터 필드들을 정의합니다.",
            "dependencies": [],
            "details": "dataclass 기반으로 PlayerMovementComponent를 구현하며, world_position(tuple[float, float]), direction(tuple[float, float]), speed(float), rotation_angle(float), angular_velocity_limit(float) 필드를 포함합니다. 타입 힌트를 완전히 적용하고, 초기값 설정과 데이터 검증 로직을 추가합니다. 좌표계 변화로 인한 추가 필드(이전 위치 추적, 가속도 등)도 고려하여 설계합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "마우스 추적 및 방향 계산 로직 구현",
            "description": "pygame.mouse.get_pos()를 활용한 마우스 위치 추적과 화면 중앙 기준 방향 계산 로직을 구현합니다.",
            "dependencies": [
              "16.1"
            ],
            "details": "PlayerMovementSystem에서 pygame.mouse.get_pos()로 실시간 마우스 위치를 추적하고, CoordinateManager를 통해 화면 중앙(플레이어 고정 위치) 기준으로 방향을 계산합니다. math.atan2를 사용한 정확한 각도 계산과 벡터 정규화(normalize()) 로직을 구현합니다. 좌표계 변환이 마우스 입력 처리에 미치는 영향을 고려하여 world-screen 좌표 변환을 적절히 적용합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "부드러운 회전 및 데드존 처리 시스템 구현",
            "description": "각속도 제한을 통한 부드러운 회전과 10픽셀 데드존 처리 로직을 구현하고 테스트합니다.",
            "dependencies": [
              "16.2"
            ],
            "details": "angular_velocity_limit을 적용한 부드러운 회전 로직을 구현하여 급작스러운 방향 전환을 방지합니다. 마우스 커서가 화면 중앙에서 10픽셀 이내일 때 움직임을 정지시키는 데드존 처리를 구현합니다. 회전 보간(interpolation) 알고리즘을 적용하여 자연스러운 회전 효과를 달성하고, 좌표계 변화로 인한 회전 계산의 정확성을 검증합니다. 성능 최적화를 위한 회전 계산 캐싱도 고려합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 17,
        "title": "MapRenderSystem 무한 스크롤 타일 시스템 구현",
        "description": "카메라 오프셋 기반으로 동작하는 무한 스크롤링 타일 배경 렌더링 시스템을 구현한다.",
        "details": "MapRenderSystem 클래스를 구현하여 64x64 픽셀 타일을 기본 단위로 사용한다. CoordinateManager를 통해 현재 보이는 타일 범위를 계산하고, 화면 밖 1-2타일 여유분을 포함하여 렌더링한다. 타일 패턴은 체스판 형태로 밝은 회색(240,240,240)과 어두운 회색(220,220,220)을 교대로 배치한다. pygame.draw.rect로 타일과 경계선을 그리며, visible_tiles set을 사용한 최적화를 적용한다.",
        "testStrategy": "가시 타일 범위 계산 로직을 테스트하고, 카메라 이동에 따른 타일 업데이트를 검증한다. 타일 패턴 생성과 렌더링 성능을 테스트하며, 메모리 사용량을 모니터링한다.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "가시 타일 범위 계산 알고리즘 구현",
            "description": "CoordinateManager와 연동하여 현재 카메라 위치에서 보이는 타일 범위를 계산하는 알고리즘을 구현합니다.",
            "dependencies": [],
            "details": "CoordinateManager.get_camera_bounds()를 사용해 현재 화면 영역을 가져오고, 64x64 타일 크기를 기준으로 가시 타일의 시작/끝 인덱스를 계산합니다. 화면 밖 1-2타일 여유분을 포함한 확장 영역도 계산하여 부드러운 스크롤을 구현합니다. calculate_visible_tiles() 메서드로 (start_x, start_y, end_x, end_y) 튜플을 반환하도록 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "체스판 패턴 타일 생성 및 렌더링 구현",
            "description": "체스판 형태의 타일 패턴을 생성하고 pygame.draw.rect로 타일과 경계선을 렌더링하는 기능을 구현합니다.",
            "dependencies": [
              "17.1"
            ],
            "details": "밝은 회색(240,240,240)과 어두운 회색(220,220,220)을 (x+y) % 2 조건으로 교대 배치하는 체스판 패턴을 생성합니다. 각 타일을 64x64 픽셀로 그리고, 1픽셀 검은색 경계선을 추가합니다. world_to_screen 좌표 변환을 적용하여 올바른 화면 위치에 렌더링하며, 화면 밖 타일은 그리지 않도록 클리핑을 적용합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "visible_tiles 세트 기반 성능 최적화 및 메모리 관리",
            "description": "visible_tiles set을 사용한 렌더링 최적화와 메모리 효율적인 타일 관리 시스템을 구현합니다.",
            "dependencies": [
              "17.2"
            ],
            "details": "현재 가시 영역의 타일들을 visible_tiles set으로 관리하여 중복 렌더링을 방지합니다. 카메라 이동 시 새로 보이는 타일은 추가하고, 화면을 벗어난 타일은 제거하여 메모리 사용량을 최적화합니다. 타일 캐싱 시스템을 구현하여 동일한 패턴의 타일은 재사용하도록 하며, FPS 모니터링을 통해 40+ FPS 목표 달성을 검증합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 18,
        "title": "EntityRenderSystem 좌표 변환 적용 업데이트",
        "description": "기존 렌더링 시스템을 월드-스크린 좌표 변환이 적용되도록 업데이트하고, 플레이어 중앙 고정 렌더링을 구현한다.",
        "details": "EntityRenderSystem에서 PositionComponent를 가진 엔티티들의 월드 좌표를 CoordinateManager.world_to_screen()으로 변환한다. 화면 밖 컬링을 위한 _is_on_screen() 메서드를 구현하여 50픽셀 여유분으로 성능을 최적화한다. 플레이어는 화면 중앙 고정으로 별도 렌더링하며, 회전 각도를 적용한 스프라이트를 pygame.transform.rotate()로 처리한다. Y좌표 기준 깊이 정렬을 적용한다.",
        "testStrategy": "좌표 변환 정확성을 테스트하고, 화면 밖 컬링 동작을 검증한다. 플레이어 중앙 고정 렌더링과 회전 적용을 테스트하며, 깊이 정렬 기능을 확인한다.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "좌표 변환 시스템 통합 및 world_to_screen 적용",
            "description": "EntityRenderSystem에 CoordinateManager.world_to_screen() 메서드를 통합하여 월드 좌표를 스크린 좌표로 변환하는 기능을 구현합니다.",
            "dependencies": [],
            "details": "EntityRenderSystem 클래스에서 CoordinateManager 인스턴스를 받아 초기화하고, render() 메서드에서 PositionComponent를 가진 모든 엔티티의 월드 좌표를 world_to_screen()으로 변환합니다. 변환된 좌표로 스프라이트를 정확한 스크린 위치에 렌더링하며, 좌표 변환 과정에서 발생할 수 있는 부동소수점 오차를 처리합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "화면 밖 컬링 최적화 시스템 구현",
            "description": "_is_on_screen() 메서드를 구현하여 렌더링할 엔티티를 선별하고 성능을 최적화합니다.",
            "dependencies": [
              "18.1"
            ],
            "details": "화면 경계에서 50픽셀 여유분을 두고 엔티티가 화면 내에 있는지 판단하는 _is_on_screen() 메서드를 구현합니다. 엔티티의 크기(sprite 크기 또는 CollisionComponent)를 고려하여 정확한 컬링을 수행하며, 화면 밖 엔티티는 렌더링 과정에서 제외합니다. 컬링 결과를 통계로 수집하여 성능 모니터링이 가능하도록 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "플레이어 중앙 고정 렌더링 시스템",
            "description": "플레이어를 항상 화면 중앙에 고정하여 렌더링하는 별도 로직을 구현합니다.",
            "dependencies": [
              "18.1"
            ],
            "details": "PlayerComponent를 가진 엔티티를 식별하여 월드 좌표와 관계없이 항상 화면 중앙(screen_width/2, screen_height/2)에 렌더링하도록 _render_player() 메서드를 구현합니다. 플레이어의 회전 각도(RotationComponent)를 pygame.transform.rotate()로 적용하고, 회전으로 인한 스프라이트 크기 변화를 중앙 정렬로 보정합니다. 플레이어 렌더링은 다른 엔티티보다 우선순위를 높여 항상 최상단에 표시합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "깊이 정렬 및 회전 처리 시스템 구현",
            "description": "Y좌표 기반 깊이 정렬과 엔티티별 회전 각도 적용을 구현합니다.",
            "dependencies": [
              "18.2",
              "18.3"
            ],
            "details": "모든 렌더링 대상 엔티티를 Y좌표 기준으로 정렬하여 깊이감을 구현하고, RotationComponent를 가진 엔티티는 pygame.transform.rotate()로 회전을 적용합니다. 회전된 스프라이트의 중심점을 유지하기 위한 offset 계산을 수행하며, 회전으로 인한 성능 저하를 최소화하기 위해 회전 각도가 변경된 경우에만 재계산하는 캐싱 시스템을 구현합니다. 정렬과 회전 처리 과정의 성능을 모니터링할 수 있는 디버그 정보를 제공합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 19,
        "title": "AutoAttackSystem 월드 좌표 기반 재구현",
        "description": "월드 좌표를 기준으로 동작하는 자동 공격 시스템을 구현하여 타겟팅과 투사체 생성을 처리한다.",
        "details": "AutoAttackSystem을 구현하여 시간 기반 공격 쿨다운(FPS 독립적)을 관리한다. _find_nearest_enemy_in_world() 메서드로 플레이어 월드 위치 기준 weapon_range 내의 가장 가까운 적을 탐색한다. WeaponComponent의 attack_speed를 초 단위로 처리하고, Vector2.length()로 거리 계산을 수행한다. 투사체 생성 시 월드 좌표를 기준으로 방향과 속도를 설정한다.",
        "testStrategy": "타겟 탐색 알고리즘의 정확성을 테스트하고, 공격 쿨다운 시간을 검증한다. 월드 좌표 기반 거리 계산과 투사체 생성 로직을 테스트한다.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "시간 기반 공격 쿨다운 시스템 구현",
            "description": "FPS 독립적인 시간 기반 공격 쿨다운을 관리하는 시스템을 구현합니다.",
            "dependencies": [],
            "details": "AutoAttackSystem 클래스에서 WeaponComponent의 attack_speed를 초 단위로 처리하고, delta_time을 사용해 쿨다운 시간을 누적 관리합니다. 각 무기별 공격 속도에 따른 쿨다운 계산 로직을 구현하고, 쿨다운 완료 시 공격 가능 상태로 전환하는 메서드를 작성합니다. 좌표계 변경으로 인해 공격 타이밍이 화면 이동에 독립적으로 유지되도록 합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "월드 좌표 기반 타겟 탐색 시스템 구현",
            "description": "플레이어 월드 위치를 기준으로 weapon_range 내의 가장 가까운 적을 탐색하는 시스템을 구현합니다.",
            "dependencies": [
              "19.1"
            ],
            "details": "_find_nearest_enemy_in_world() 메서드를 구현하여 CoordinateManager를 통해 플레이어의 월드 좌표를 가져옵니다. 모든 적 엔티티의 월드 좌표와 플레이어 사이의 Vector2.length() 거리 계산을 수행하고, weapon_range 내에서 가장 가까운 적을 선택합니다. 좌표계 확장으로 인해 넓어진 게임 월드에서도 정확한 거리 기반 타겟팅이 가능하도록 최적화합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "월드 좌표 기반 투사체 생성 및 방향 계산 시스템 구현",
            "description": "월드 좌표를 기준으로 투사체의 생성 위치와 이동 방향을 계산하는 시스템을 구현합니다.",
            "dependencies": [
              "19.2"
            ],
            "details": "플레이어와 타겟의 월드 좌표를 사용하여 정규화된 방향 벡터를 계산하고, 투사체의 초기 월드 위치와 속도를 설정합니다. ProjectileComponent에 월드 좌표 기반 위치와 방향 정보를 저장하고, 투사체가 화면 밖으로 이동하더라도 월드 좌표에서 추적 가능하도록 구현합니다. 좌표계 변경으로 인한 투사체 궤적의 일관성과 정확성을 보장하는 로직을 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 20,
        "title": "EnemyAISystem 월드 좌표 기반 재구현",
        "description": "월드 좌표를 기준으로 동작하는 적 AI 시스템을 구현하여 추적, 공격, 대기 상태를 처리한다.",
        "details": "EnemyAISystem을 구현하여 플레이어 월드 위치를 기준으로 AI 동작을 처리한다. attack_range와 chase_range를 사용한 상태 기반 AI를 구현하고, 월드 좌표에서 방향 벡터를 계산하여 적의 이동을 처리한다. EnemyAIComponent에는 ai_type, attack_range, chase_range, movement_speed 필드를 포함한다. Vector2.normalize()를 사용한 방향 계산과 delta_time 기반 위치 업데이트를 구현한다.",
        "testStrategy": "AI 상태 전환 로직을 테스트하고, 월드 좌표 기반 거리 계산을 검증한다. 적 추적 동작과 이동 속도 적용을 테스트하며, 다양한 AI 타입별 동작을 확인한다.",
        "priority": "medium",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "월드 좌표 기반 거리 계산 및 상태 전환 로직 구현",
            "description": "좌표계 추가로 인한 AI 시스템의 거리 계산을 월드 좌표 기준으로 재구현하고, attack_range와 chase_range를 활용한 상태 전환 로직을 구현합니다.",
            "dependencies": [],
            "details": "CoordinateSystem을 활용하여 월드 좌표에서 적과 플레이어 간의 거리를 계산하는 로직을 구현합니다. EnemyAIComponent에 attack_range, chase_range, movement_speed 필드를 추가하고, 이를 기반으로 IDLE, CHASE, ATTACK 상태를 전환하는 로직을 작성합니다. 좌표계 변환이 필요한 부분에서 ICoordinateTransformer 인터페이스를 활용하여 화면-월드 간 변환을 처리합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "월드 좌표 기반 방향 벡터 계산 및 정규화 구현",
            "description": "좌표계 변경에 따른 방향 계산을 월드 좌표 기준으로 재구현하고, Vector2 클래스를 활용한 정규화 처리를 구현합니다.",
            "dependencies": [
              "20.1"
            ],
            "details": "월드 좌표에서 적의 현재 위치와 플레이어 위치를 기반으로 방향 벡터를 계산합니다. Vector2.normalize() 메서드를 사용하여 단위 벡터를 생성하고, 8방향 이동 제한이나 대각선 이동 속도 보정 등의 게임 로직을 구현합니다. 좌표계 변환 시 발생할 수 있는 정밀도 손실이나 성능 문제를 고려하여 최적화된 계산 방식을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "월드 좌표 기반 적 이동 처리 및 AI 시스템 통합 테스트",
            "description": "좌표계 기반 이동 로직을 구현하고, 전체 AI 시스템이 새로운 좌표계에서 정상 동작하는지 통합 테스트를 수행합니다.",
            "dependencies": [
              "20.2"
            ],
            "details": "delta_time을 활용한 월드 좌표 기반 위치 업데이트 로직을 구현합니다. EnemyAISystem에서 CoordinateSystem과 연동하여 적의 월드 위치를 업데이트하고, 화면 렌더링을 위한 스크린 좌표 변환을 처리합니다. AI 상태별 동작 테스트, 좌표 변환 정확성 테스트, 다양한 AI 타입별 동작 검증을 포함한 통합 테스트를 구현하여 기존 AI 로직이 새로운 좌표계에서 올바르게 작동하는지 확인합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 21,
        "title": "좌표계 테스트 스위트 구현",
        "description": "좌표 변환 시스템의 정확성과 성능을 검증하는 포괄적인 테스트 스위트를 구현한다.",
        "details": "pytest 기반으로 tests/unit/test_coordinates.py와 tests/performance/test_coordinate_performance.py를 구현한다. 좌표 변환 정확성 테스트, 왕복 변환 일관성 테스트, 다형성 인터페이스 호환성 테스트를 포함한다. @pytest.mark.parametrize를 사용한 다양한 변환기 클래스 테스트와 성능 벤치마크를 구현한다. 1000개 좌표 변환을 100ms 이내 처리하는 성능 요구사항을 검증한다.",
        "testStrategy": "모든 좌표 변환 함수의 수학적 정확성을 검증하고, 경계값과 예외 상황을 테스트한다. 성능 벤치마크로 기본 구현체 대비 최적화 구현체의 성능 향상을 측정한다.",
        "priority": "high",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "좌표 변환 정확성 단위 테스트 구현",
            "description": "월드-스크린 변환, 왕복 변환 일관성, 경계값 테스트를 포함한 수학적 정확성 검증",
            "dependencies": [],
            "details": "tests/unit/test_coordinates.py 구현. WorldToScreenTransformer, ScreenToWorldTransformer의 변환 정확성 테스트. @pytest.mark.parametrize를 사용한 다양한 좌표값 테스트(정수, 부동소수점, 음수, 0, 극값). 왕복 변환 일관성 검증: world → screen → world 변환 후 원래 좌표와의 오차 허용범위(1픽셀) 내 확인. 카메라 이동, 줌 레벨 변경에 따른 변환 정확성 테스트.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "다형성 인터페이스 호환성 테스트 구현",
            "description": "ICoordinateTransformer 인터페이스를 구현한 모든 변환기 클래스의 호환성 검증",
            "dependencies": [
              "21.1"
            ],
            "details": "다형성 테스트 구현으로 모든 변환기 클래스가 ICoordinateTransformer 인터페이스를 올바르게 구현하는지 검증. WorldToScreenTransformer, ScreenToWorldTransformer, CachedCoordinateTransformer 등 모든 구현체 테스트. 인터페이스 메서드 시그니처 호환성과 반환값 타입 검증. 변환기 교체 시 동작 일관성 테스트.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "성능 벤치마크 테스트 구현",
            "description": "1000개 좌표 변환을 100ms 이내 처리하는 성능 요구사항 검증 및 최적화 효과 측정",
            "dependencies": [],
            "details": "tests/performance/test_coordinate_performance.py 구현. 1000개 좌표 변환 성능 벤치마크: 기본 변환기와 캐시된 변환기 성능 비교. 시간 측정을 위한 time.perf_counter() 사용. 메모리 사용량 프로파일링으로 GC 압박 측정. 다양한 카메라 위치와 줌 레벨에서 성능 일관성 테스트. 프레임당 변환 호출 수 시뮬레이션 테스트.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "통합 시나리오 테스트 구현",
            "description": "실제 게임 상황을 시뮬레이션한 좌표계 시스템 통합 테스트 및 영향도 검증",
            "dependencies": [
              "21.1",
              "21.2",
              "21.3"
            ],
            "details": "CoordinateManager와 CameraSystem, PlayerMovementSystem, EnemyAISystem 간 통합 테스트. 플레이어 이동에 따른 카메라 추적과 월드-스크린 좌표 동기화 검증. 적 AI의 월드 좌표 기반 추적 동작과 화면 렌더링 위치 일치성 테스트. 투사체 시스템의 궤적 계산과 충돌 감지 정확성 검증. 실제 게임 루프 환경에서 좌표계 안정성과 일관성 테스트. 다중 엔티티 상호작용 시나리오에서 좌표 변환 정확성 검증.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 22,
        "title": "통합 시스템 조정 및 게임 루프 최적화",
        "description": "모든 좌표계 관련 시스템을 통합하고, 40+ FPS 목표를 달성하기 위한 게임 루프 최적화를 수행한다.",
        "details": "SystemOrchestrator에서 시스템 실행 순서를 최적화하여 CameraSystem → PlayerMovementSystem → EnemyAISystem → AutoAttackSystem → RenderSystem 순으로 처리한다. CoordinateManager의 프레임 진행 관리와 캐시 무효화 타이밍을 조정한다. 성능 모니터링을 위한 FPS 카운터와 좌표 변환 호출 수 추적을 구현한다. 적 20마리와 투사체 상황에서 40+ FPS 달성을 목표로 한다.",
        "testStrategy": "통합 테스트로 전체 게임 루프의 안정성을 검증하고, 성능 프로파일링으로 병목 지점을 식별한다. 다양한 게임 상황에서 FPS 안정성을 측정하고, 메모리 사용량을 모니터링한다.",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "SystemOrchestrator 실행 순서 최적화 구현",
            "description": "좌표계 시스템을 포함한 전체 시스템의 실행 순서를 최적화하여 CameraSystem → CoordinateManager → PlayerMovementSystem → EnemyAISystem → AutoAttackSystem → CollisionSystem → RenderSystem 순으로 처리하도록 SystemOrchestrator를 수정한다.",
            "dependencies": [],
            "details": "SystemOrchestrator.update() 메서드에서 시스템 실행 순서를 명시적으로 정의하고, 좌표 변환이 필요한 시스템들 간의 의존성을 고려한 실행 순서를 구현한다. ExecutionPhase enum(COORDINATE_UPDATE, MOVEMENT, AI_LOGIC, COLLISION, RENDER)을 정의하여 각 단계별로 시스템을 분류하고 순차 실행한다. 시스템 간 데이터 흐름을 최적화하여 불필요한 좌표 변환을 최소화한다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "좌표 변환 캐시 관리 시스템 구현",
            "description": "CoordinateManager의 캐시 무효화 타이밍을 최적화하고, 프레임별 캐시 관리 전략을 구현하여 좌표 변환 성능을 극대화한다.",
            "dependencies": [
              "22.1"
            ],
            "details": "CoordinateManager에 frame_begin()과 frame_end() 메서드를 추가하여 프레임 단위 캐시 관리를 구현한다. 카메라 이동이나 줌 변경 시에만 캐시를 무효화하는 스마트 캐시 전략을 적용한다. 변환 빈도가 높은 좌표는 LRU 캐시로 관리하고, 프레임당 최대 캐시 엔트리 수를 제한하여 메모리 사용량을 조절한다. 캐시 히트율과 변환 호출 수를 추적하는 디버그 정보를 제공한다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "성능 모니터링 시스템 구현",
            "description": "FPS 카운터, 좌표 변환 호출 수, 시스템별 처리 시간을 추적하는 성능 모니터링 시스템을 구현한다.",
            "dependencies": [
              "22.1"
            ],
            "details": "PerformanceMonitor 클래스를 구현하여 각 시스템의 실행 시간을 측정하고, 좌표 변환 호출 횟수와 캐시 히트율을 추적한다. FPS 계산과 평균/최소/최대 FPS 통계를 제공한다. 성능 데이터를 JSON 형태로 저장하여 분석할 수 있도록 한다. 디버그 모드에서 화면에 실시간 성능 정보를 표시하는 UI를 구현한다. 성능 임계값을 설정하여 경고를 출력하는 기능을 포함한다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "FPS 안정성 확보 및 프레임 제한 구현",
            "description": "40+ FPS 목표 달성을 위한 프레임 제한과 안정화 메커니즘을 구현하여 다양한 게임 상황에서 일정한 성능을 보장한다.",
            "dependencies": [
              "22.2",
              "22.3"
            ],
            "details": "pygame.time.Clock을 사용한 프레임 제한을 구현하고, 적응적 품질 조정 시스템을 추가한다. 적이 20마리 이상이거나 투사체가 많을 때 자동으로 렌더링 품질을 조정하는 기능을 구현한다. delta_time 기반의 시간 독립적인 업데이트 로직을 모든 시스템에 적용한다. 프레임 드랍이 발생할 때 비필수적인 시각 효과를 일시적으로 비활성화하는 성능 보호 기능을 추가한다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "메모리 사용량 최적화 및 통합 테스트",
            "description": "전체 시스템의 메모리 사용량을 최적화하고, 통합 테스트를 통해 40+ FPS 목표 달성과 시스템 안정성을 검증한다.",
            "dependencies": [
              "22.4"
            ],
            "details": "메모리 풀링을 사용하여 Entity와 Component 객체 생성/소멸 비용을 최소화한다. 불필요한 객체 참조를 제거하고 가비지 컬렉션 부하를 줄이는 메모리 관리를 구현한다. 적 20마리, 투사체 50개, 아이템 10개가 동시에 존재하는 상황에서 40+ FPS를 유지하는지 통합 테스트를 수행한다. memory_profiler를 사용한 메모리 사용량 분석과 성능 병목 지점을 식별하는 프로파일링을 실시한다. 전체 시스템의 안정성과 성능 목표 달성을 종합적으로 검증한다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 23,
        "title": "이벤트 시스템 기본 인프라 구현",
        "description": "게임의 느슨한 결합을 위한 이벤트 기반 아키텍처의 기본 클래스들을 구현",
        "details": "BaseEvent 추상 클래스, EventType IntEnum, IEventSubscriber 인터페이스를 구현합니다. BaseEvent는 event_type과 timestamp를 포함하며, EventType은 display_name 프로퍼티를 가진 다층 구조로 설계합니다. IEventSubscriber는 handle_event와 get_subscribed_events 메서드를 정의합니다. 모든 클래스는 Python 3.13+ 타입 힌트를 완전히 적용하고 dataclass를 활용합니다.",
        "testStrategy": "BaseEvent 생성 및 timestamp 자동 설정 검증, EventType enum의 display_name 프로퍼티 테스트, IEventSubscriber 인터페이스 구현체의 메서드 호출 테스트",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "BaseEvent 추상 클래스 구현",
            "description": "모든 게임 이벤트의 기본이 되는 BaseEvent 추상 클래스를 구현합니다.",
            "dependencies": [],
            "details": "src/core/events/base_event.py에 BaseEvent 추상 클래스를 구현합니다. event_type(EventType), timestamp(float), created_at(datetime) 필드를 포함하며, @dataclass와 ABC를 활용합니다. timestamp는 time.time()으로 자동 설정되고, Python 3.13+ 타입 힌트를 완전 적용합니다. 추상 메서드 validate()를 정의하여 하위 클래스에서 이벤트 데이터 유효성 검증을 구현하도록 합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "EventType IntEnum 다층 구조 설계",
            "description": "이벤트 타입을 구분하고 성능과 표시를 위한 다층 EventType IntEnum을 구현합니다.",
            "dependencies": [],
            "details": "src/core/events/event_types.py에 EventType IntEnum을 구현합니다. ENEMY_DEATH(0), ITEM_DROP(1), EXPERIENCE_GAIN(2), WEAPON_FIRED(3) 등의 타입을 정의하고, display_name 프로퍼티로 한국어 표시명('적 사망', '아이템 드롭' 등)을 제공합니다. _display_names 딕셔너리와 인덱스 기반 성능 최적화를 적용하며, 향후 확장을 위한 카테고리별 그룹핑도 고려합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "IEventSubscriber 인터페이스 정의",
            "description": "이벤트 구독자를 위한 표준 인터페이스를 정의합니다.",
            "dependencies": [],
            "details": "src/core/events/interfaces.py에 IEventSubscriber ABC 인터페이스를 구현합니다. handle_event(event: BaseEvent) -> None 추상 메서드로 이벤트 처리를 정의하고, get_subscribed_events() -> list[EventType] 추상 메서드로 구독할 이벤트 타입 목록을 반환하도록 합니다. 타입 안전성을 위해 Generic[T] 활용을 검토하고, 예외 처리 가이드라인을 문서화합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "타입 힌트 및 dataclass 통합 적용",
            "description": "구현된 모든 이벤트 시스템 클래스에 Python 3.13+ 타입 힌트와 dataclass를 완전 적용합니다.",
            "dependencies": [
              "23.1",
              "23.2",
              "23.3"
            ],
            "details": "BaseEvent, EventType, IEventSubscriber에 Python 3.13+ 네이티브 타입 힌트(list[EventType], dict[str, Any] 등)를 완전 적용합니다. @dataclass(frozen=True)를 BaseEvent에 적용하여 불변성을 보장하고, __post_init__ 메서드로 timestamp 자동 설정을 구현합니다. mypy strict 모드 통과를 위한 타입 체크를 수행하고, 모든 메서드의 반환 타입을 명시합니다. ruff를 사용한 코드 포맷팅과 린팅을 적용합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 24,
        "title": "EventBus 큐잉 시스템 구현",
        "description": "큐 기반 이벤트 발행/처리 시스템을 구현하여 ECS 시스템 독립성을 보장",
        "details": "EventBus 클래스를 구현하여 deque 기반 이벤트 큐, 구독자 관리(Dict[EventType, Set[IEventSubscriber]]), 재진입 방지를 포함합니다. publish 메서드로 이벤트를 큐에 저장하고, process_events로 일괄 처리합니다. 구독자 예외 격리를 위해 try-catch로 각 구독자를 보호하고, get_queue_size로 성능 모니터링을 지원합니다.",
        "testStrategy": "이벤트 발행 및 큐 저장 검증, 다중 구독자 처리 테스트, 구독자 예외 격리 테스트, 재진입 방지 검증, 큐 크기 모니터링 테스트",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "deque 기반 이벤트 큐 구조 구현",
            "description": "EventBus 클래스에 deque를 사용한 이벤트 큐 자료구조를 구현하고 기본적인 큐 관리 기능을 추가",
            "dependencies": [],
            "details": "collections.deque를 사용하여 이벤트 큐를 구현합니다. _event_queue 속성으로 deque 인스턴스를 관리하고, 큐의 기본 조작 메서드(enqueue, dequeue)를 준비합니다. 큐 크기 제한과 오버플로우 방지 로직을 포함하여 메모리 안정성을 보장합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "구독자 관리 Dictionary 시스템 구현",
            "description": "이벤트 타입별 구독자를 관리하는 Dictionary 기반 시스템을 구현하고 구독/구독해제 기능을 추가",
            "dependencies": [
              "24.1"
            ],
            "details": "_subscribers: Dict[EventType, Set[IEventSubscriber]] 구조로 구독자 관리 시스템을 구현합니다. subscribe/unsubscribe 메서드를 통해 구독자를 등록/해제하고, 이벤트 타입별로 구독자 Set을 유지관리합니다. 중복 구독 방지와 존재하지 않는 구독자 해제 시 안전한 처리를 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "publish/process_events 메서드 구현",
            "description": "이벤트 발행과 일괄 처리를 담당하는 핵심 메서드들을 구현하여 큐 기반 이벤트 처리 흐름을 완성",
            "dependencies": [
              "24.2"
            ],
            "details": "publish 메서드는 이벤트를 큐에 저장하고, process_events는 큐의 모든 이벤트를 순차적으로 처리합니다. 재진입 방지를 위한 _processing_events 플래그를 사용하여 중첩 처리를 방지하고, 큐가 비어있을 때까지 반복 처리하는 안전한 루프를 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "구독자 예외 격리 처리 시스템 구현",
            "description": "개별 구독자의 예외가 전체 이벤트 처리를 중단시키지 않도록 예외 격리 시스템을 구현",
            "dependencies": [
              "24.3"
            ],
            "details": "각 구독자의 handle_event 호출을 try-catch 블록으로 래핑하여 개별 구독자 예외를 격리합니다. 예외 발생 시 로깅 처리를 통해 디버깅을 지원하고, 다른 구독자들의 정상 처리를 보장합니다. 예외 통계를 수집하여 모니터링 기능에 활용할 수 있도록 준비합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "성능 모니터링 기능 구현",
            "description": "이벤트 큐 상태와 처리 성능을 모니터링할 수 있는 기능들을 구현하여 시스템 관찰성을 제공",
            "dependencies": [
              "24.4"
            ],
            "details": "get_queue_size, get_subscriber_count, get_processing_stats 등의 모니터링 메서드를 구현합니다. 큐 크기, 구독자 수, 처리된 이벤트 수, 예외 발생 횟수 등의 통계를 제공하여 성능 분석과 디버깅을 지원합니다. 선택적으로 처리 시간 측정 기능을 포함하여 성능 최적화에 활용할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 25,
        "title": "게임 이벤트 타입 정의 및 구현",
        "description": "게임에서 사용할 구체적인 이벤트 클래스들을 정의하고 구현",
        "details": "EnemyDeathEvent, ProjectileCreatedEvent 등 게임 전용 이벤트 클래스를 구현합니다. EnemyDeathEvent는 enemy_entity_id를 포함하며 데이터 검증(빈 문자열, None 방지)을 수행합니다. 각 이벤트는 BaseEvent를 상속받고 적절한 EventType을 설정합니다. 최소한의 데이터만 포함하여 성능을 최적화합니다.",
        "testStrategy": "각 이벤트 클래스의 생성 및 데이터 검증 테스트, event_type 자동 설정 검증, 데이터 validation 실패 케이스 테스트",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EnemyDeathEvent 클래스 구현",
            "description": "적 사망 시 발행되는 EnemyDeathEvent 클래스를 구현하고 데이터 검증 로직을 추가합니다.",
            "dependencies": [],
            "details": "BaseEvent를 상속받는 EnemyDeathEvent 클래스를 src/core/events/enemy_death_event.py에 구현합니다. enemy_entity_id 필드를 포함하며, __init__에서 None이나 빈 문자열 검증을 수행합니다. event_type은 EventType.ENEMY_DEATH로 자동 설정되도록 구현합니다. @dataclass 데코레이터를 사용하여 타입 안정성을 보장하고, 최소한의 데이터만 포함하여 성능을 최적화합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "ProjectileCreatedEvent 클래스 구현",
            "description": "투사체 생성 시 발행되는 ProjectileCreatedEvent 클래스를 구현하고 데이터 검증 로직을 추가합니다.",
            "dependencies": [],
            "details": "BaseEvent를 상속받는 ProjectileCreatedEvent 클래스를 src/core/events/projectile_created_event.py에 구현합니다. projectile_entity_id, weapon_type, target_position 필드를 포함하며, __init__에서 각 필드의 유효성 검증을 수행합니다. event_type은 EventType.PROJECTILE_CREATED로 자동 설정되도록 구현합니다. @dataclass 데코레이터를 사용하여 타입 안정성을 보장하고, 필수 데이터만 포함하여 메모리 사용량을 최적화합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "이벤트 데이터 검증 및 성능 최적화",
            "description": "구현된 이벤트 클래스들의 데이터 검증을 강화하고 성능 최적화를 적용합니다.",
            "dependencies": [
              "25.1",
              "25.2"
            ],
            "details": "각 이벤트 클래스에 validate() 메서드를 추가하여 런타임 데이터 검증을 수행합니다. __slots__ 속성을 추가하여 메모리 사용량을 최적화하고, property 메서드를 통해 읽기 전용 필드를 보장합니다. 잘못된 데이터 입력 시 명확한 에러 메시지와 함께 ValueError를 발생시키도록 예외 처리를 구현합니다. 이벤트 객체 생성 성능을 측정하고 최적화합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 26,
        "title": "ProjectileSystem 책임 분리 리팩토링",
        "description": "기존 ProjectileSystem에서 적 사망 처리 로직을 제거하고 이벤트 발행자로 역할 변경",
        "details": "ProjectileSystem을 IEventPublisher 인터페이스로 확장하고, 적과의 충돌 시 EnemyDeathEvent만 발행하도록 수정합니다. 기존의 경험치 계산, 엔티티 제거 로직을 제거하고 이벤트 버스를 통한 발행만 담당합니다. _handle_enemy_death 메서드를 단순화하여 이벤트 발행 후 투사체 제거만 처리합니다.",
        "testStrategy": "투사체-적 충돌 시 EnemyDeathEvent 발행 검증, 기존 직접 처리 로직 제거 확인, 이벤트 발행 후 적절한 투사체 제거 테스트",
        "priority": "high",
        "dependencies": [
          24,
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "IEventPublisher 인터페이스 설계 및 구현",
            "description": "모든 이벤트 발행자가 구현해야 할 공통 인터페이스를 정의하고 ProjectileSystem이 이를 구현하도록 수정",
            "dependencies": [],
            "details": "src/core/interfaces/event_publisher.py에 IEventPublisher 인터페이스를 생성하고 publish_event 추상 메서드를 정의합니다. ProjectileSystem 클래스가 이 인터페이스를 구현하도록 수정하고, __init__ 메서드에 event_bus 참조를 추가합니다. 인터페이스의 타입 힌트와 추상 메서드 시그니처를 명확히 정의하여 일관된 이벤트 발행 패턴을 보장합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "기존 직접 처리 로직 제거 및 정리",
            "description": "ProjectileSystem에서 적 사망과 관련된 직접 처리 로직들을 식별하고 제거",
            "dependencies": [
              "26.1"
            ],
            "details": "_handle_enemy_death 메서드에서 경험치 계산, 엔티티 제거, 직접적인 적 컴포넌트 조작 로직을 제거합니다. 기존에 EntityManager를 통해 직접 처리하던 적 제거 로직과 경험치 시스템 호출 부분을 정리합니다. 코드 리뷰를 통해 다른 메서드에 숨어있는 직접 처리 로직이 있는지 확인하고 제거합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EnemyDeathEvent 발행 로직 구현",
            "description": "투사체와 적의 충돌 시 EnemyDeathEvent를 생성하고 이벤트 버스를 통해 발행하는 로직 구현",
            "dependencies": [
              "26.1",
              "26.2"
            ],
            "details": "_handle_enemy_death 메서드를 수정하여 EnemyDeathEvent 객체를 생성하고 publish_event 메서드를 통해 이벤트 버스에 발행합니다. 이벤트 생성 시 필요한 데이터(enemy_entity_id)를 정확히 전달하고, 이벤트 발행 성공/실패에 대한 기본적인 예외 처리를 추가합니다. 이벤트 발행 후의 후처리 로직을 명확히 분리합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "투사체 제거 로직 단순화 및 최적화",
            "description": "이벤트 발행 후 투사체 제거만을 담당하도록 로직을 단순화하고 성능 최적화",
            "dependencies": [
              "26.3"
            ],
            "details": "_handle_enemy_death 메서드에서 EnemyDeathEvent 발행 후 해당 투사체만 제거하도록 로직을 단순화합니다. 투사체 제거 시 불필요한 컴포넌트 조회나 추가적인 계산을 제거하여 성능을 최적화합니다. 투사체 제거 로직의 에러 처리를 추가하고, 제거 실패 시의 대응 방안을 구현합니다. 메모리 누수 방지를 위한 적절한 리소스 정리를 보장합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 27,
        "title": "ExperienceSystem 이벤트 구독 시스템 구현",
        "description": "적 사망 이벤트를 구독하여 경험치를 처리하는 전용 시스템 구현",
        "details": "ExperienceSystem을 IEventSubscriber로 구현하여 EnemyDeathEvent를 구독합니다. handle_event 메서드에서 적 엔티티 조회, EnemyComponent에서 경험치 보상 계산, 플레이어에게 경험치 적용을 처리합니다. EntityManager를 통해 적 정보를 조회하고 get_experience_reward 메서드로 적절한 경험치를 계산합니다.",
        "testStrategy": "EnemyDeathEvent 구독 및 처리 검증, 적 엔티티 조회 및 경험치 계산 테스트, 플레이어 경험치 적용 검증, 존재하지 않는 적 엔티티 처리 테스트",
        "priority": "medium",
        "dependencies": [
          24,
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "IEventSubscriber 인터페이스 구현",
            "description": "이벤트 구독을 위한 기본 인터페이스를 정의하고 ExperienceSystem에서 구현합니다.",
            "dependencies": [],
            "details": "src/core/event_subscriber.py에 IEventSubscriber 추상 인터페이스를 구현합니다. handle_event 메서드를 추상 메서드로 정의하여 이벤트 처리 구조를 표준화합니다. ExperienceSystem 클래스가 IEventSubscriber를 상속받도록 하고, handle_event 메서드의 기본 구조를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "EnemyDeathEvent 구독 로직 구현",
            "description": "EnemyDeathEvent를 구독하고 필터링하는 로직을 구현합니다.",
            "dependencies": [
              "27.1"
            ],
            "details": "handle_event 메서드에서 이벤트 타입을 검증하여 EnemyDeathEvent만 처리하도록 구현합니다. 이벤트 타입 체크 로직과 잘못된 이벤트 타입에 대한 처리를 추가합니다. 이벤트 데이터 유효성 검증 로직을 구현하여 enemy_entity_id가 올바른지 확인합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "경험치 계산 및 적용 시스템 구현",
            "description": "적 사망 시 경험치를 계산하고 플레이어에게 적용하는 로직을 구현합니다.",
            "dependencies": [
              "27.2"
            ],
            "details": "EnemyComponent에서 get_experience_reward 메서드를 호출하여 적절한 경험치를 계산합니다. 플레이어 엔티티를 조회하고 ExperienceComponent에 경험치를 추가하는 로직을 구현합니다. 경험치 적용 후 레벨업 조건 확인 및 처리 로직을 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "엔티티 조회 및 예외 처리 구현",
            "description": "EntityManager를 통한 안전한 엔티티 조회와 예외 상황 처리를 구현합니다.",
            "dependencies": [
              "27.3"
            ],
            "details": "EntityManager를 통해 적 엔티티와 플레이어 엔티티를 조회하는 로직을 구현합니다. 존재하지 않는 엔티티나 누락된 컴포넌트에 대한 예외 처리를 추가합니다. 로그 출력을 통해 디버깅과 모니터링이 가능하도록 구현합니다. 엔티티 조회 실패 시 graceful한 처리 방식을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 28,
        "title": "ItemDropSystem 및 EntityCleanupSystem 구현",
        "description": "적 사망 시 아이템 드롭과 엔티티 정리를 담당하는 전용 시스템들을 구현",
        "details": "ItemDropSystem은 EnemyDeathEvent를 구독하여 적 사망 위치에서 확률적 아이템 드롭을 처리합니다. EntityCleanupSystem은 동일 이벤트를 구독하여 사망한 적 엔티티를 EntityManager에서 제거합니다. 두 시스템 모두 IEventSubscriber를 구현하고 독립적으로 동작하도록 설계합니다.",
        "testStrategy": "ItemDropSystem의 아이템 드롭 확률 계산 및 생성 테스트, EntityCleanupSystem의 엔티티 제거 검증, 두 시스템의 독립적 동작 확인",
        "priority": "medium",
        "dependencies": [
          24,
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ItemDropSystem 이벤트 구독 및 기본 구조 구현",
            "description": "EnemyDeathEvent를 구독하는 ItemDropSystem 클래스를 생성하고 IEventSubscriber 인터페이스를 구현합니다.",
            "dependencies": [],
            "details": "src/systems/item_drop_system.py에 ItemDropSystem 클래스를 구현합니다. IEventSubscriber 인터페이스를 상속받아 handle_event() 메서드를 구현하고, EnemyDeathEvent 타입만을 처리하도록 필터링합니다. 시스템 초기화 시 EventManager에 구독을 등록하고, 적 사망 위치 정보를 추출하는 기본 로직을 구현합니다. 시스템의 활성화/비활성화 상태 관리 기능을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "확률적 아이템 드롭 로직 구현",
            "description": "적 사망 시 확률에 따라 아이템을 생성하는 드롭 확률 계산 및 아이템 생성 시스템을 구현합니다.",
            "dependencies": [
              "28.1"
            ],
            "details": "아이템별 드롭 확률을 정의하는 DROP_RATES 상수를 구현하고, 적 타입에 따른 드롭 테이블을 설계합니다. random.random()을 사용한 확률 계산 로직을 구현하여 드롭 여부를 결정합니다. 아이템 타입별 ItemComponent 생성 로직을 구현하고, 적 사망 위치에 아이템 엔티티를 생성하는 _create_item_entity() 메서드를 작성합니다. 드롭된 아이템의 PositionComponent를 적의 최종 위치로 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EntityCleanupSystem 엔티티 제거 로직 구현",
            "description": "EnemyDeathEvent를 구독하여 사망한 적 엔티티를 EntityManager에서 안전하게 제거하는 시스템을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/entity_cleanup_system.py에 EntityCleanupSystem 클래스를 구현합니다. IEventSubscriber 인터페이스를 상속받아 EnemyDeathEvent 처리 로직을 구현하고, EntityManager.remove_entity()를 호출하여 엔티티를 제거합니다. 엔티티 제거 전 필요한 정리 작업(컴포넌트 해제, 메모리 정리)을 수행하는 _cleanup_entity_resources() 메서드를 구현합니다. 엔티티 제거 과정에서 발생할 수 있는 예외 상황을 처리하는 안전 장치를 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "두 시스템의 독립성 보장 및 통합 테스트",
            "description": "ItemDropSystem과 EntityCleanupSystem이 서로 독립적으로 동작하면서 올바르게 협력하는지 검증하는 테스트를 작성합니다.",
            "dependencies": [
              "28.2",
              "28.3"
            ],
            "details": "각 시스템이 동일한 EnemyDeathEvent에 대해 독립적으로 반응하는지 테스트합니다. 한 시스템의 오류가 다른 시스템의 동작에 영향을 주지 않는지 검증하는 격리 테스트를 작성합니다. 적 사망 시 아이템 드롭과 엔티티 제거가 모두 정상적으로 실행되는지 확인하는 통합 테스트를 구현합니다. 시스템 간 실행 순서에 관계없이 올바른 결과가 나오는지 검증하고, 각 시스템의 성능 영향도를 측정하는 벤치마크 테스트를 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 29,
        "title": "GameLoop 이벤트 시스템 통합",
        "description": "메인 게임 루프에 이벤트 시스템을 통합하고 시스템 간 구독 관계를 설정",
        "details": "GameLoop 클래스에 EventBus를 추가하고 모든 이벤트 발행/구독 시스템을 등록합니다. _setup_event_subscriptions 메서드로 구독 관계를 자동 설정하고, update 메서드에서 모든 시스템 업데이트 후 event_bus.process_events()를 호출합니다. SystemOrchestrator에 새로운 시스템들을 적절한 priority로 등록합니다.",
        "testStrategy": "게임 루프의 이벤트 시스템 초기화 검증, 구독 관계 자동 설정 테스트, 시스템 업데이트 후 이벤트 처리 순서 확인",
        "priority": "high",
        "dependencies": [
          26,
          27,
          28
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "GameLoop에 EventBus 통합 구현",
            "description": "GameLoop 클래스에 EventBus 인스턴스를 추가하고 초기화 로직을 구현합니다.",
            "dependencies": [],
            "details": "GameLoop 클래스의 __init__ 메서드에서 EventBus 인스턴스를 생성하고, 초기화 메서드에서 event_bus.initialize()를 호출합니다. EventBus가 게임 루프의 생명주기와 동기화되도록 start/stop 메서드에서 EventBus 상태를 관리합니다. EventBus 참조를 다른 시스템에서 접근할 수 있도록 getter 메서드를 제공합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "시스템 구독 관계 자동 설정 구현",
            "description": "_setup_event_subscriptions 메서드를 구현하여 시스템별 이벤트 구독을 자동화합니다.",
            "dependencies": [
              "29.1"
            ],
            "details": "GameLoop 클래스에 _setup_event_subscriptions 메서드를 추가하여 각 시스템의 이벤트 구독을 자동 설정합니다. SystemOrchestrator에서 관리하는 모든 시스템을 순회하며, IEventSubscriber 인터페이스를 구현한 시스템들을 EventBus에 등록합니다. 시스템별로 관심 있는 이벤트 타입을 자동 감지하여 구독 관계를 설정하고, 구독 실패 시 로그를 남기고 예외를 처리합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "이벤트 처리 순서 관리 구현",
            "description": "GameLoop의 update 메서드에서 시스템 업데이트와 이벤트 처리 순서를 적절히 관리합니다.",
            "dependencies": [
              "29.2"
            ],
            "details": "GameLoop.update() 메서드를 수정하여 모든 시스템의 업데이트가 완료된 후 event_bus.process_events()를 호출하도록 합니다. 시스템 업데이트 → 이벤트 처리 → 렌더링 순서로 프레임 처리 플로우를 구성합니다. 이벤트 처리 중 발생하는 새로운 이벤트들이 다음 프레임에서 처리되도록 이벤트 큐 관리를 구현합니다. 성능 모니터링을 위해 이벤트 처리 시간을 측정하고 기록합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "SystemOrchestrator 시스템 등록 구현",
            "description": "새로운 이벤트 관련 시스템들을 SystemOrchestrator에 적절한 우선순위로 등록합니다.",
            "dependencies": [
              "29.3"
            ],
            "details": "SystemOrchestrator에 새로 개발된 이벤트 기반 시스템들(ExperienceSystem, ItemDropSystem, EntityCleanupSystem 등)을 등록합니다. 시스템 간 의존성을 고려하여 적절한 priority 값을 설정하고 실행 순서를 보장합니다. 이벤트를 발행하는 시스템(CollisionSystem, ProjectileSystem)과 이벤트를 구독하는 시스템들의 실행 순서를 조정합니다. 시스템 등록 과정에서 발생할 수 있는 의존성 충돌을 검사하고 해결하는 로직을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 30,
        "title": "이벤트 시스템 단위 테스트 구현",
        "description": "이벤트 시스템의 모든 컴포넌트에 대한 포괄적인 단위 테스트 작성",
        "details": "tests/unit/test_events.py에 EventBus, 각종 이벤트 클래스, 구독자 인터페이스에 대한 단위 테스트를 작성합니다. pytest fixture를 활용한 테스트 환경 구성, Mock을 이용한 구독자 테스트, 예외 상황 처리 검증을 포함합니다. @pytest.mark.events 마커로 이벤트 관련 테스트를 분류합니다.",
        "testStrategy": "EventBus 기능별 단위 테스트, 이벤트 클래스 생성 및 검증 테스트, 구독자 인터페이스 구현 테스트, 예외 상황 처리 테스트",
        "priority": "medium",
        "dependencies": [
          24,
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EventBus 단위 테스트 구현",
            "description": "EventBus 클래스의 이벤트 구독, 발행, 구독 해제 등 핵심 기능들에 대한 단위 테스트를 작성합니다.",
            "dependencies": [],
            "details": "EventBus의 subscribe/unsubscribe 메소드 테스트, publish 메소드를 통한 이벤트 발행 검증, 여러 구독자가 있을 때 모든 구독자가 이벤트를 받는지 확인, 구독 해제 후 이벤트가 전달되지 않는지 검증하는 테스트를 작성합니다. test_event_bus_subscribe_success, test_event_bus_publish_to_multiple_subscribers, test_event_bus_unsubscribe_success 등의 테스트 메소드를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "이벤트 클래스 단위 테스트 구현",
            "description": "BaseEvent, EnemyDeathEvent 등 이벤트 클래스들의 생성, 데이터 접근, 타입 검증에 대한 단위 테스트를 작성합니다.",
            "dependencies": [],
            "details": "EnemyDeathEvent 생성 및 enemy_entity_id 데이터 접근 테스트, EventType 열거형 할당 및 타입 검증 테스트, BaseEvent 추상 클래스 상속 구조 테스트를 구현합니다. test_enemy_death_event_creation, test_event_type_validation, test_base_event_inheritance 등의 테스트 메소드를 작성하여 이벤트 객체의 무결성을 검증합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "구독자 인터페이스 Mock 테스트 구현",
            "description": "이벤트 구독자 인터페이스의 동작을 검증하기 위한 Mock 객체를 활용한 단위 테스트를 구현합니다.",
            "dependencies": [
              "30.1"
            ],
            "details": "unittest.mock을 사용하여 MockEventSubscriber 클래스를 생성하고, 이벤트 수신 시 호출되는 메소드들을 검증합니다. 구독자가 정확한 이벤트 타입을 받는지, 여러 구독자가 동시에 이벤트를 처리할 수 있는지, 구독자에서 예외 발생 시 다른 구독자에게 영향을 주지 않는지 테스트합니다. test_mock_subscriber_receives_event, test_multiple_subscribers_isolation 등의 테스트를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "예외 상황 처리 테스트 구현",
            "description": "이벤트 시스템에서 발생할 수 있는 다양한 예외 상황들에 대한 처리 로직을 검증하는 테스트를 작성합니다.",
            "dependencies": [
              "30.2",
              "30.3"
            ],
            "details": "잘못된 데이터로 이벤트 생성 시 예외 처리(None, 빈 문자열 entity_id), 존재하지 않는 이벤트 타입 구독 시도, 구독자에서 예외 발생 시 이벤트 버스의 안정성 보장, 메모리 누수 방지를 위한 약한 참조 처리 등을 테스트합니다. test_invalid_event_data_exception, test_subscriber_exception_isolation, test_memory_leak_prevention 등의 테스트 메소드를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "pytest fixture 및 마커 설정 구현",
            "description": "이벤트 시스템 테스트를 위한 pytest fixture들과 테스트 분류를 위한 마커를 설정합니다.",
            "dependencies": [
              "30.1",
              "30.2",
              "30.3",
              "30.4"
            ],
            "details": "EventBus 인스턴스를 제공하는 event_bus fixture, 테스트용 이벤트 객체들을 생성하는 sample_events fixture, Mock 구독자를 제공하는 mock_subscriber fixture를 구현합니다. @pytest.mark.events 마커로 이벤트 관련 테스트를 분류하고, conftest.py에 공통 fixture들을 정의합니다. 테스트 실행 시 이벤트 관련 테스트만 선별적으로 실행할 수 있도록 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 31,
        "title": "이벤트 플로우 통합 테스트 구현",
        "description": "실제 게임 시나리오에서 이벤트 시스템의 전체 플로우를 검증하는 통합 테스트",
        "details": "tests/integration/test_event_flow.py에 투사체-적 충돌부터 경험치 획득, 아이템 드롭, 엔티티 제거까지의 전체 플로우를 테스트합니다. 실제 EntityManager, 각종 시스템들을 사용한 통합 환경에서 이벤트 발행과 처리를 검증합니다. 성능 요구사항(100개 이벤트 2ms 이내 처리) 검증도 포함합니다.",
        "testStrategy": "전체 이벤트 플로우 시나리오 테스트, 다중 구독자 동시 처리 검증, 이벤트 처리 성능 요구사항 검증, 실제 게임 환경에서의 안정성 테스트",
        "priority": "medium",
        "dependencies": [
          29,
          30
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "전체 이벤트 플로우 시나리오 테스트 구현",
            "description": "투사체-적 충돌부터 경험치 획득, 아이템 드롭, 엔티티 제거까지의 완전한 이벤트 체인을 검증하는 시나리오 테스트",
            "dependencies": [],
            "details": "tests/integration/test_event_flow_scenarios.py에 실제 게임 플레이 시나리오를 재현하는 통합 테스트를 구현합니다. 투사체가 적과 충돌했을 때 발생하는 모든 이벤트 체인(충돌 감지 -> 적 사망 -> 경험치 지급 -> 레벨업 체크 -> 아이템 드롭 -> 엔티티 정리)이 순서대로 올바르게 처리되는지 검증합니다. EntityManager, CollisionSystem, ExperienceSystem, ItemDropSystem 등 실제 시스템들을 통합하여 이벤트 발행과 구독자 처리를 테스트합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "다중 구독자 동시 처리 검증 테스트",
            "description": "하나의 이벤트에 대해 여러 시스템이 동시에 구독하고 처리할 때의 안정성과 일관성을 검증하는 테스트",
            "dependencies": [
              "31.1"
            ],
            "details": "tests/integration/test_multiple_subscribers.py에 하나의 EnemyDeathEvent에 대해 ExperienceSystem, ItemDropSystem, AudioSystem, UISystem 등 여러 구독자가 동시에 반응할 때의 처리 순서와 데이터 일관성을 검증하는 테스트를 구현합니다. 구독자 간 의존성이 없어야 하며, 한 구독자의 오류가 다른 구독자에게 영향을 주지 않아야 함을 확인합니다. 멀티스레딩 환경에서의 동시 접근 안전성도 검증합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "성능 요구사항 테스트 구현",
            "description": "이벤트 시스템이 성능 요구사항(100개 이벤트 2ms 이내 처리)을 만족하는지 검증하는 성능 테스트",
            "dependencies": [
              "31.1"
            ],
            "details": "tests/performance/test_event_performance.py에 이벤트 시스템의 성능을 정량적으로 측정하는 테스트를 구현합니다. 100개의 동시 이벤트 발행 시 처리 완료까지 걸리는 시간이 2ms 이내인지 검증하고, 메모리 사용량 모니터링, 구독자별 처리 시간 측정, 이벤트 큐 오버플로우 처리 등을 테스트합니다. 다양한 이벤트 타입과 구독자 수 조합에서의 성능 특성을 분석합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "실제 게임 환경 통합 테스트",
            "description": "완전한 게임 환경에서 이벤트 시스템이 다른 게임 시스템들과 안정적으로 통합되어 동작하는지 검증하는 통합 테스트",
            "dependencies": [
              "31.2",
              "31.3"
            ],
            "details": "tests/integration/test_game_environment_integration.py에 GameLoop, TimeManager, SystemOrchestrator와 함께 동작하는 실제 게임 환경에서의 이벤트 시스템 안정성을 검증하는 테스트를 구현합니다. 게임 일시정지/재개, 상태 전환(메뉴/플레이/게임오버), 프레임 드롭 상황에서의 이벤트 처리 일관성을 테스트합니다. 장시간 실행(30초 이상) 테스트를 통해 메모리 누수나 성능 저하가 없는지 확인합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 32,
        "title": "이벤트 시스템 성능 최적화 및 모니터링",
        "description": "이벤트 시스템의 성능을 최적화하고 런타임 모니터링 기능을 구현",
        "details": "EventPerformanceMonitor 클래스를 구현하여 이벤트 처리 성능을 실시간 모니터링합니다. 프레임당 최대 이벤트 수(100개) 제한, 처리 시간 임계값(2ms) 모니터링, 성능 경고 시스템을 구현합니다. tests/performance/test_event_performance.py에 성능 테스트를 작성하여 요구사항 달성을 검증합니다.",
        "testStrategy": "이벤트 처리 성능 벤치마크 테스트, 대량 이벤트 처리 부하 테스트, 성능 모니터링 경고 시스템 검증, 메모리 사용량 최적화 확인",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EventPerformanceMonitor 클래스 기본 구조 구현",
            "description": "실시간 이벤트 처리 성능을 모니터링하는 EventPerformanceMonitor 클래스의 기본 구조와 인터페이스를 구현합니다.",
            "dependencies": [],
            "details": "src/core/performance/event_performance_monitor.py에 EventPerformanceMonitor 클래스를 생성하고, 이벤트 처리 시간 측정, 프레임당 이벤트 수 추적, 성능 통계 데이터 저장을 위한 기본 속성들을 정의합니다. time 모듈을 사용한 고정밀 시간 측정과 collections.deque를 활용한 효율적인 데이터 버퍼링 구조를 구현합니다. 싱글톤 패턴을 적용하여 전역적으로 접근 가능한 성능 모니터링 인스턴스를 보장합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "프레임당 이벤트 수 제한 메커니즘 구현",
            "description": "프레임당 최대 100개의 이벤트 처리 제한을 적용하는 메커니즘을 구현합니다.",
            "dependencies": [
              "32.1"
            ],
            "details": "EventPerformanceMonitor에 frame_event_limit(기본값 100) 설정과 현재 프레임의 이벤트 카운터를 추가합니다. check_frame_limit() 메서드로 현재 프레임에서 처리된 이벤트 수가 제한을 초과하는지 검사하고, 초과 시 이벤트 처리를 지연시키는 로직을 구현합니다. 프레임 종료 시 카운터를 리셋하는 reset_frame_counter() 메서드를 추가하여 프레임 단위 제한이 정확히 작동하도록 합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "처리 시간 임계값 모니터링 시스템 구현",
            "description": "이벤트 처리 시간이 2ms 임계값을 초과하는지 모니터링하는 시스템을 구현합니다.",
            "dependencies": [
              "32.1"
            ],
            "details": "start_monitoring()과 end_monitoring() 메서드를 구현하여 이벤트 처리 시작과 종료 시점을 측정합니다. processing_time_threshold(기본값 2ms) 설정과 실제 처리 시간을 비교하여 임계값 초과 여부를 판단합니다. 처리 시간 기록을 위한 순환 버퍼를 구현하여 최근 N개 이벤트의 처리 시간 통계를 유지하고, 평균/최대/최소 처리 시간을 계산하는 get_performance_stats() 메서드를 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "성능 경고 시스템 구현",
            "description": "성능 임계값 초과 시 경고를 발행하고 관리하는 시스템을 구현합니다.",
            "dependencies": [
              "32.2",
              "32.3"
            ],
            "details": "PerformanceWarning 데이터 클래스를 정의하여 경고 타입(FRAME_LIMIT_EXCEEDED, PROCESSING_TIME_EXCEEDED), 시간, 측정값, 임계값 정보를 저장합니다. issue_warning() 메서드로 경고를 생성하고 로깅하며, warnings 리스트에 저장합니다. get_recent_warnings()로 최근 경고 조회, clear_warnings()로 경고 기록 정리, has_active_warnings()로 현재 활성 경고 존재 여부를 확인하는 메서드들을 구현합니다. Python logging 모듈을 통해 WARNING 레벨로 성능 이슈를 기록합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "성능 테스트 구현",
            "description": "이벤트 시스템의 성능 요구사항을 검증하는 종합적인 테스트를 구현합니다.",
            "dependencies": [
              "32.4"
            ],
            "details": "tests/performance/test_event_performance.py에 EventPerformanceMonitor의 모든 기능을 검증하는 테스트를 작성합니다. 100개 이벤트 처리 시 2ms 이내 완료 검증, 프레임당 이벤트 수 제한 동작 확인, 처리 시간 임계값 초과 시 경고 발행 테스트를 구현합니다. 대량 이벤트(1000개) 처리 부하 테스트로 시스템 안정성을 검증하고, 메모리 사용량이 일정 수준을 유지하는지 확인하는 메모리 누수 테스트를 추가합니다. pytest-benchmark를 사용한 성능 벤치마크 테스트도 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 33,
        "title": "ProjectileSystem 옵저버 패턴 리팩토링 - Phase 1: 이벤트 정의 및 데이터 구조 설계",
        "description": "ProjectileSystem의 책임 분리를 위한 옵저버 패턴 적용의 첫 단계로, 이벤트 기반 아키텍처의 기초가 되는 이벤트 정의와 데이터 구조를 설계하고 구현",
        "details": "BaseEvent 추상 클래스를 구현하여 모든 이벤트의 기본 구조를 정의합니다. EnemyDeathEvent 클래스를 생성하여 적 사망 시 발행되는 이벤트 데이터 구조를 설계하며, enemy_entity_id 필드만 포함하여 최소한의 데이터 전달 원칙을 따릅니다. 이벤트 타입을 구분하기 위한 EventType Enum을 구현하고, 각 이벤트 클래스에 타입 식별자를 추가합니다. 구독자가 EntityManager를 통해 필요한 컴포넌트를 조회할 수 있도록 일관된 데이터 접근 패턴을 설계합니다. src/core/events/ 디렉토리 구조를 생성하고 base_event.py, enemy_death_event.py, event_types.py 파일로 모듈을 분리합니다.",
        "testStrategy": "EnemyDeathEvent 생성 및 데이터 접근 테스트를 작성하여 이벤트 객체가 올바른 enemy_entity_id를 보유하는지 검증합니다. 이벤트 타입 검증 및 데이터 무결성 테스트로 EventType Enum이 올바르게 할당되고 타입 체크가 작동하는지 확인합니다. 잘못된 데이터로 이벤트 생성 시 예외 처리 테스트를 구현하여 None이나 빈 문자열 등의 잘못된 entity_id 처리를 검증합니다. BaseEvent 추상 클래스의 상속 구조 테스트로 모든 이벤트가 올바른 기본 구조를 따르는지 확인합니다. tests/unit/test_events.py에 포괄적인 단위 테스트를 작성하여 이벤트 구조의 안정성을 보장합니다.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "BaseEvent 추상 클래스 구현",
            "description": "모든 이벤트의 기본 구조를 정의하는 BaseEvent 추상 클래스를 구현합니다.",
            "dependencies": [],
            "details": "src/core/events/base_event.py 파일을 생성하고 BaseEvent 추상 클래스를 구현합니다. 이벤트의 기본 속성인 event_type(EventType), timestamp(float), source_system(Optional[str])을 정의합니다. 추상 메서드 validate_data()를 선언하여 각 이벤트가 데이터 유효성 검증을 구현하도록 강제합니다. __init__ 메서드에서 timestamp를 자동으로 현재 시간으로 설정하고, __repr__ 메서드를 구현하여 디버깅을 지원합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "EventType Enum 구현",
            "description": "이벤트 타입을 구분하기 위한 EventType Enum을 구현합니다.",
            "dependencies": [],
            "details": "src/core/events/event_types.py 파일을 생성하고 IntEnum을 상속받는 EventType 클래스를 구현합니다. ENEMY_DEATH = 0, PROJECTILE_HIT = 1, PLAYER_LEVEL_UP = 2 등의 이벤트 타입을 정의합니다. 각 타입의 display_name 속성을 구현하여 한글 표시명을 제공하고, _type_descriptions 딕셔너리로 각 이벤트 타입의 설명을 관리합니다. 성능 최적화를 위해 _type_priorities 배열로 인덱스 기반 우선순위 조회를 지원합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EnemyDeathEvent 데이터 구조 설계",
            "description": "적 사망 시 발행되는 이벤트의 데이터 구조를 설계하고 구현합니다.",
            "dependencies": [
              "33.1",
              "33.2"
            ],
            "details": "src/core/events/enemy_death_event.py 파일을 생성하고 BaseEvent를 상속받는 EnemyDeathEvent 클래스를 구현합니다. enemy_entity_id(str) 필드만 포함하여 최소한의 데이터 전달 원칙을 따릅니다. validate_data() 메서드에서 enemy_entity_id가 None이거나 빈 문자열인지 검증하고, 유효하지 않은 경우 ValueError를 발생시킵니다. 클래스 메서드 create_from_entity()를 제공하여 Entity 객체로부터 간편하게 이벤트를 생성할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "이벤트 디렉토리 구조 생성 및 모듈 초기화",
            "description": "src/core/events/ 디렉토리 구조를 생성하고 모듈 초기화를 설정합니다.",
            "dependencies": [
              "33.3"
            ],
            "details": "src/core/events/ 디렉토리를 생성하고 __init__.py 파일을 작성하여 모듈로 인식되도록 합니다. __init__.py에서 BaseEvent, EventType, EnemyDeathEvent를 from .base_event import BaseEvent 형태로 임포트하여 외부에서 간편하게 사용할 수 있도록 합니다. __all__ 리스트를 정의하여 공개 API를 명시하고, 타입 힌팅을 위한 TYPE_CHECKING 블록을 추가합니다. 각 모듈 파일의 독립성을 검증하고 순환 임포트가 발생하지 않도록 확인합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-07T18:01:58.038Z",
      "updated": "2025-08-12T22:51:49.624Z",
      "description": "Tasks for master context"
    }
  }
}