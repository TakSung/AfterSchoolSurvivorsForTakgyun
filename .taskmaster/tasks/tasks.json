{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "ECS 프레임워크 기반 구조 설정",
        "description": "Entity-Component-System 아키텍처 기반의 핵심 프레임워크를 구축하고 프로젝트 구조를 설정합니다.",
        "details": "src/core/ 디렉토리에 Entity, Component, System 추상 클래스들을 정의합니다. EntityManager 클래스로 엔티티 생명주기를 관리하고, ComponentRegistry로 컴포넌트 타입별 저장소를 구현합니다. SystemOrchestrator 클래스로 시스템 실행 순서를 제어하는 구조를 만듭니다. Python 3.13+ 환경에서 pygame 2.6.0+, numpy 2.2.4+, pytest 8.0.0+, ruff 0.6.0+ 의존성을 설정합니다.",
        "testStrategy": "각 ECS 컴포넌트의 기본 인터페이스가 정상 동작하는지 단위 테스트를 작성합니다. EntityManager의 엔티티 생성/삭제, ComponentRegistry의 컴포넌트 추가/제거, SystemOrchestrator의 시스템 등록/실행 순서를 검증합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "프로젝트 구조 및 기본 디렉토리 설정",
            "description": "src/core/, src/systems/, tests/ 등 ECS 아키텍처에 맞는 프로젝트 디렉토리 구조를 생성하고 초기 설정 파일들을 구성합니다.",
            "dependencies": [],
            "details": "src/core/, src/systems/, src/components/, src/entities/, tests/ 디렉토리를 생성하고, __init__.py 파일들을 추가합니다. pyproject.toml에 프로젝트 메타데이터와 의존성을 정의하고, .gitignore와 기본 설정 파일들을 생성합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "전체 시스템 구조 docs/design.md 문서를 작성",
            "description": "",
            "details": "<info added on 2025-08-07T19:17:29.270Z>\nECS 프레임워크의 전체 시스템 구조를 설계하고 docs/design.md에 문서화합니다. Entity-Component-System 아키텍처의 핵심 개념과 클래스 관계를 정의하며, 각 시스템 간의 상호작용을 머메이드 다이어그램으로 시각화합니다. 구현 전 모든 개발자가 참조할 수 있는 설계 청사진을 제공하여 일관된 아키텍처 구현을 보장합니다.\n</info added on 2025-08-07T19:17:29.270Z>",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Entity, Component, System 추상 클래스 정의",
            "description": "ECS 아키텍처의 핵심인 Entity, Component, System의 기본 인터페이스와 추상 클래스를 정의합니다.",
            "dependencies": [
              "1.1"
            ],
            "details": "src/core/entity.py에 Entity 클래스, src/core/component.py에 Component 추상 클래스, src/core/system.py에 System 추상 클래스를 정의합니다. 각 클래스는 고유 ID, 생명주기 관리, 상속 가능한 인터페이스를 포함해야 합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EntityManager 클래스 구현",
            "description": "엔티티의 생성, 삭제, 관리를 담당하는 EntityManager 클래스를 구현합니다.",
            "dependencies": [
              "1.2"
            ],
            "details": "src/core/entity_manager.py에 EntityManager 클래스를 구현합니다. create_entity(), destroy_entity(), get_entity(), get_entities_with_component() 등의 메서드를 포함하며, 엔티티 ID 할당과 생명주기를 관리합니다. 약한 참조를 사용한 메모리 관리를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ComponentRegistry 클래스 구현",
            "description": "컴포넌트 타입별 저장소와 관리 기능을 제공하는 ComponentRegistry를 구현합니다.",
            "dependencies": [
              "1.2"
            ],
            "details": "src/core/component_registry.py에 ComponentRegistry 클래스를 구현합니다. add_component(), remove_component(), get_component(), has_component() 메서드를 구현하고, 컴포넌트 타입별로 효율적인 저장 구조를 만듭니다. 타입 안전성과 빠른 조회를 위한 딕셔너리 기반 저장소를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "SystemOrchestrator 클래스 구현",
            "description": "시스템들의 실행 순서를 제어하고 관리하는 SystemOrchestrator를 구현합니다.",
            "dependencies": [
              "1.2",
              "1.3",
              "1.4"
            ],
            "details": "src/core/system_orchestrator.py에 SystemOrchestrator 클래스를 구현합니다. register_system(), unregister_system(), update_systems() 메서드를 포함하며, 시스템 우선순위와 실행 순서를 관리합니다. 시스템 간 의존성과 실행 그룹을 고려한 스케줄링을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "의존성 설정 및 환경 구성",
            "description": "Python 3.13+, pygame 2.6.0+, numpy 2.2.4+ 등 필요한 의존성을 설정하고 개발 환경을 구성합니다.",
            "dependencies": [
              "1.1"
            ],
            "details": "pyproject.toml에 pygame>=2.6.0, numpy>=2.2.4, pytest>=8.0.0, ruff>=0.6.0 의존성을 설정합니다. requirements.txt와 dev-requirements.txt를 생성하고, ruff와 pytest 설정 파일을 추가합니다. Python 가상환경 생성 스크립트와 설치 가이드를 작성합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "게임 루프 및 기본 렌더링 시스템 구현",
        "description": "60fps/40fps 게임 루프와 pygame 기반 기본 렌더링 시스템을 구현합니다.",
        "details": "src/core/game_loop.py에서 pygame.time.Clock을 사용한 고정 시간 간격 게임 루프를 구현합니다. RenderSystem 클래스에서 pygame.sprite.Group을 활용한 기본 스프라이트 렌더링을 구현합니다. 화면 해상도와 FPS 설정을 외부에서 조정 가능하도록 설정 파일을 만듭니다. 게임 상태 관리(RUNNING, PAUSED, STOPPED)를 포함합니다.",
        "testStrategy": "빈 게임 월드에서 40+ FPS가 안정적으로 유지되는지 성능 테스트를 실행합니다. 게임 루프의 시간 정확성과 렌더링 시스템의 기본 동작을 검증하는 통합 테스트를 작성합니다. 유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "pygame 기반 게임 루프 구현",
            "description": "pygame.time.Clock을 사용한 고정 시간 간격 게임 루프를 구현하고 FPS 제어 기능을 추가합니다.",
            "dependencies": [],
            "details": "src/core/game_loop.py에서 GameLoop 클래스를 구현합니다. pygame.time.Clock()을 사용하여 60fps/40fps 고정 시간 간격을 관리하고, delta time 계산을 통해 프레임률 독립적인 게임 로직을 지원합니다. 게임 루프의 초기화, 업데이트, 종료 메서드를 구현하며, FPS 모니터링 기능을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "고정 시간 간격 처리 시스템",
            "description": "프레임률 독립적인 시간 기반 게임 로직을 처리하는 시스템을 구현합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "delta time을 활용한 시간 기반 계산 유틸리티를 구현합니다. 고정 시간 간격(fixed timestep)과 가변 시간 간격(variable timestep) 처리 옵션을 제공하며, 시간 스케일링 기능(일시정지, 슬로우모션 등)을 지원합니다. TimeManager 클래스로 게임 내 시간 흐름을 중앙 관리합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "RenderSystem과 스프라이트 렌더링 구현",
            "description": "pygame.sprite.Group을 활용한 기본 렌더링 시스템과 스프라이트 관리 기능을 구현합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "src/systems/render_system.py에서 RenderSystem 클래스를 구현합니다. pygame.sprite.Group을 사용한 스프라이트 그룹 관리, 렌더링 레이어 시스템, 화면 클리어 및 더블 버퍼링 처리를 포함합니다. 스프라이트 정렬(z-order), 카메라 변환, 기본적인 렌더링 최적화 기능을 구현합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "게임 상태 관리 및 설정 파일 처리",
            "description": "게임 상태(RUNNING, PAUSED, STOPPED) 관리 시스템과 외부 설정 파일 처리를 구현합니다.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "GameStateManager 클래스로 게임 상태 전환을 관리하고, JSON 기반 설정 파일(config.json)에서 화면 해상도, FPS, 키 바인딩 등을 로드합니다. 런타임 중 설정 변경 기능과 설정 저장 기능을 구현하며, 상태별 렌더링 및 입력 처리 분기를 지원합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 5,
            "title": "고정 시간 간격 처리 시스템이 테스트",
            "description": "고정 시간 간격 처리 시스템이 60fps/40fps 모두 동일한 스팩으로 동작하는지 유닛 테스트를 진행합니다.",
            "details": "delta time 계산이 정확한지 테스트 케이스를 작성합니다. 테스트 케이스는 60fps, 40fps 모두 동일한 스팩으로 동작하는지 테스트합니다.",
            "status": "pending",
            "dependencies": [
              "2.2"
            ],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "충돌감지 및 물리 시스템 구현",
        "description": "브루트포스 방식의 충돌감지 시스템과 기본 물리 계산 시스템을 구현합니다.",
        "details": "src/systems/collision_system.py에서 AABB(Axis-Aligned Bounding Box) 기반 충돌감지를 구현합니다. CollisionComponent에 hitbox 크기와 collision mask를 정의합니다. PhysicsSystem에서 기본 벡터 연산을 통한 이동과 속도 계산을 구현합니다. 초기에는 O(n²) 브루트포스 방식으로 구현하되, 추후 Spatial Partitioning으로 교체 가능하도록 인터페이스를 추상화합니다.",
        "testStrategy": "다양한 충돌 시나리오(정면 충돌, 모서리 충돌, 겹침)에 대한 단위 테스트를 작성합니다. 물리 계산의 정확성과 성능을 검증하는 테스트를 포함합니다.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "AABB 충돌감지 알고리즘 구현",
            "description": "Axis-Aligned Bounding Box 기반의 기본 충돌감지 로직을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/collision_system.py에서 CollisionSystem 클래스를 생성하고 AABB 충돌감지 함수를 구현합니다. 두 객체의 좌표와 크기를 비교하여 겹침을 판단하는 check_aabb_collision() 메서드를 작성합니다. x축과 y축 각각에서 겹침 여부를 확인하는 로직을 포함합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "CollisionComponent 설계 및 구현",
            "description": "충돌감지에 필요한 CollisionComponent를 설계하고 구현합니다.",
            "dependencies": [],
            "details": "src/components/collision_component.py에서 CollisionComponent 클래스를 정의합니다. hitbox 크기(width, height), collision mask(적 타입별 충돌 여부), collision layer(충돌 계층) 속성을 포함합니다. 컴포넌트 초기화 시 기본값 설정과 유효성 검증 로직을 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "PhysicsSystem 벡터 연산 구현",
            "description": "기본 물리 계산을 위한 PhysicsSystem의 벡터 연산을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/physics_system.py에서 PhysicsSystem 클래스를 생성합니다. 속도 벡터 계산, 위치 업데이트, 기본 중력 적용 등의 메서드를 구현합니다. numpy를 활용한 2D 벡터 연산 함수들(덧셈, 곱셈, 정규화)을 포함하며, 프레임 독립적인 시간 기반 계산을 적용합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "브루트포스 충돌 처리 시스템 구현",
            "description": "O(n²) 브루트포스 방식의 충돌 처리 메인 로직을 구현합니다.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "CollisionSystem에서 모든 엔티티 쌍에 대해 충돌을 검사하는 process_collisions() 메서드를 구현합니다. 충돌 발생 시 적절한 반응(피해 적용, 아이템 획득 등)을 처리하는 로직을 포함합니다. 성능 모니터링을 위한 충돌 검사 횟수 카운터를 추가합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 5,
            "title": "확장성을 위한 인터페이스 추상화",
            "description": "추후 Spatial Partitioning 등으로 교체 가능한 추상 인터페이스를 구현합니다.",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "src/systems/collision_system.py에서 ICollisionDetector 추상 클래스를 정의하고, BruteForceCollisionDetector를 구체 구현체로 만듭니다. 충돌감지 알고리즘을 쉽게 교체할 수 있도록 Strategy 패턴을 적용합니다. 향후 QuadTree, SpatialHash 등의 최적화된 알고리즘 교체를 위한 인터페이스를 설계합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          }
        ]
      },
      {
        "id": 4,
        "title": "JSON 데이터 로딩 및 관리 시스템",
        "description": "게임 데이터(아이템, 적, 보스, 밸런스)를 JSON 파일로 관리하는 시스템을 구현합니다.",
        "details": "src/data/ 디렉토리에 DataLoader 클래스를 구현하여 items.json, enemies.json, bosses.json, game_balance.json을 로딩합니다. 각 데이터 타입별로 Pydantic 모델을 정의하여 타입 안전성을 보장합니다. 데이터 유효성 검증과 기본값 설정 로직을 포함합니다. 런타임 중 데이터 리로딩 기능을 지원하여 밸런싱 조정을 용이하게 만듭니다.",
        "testStrategy": "JSON 스키마 유효성 검증 테스트와 데이터 로딩 실패 시 적절한 에러 처리가 되는지 테스트합니다. 잘못된 JSON 형식이나 누락된 필드에 대한 예외 처리를 검증합니다.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "DataLoader 클래스 구현",
            "description": "JSON 파일을 로딩하고 관리하는 핵심 DataLoader 클래스를 구현합니다.",
            "dependencies": [],
            "details": "src/data/loader.py에 DataLoader 클래스를 구현하여 items.json, enemies.json, bosses.json, game_balance.json 파일을 비동기적으로 로딩하는 기능을 만듭니다. 파일 경로 관리, 캐싱 메커니즘, 에러 처리 로직을 포함하며, 싱글톤 패턴을 적용하여 데이터 로더의 유일성을 보장합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "Pydantic 모델 정의",
            "description": "각 데이터 타입별 Pydantic 모델을 정의하여 타입 안전성을 보장합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "src/data/models.py에 Item, Enemy, Boss, GameBalance 등의 Pydantic 모델을 정의합니다. 각 모델에는 필수 필드 검증, 기본값 설정, 타입 변환 로직을 포함하며, Field validator를 사용하여 데이터 범위와 형식을 검증하는 기능을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "JSON 스키마 검증 시스템",
            "description": "로딩된 JSON 데이터의 유효성을 검증하는 스키마 검증 시스템을 구현합니다.",
            "dependencies": [
              "4.2"
            ],
            "details": "src/data/validator.py에서 JSON 스키마 검증 시스템을 구현합니다. 잘못된 JSON 형식, 누락된 필드, 잘못된 데이터 타입에 대한 명확한 에러 메시지를 제공하며, 검증 실패 시 기본값으로 대체하거나 안전하게 종료하는 복구 전략을 포함합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "런타임 데이터 리로딩 기능 구현",
            "description": "게임 실행 중 데이터 파일을 다시 로딩할 수 있는 런타임 리로딩 기능을 구현합니다.",
            "dependencies": [
              "4.3"
            ],
            "details": "src/data/reload_manager.py에서 파일 변경 감지와 런타임 리로딩 기능을 구현합니다. watchdog 라이브러리를 사용한 파일 시스템 모니터링, 리로딩 시 게임 상태 보존, 리로딩 실패 시 이전 데이터 복구 메커니즘을 포함하며, 개발 모드에서만 활성화되는 안전 장치를 구현합니다.",
            "status": "deferred",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "플레이어 마우스 이동 시스템",
        "description": "마우스 커서를 향해 플레이어가 바라보지만 플레이어는 중앙에 고정되고 맵이 플레이어 반대 방향으로 움직이는 카메라 시스템을 구현합니다.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "high",
        "details": "src/systems/movement_system.py에서 pygame.mouse.get_pos()를 사용해 마우스 위치를 추적하고 플레이어가 마우스 방향을 바라보도록 합니다. 플레이어는 화면 중앙에 고정되고, CameraSystem을 통해 맵이 플레이어 이동의 역방향으로 움직입니다. PlayerMovementComponent에 이동 방향과 속도를 저장하고, MapSystem에서 배경과 오브젝트들을 카메라 오프셋에 따라 렌더링합니다. 맵 움직임을 시각적으로 확인할 수 있는 타일 패턴이나 그리드 배경을 구현합니다.",
        "testStrategy": "마우스 위치 변화에 따른 플레이어 회전 방향이 정확한지 테스트합니다. 카메라 이동에 따른 맵 오브젝트 위치 변화와 시각적 피드백이 올바르게 작동하는지 검증합니다. 맵 경계 처리와 카메라 제한 범위에 대한 테스트를 포함합니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "마우스 위치 추적 및 플레이어 회전 구현",
            "description": "pygame을 사용해 마우스 위치를 실시간으로 추적하고, 플레이어가 마우스 방향을 바라보도록 회전시키는 시스템을 구현합니다.",
            "status": "pending",
            "dependencies": [],
            "details": "pygame.mouse.get_pos()를 사용하여 마우스 좌표를 획득하고, 플레이어 위치(화면 중앙)와의 방향각을 계산합니다. math.atan2를 활용한 각도 계산과 플레이어 스프라이트 회전 로직을 src/systems/movement_system.py에 구현합니다. 플레이어 회전 시 부드러운 회전 전환을 위한 각속도 제한을 적용합니다. 추가적으로 플레이어 위치를 획득하는 부분과 계산하는 부분을 분리하여 유닛테스트를 만들기 유용하게 작성합니다.",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "카메라 시스템과 맵 역방향 이동 구현",
            "description": "플레이어를 화면 중앙에 고정하고 맵이 플레이어 이동의 역방향으로 움직이는 카메라 시스템을 구현합니다.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "CameraSystem 클래스를 생성하여 카메라 오프셋을 관리합니다. 플레이어는 화면 중앙 고정 위치에 렌더링하고, 플레이어의 이동 입력에 따라 월드 좌표계를 역방향으로 이동시킵니다. PlayerMovementComponent에 이동 속도와 방향을 저장하여 카메라 오프셋 계산에 활용합니다. 모든 게임 오브젝트의 렌더링 시 카메라 오프셋을 적용하는 시스템을 구현합니다. UI부분과 객체 부분이 분리되어 유닛테스트가 쉽도록 작성합니다.",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "시각적 맵 시스템 및 경계 처리",
            "description": "맵 움직임을 확인할 수 있는 시각적 배경과 카메라 경계 처리 시스템을 구현합니다.",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "타일 기반 배경 시스템이나 그리드 패턴을 구현하여 카메라 이동을 시각적으로 확인할 수 있게 합니다. 맵 경계를 설정하고 카메라가 맵 밖으로 나가지 않도록 제한하는 boundary checking을 구현합니다. 배경 타일의 무한 스크롤링 또는 맵 크기 제한 시스템을 추가하여 자연스러운 맵 탐색 경험을 제공합니다. 코드 디자인이 유닛테스트 하기 쉽도록, 위치가 주어질 때 어떤 타일을 제공해야하는 지에 대한 정보를 계산하는 함수(혹은 객체)를 분리해서 작성하여 타일 로드와 어떤 타일을 로드해야하는지 계산하는 로직을 분리합니다.",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          }
        ]
      },
      {
        "id": 6,
        "title": "자동 공격 및 투사체 시스템",
        "description": "시간 기반으로 가장 가까운 적을 자동 공격하는 시스템과 투사체를 구현합니다.",
        "details": "src/systems/weapon_system.py에서 WeaponComponent를 정의하여 공격 속도, 사거리, 데미지를 관리합니다. 가장 가까운 적을 찾기 위한 거리 계산 함수를 구현하고, ProjectileComponent로 투사체의 방향, 속도, 수명을 관리합니다. ProjectileSystem에서 투사체 이동과 충돌 처리를 담당하며, 화면 밖으로 나간 투사체는 자동으로 제거합니다.",
        "testStrategy": "자동 타겟팅이 정확히 가장 가까운 적을 선택하는지 테스트합니다. 투사체의 궤적과 충돌 감지, 수명 관리가 정상 동작하는지 검증합니다.",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "WeaponComponent와 자동 타겟팅 시스템 구현",
            "description": "WeaponComponent 클래스를 정의하고 가장 가까운 적을 찾는 자동 타겟팅 로직을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/weapon_system.py에서 WeaponComponent 클래스를 만들어 공격 속도(attack_speed), 사거리(range), 데미지(damage) 속성을 관리합니다. WeaponSystem 클래스에서 거리 계산 함수를 구현하여 지정된 사거리 내의 적 엔티티 중 가장 가까운 대상을 선택하는 자동 타겟팅 로직을 만듭니다. 시간 기반 쿨다운 시스템을 구현하여 attack_speed에 따라 공격 주기를 제어합니다. WeaponComponent.projectile_type 에 따라 각자 다른 방식으로 동작을 하도록 하며, State 패턴을 사용해서 WeaponComponent 가 projectile_type의 타입과 구현 내용을 몰라도 동작할 수 있도록 합니다. 처음 구현은 basic 만하여 동작하는지 확인합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "ProjectileComponent와 투사체 물리 처리",
            "description": "투사체의 이동과 물리적 특성을 관리하는 ProjectileComponent와 물리 시스템을 구현합니다.",
            "dependencies": [
              "6.1"
            ],
            "details": "src/components/projectile_component.py에서 ProjectileComponent 클래스를 정의하여 투사체의 방향(direction), 속도(velocity), 수명(lifetime), 데미지(damage) 등을 관리합니다. ProjectileSystem에서 매 프레임마다 투사체의 위치를 업데이트하는 물리 처리 로직을 구현합니다. 투사체 생성 시 타겟 방향으로의 벡터 계산과 정규화를 통해 일정한 속도로 이동하도록 설정합니다. ProjectileSystem에서 개별 투사체의 구현을 알지 않아도 되도록, 코드 구조를 설계하여 작성 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "투사체 충돌 및 수명 관리",
            "description": "투사체와 적의 충돌 감지, 수명 관리, 그리고 충돌 시 효과 처리를 구현합니다.",
            "dependencies": [
              "6.2"
            ],
            "details": "ProjectileSystem에서 pygame.sprite.spritecollide를 활용한 투사체-적 충돌 감지를 구현합니다. 충돌 발생 시 적에게 데미지를 적용하고 투사체를 제거하는 로직을 만듭니다. 투사체 수명(lifetime)을 매 프레임마다 감소시켜 시간이 지나면 자동으로 제거되도록 구현합니다. 화면 경계를 벗어난 투사체도 자동 제거하여 메모리 누수를 방지합니다. 또한 해당 부분을 객체화 하여 효과적으로 유닛테스트를 할수 있도록 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "거리 계산 및 최적화 로직",
            "description": "효율적인 거리 계산과 타겟팅 성능 최적화를 구현합니다.",
            "dependencies": [
              "6.1"
            ],
            "details": "numpy를 활용한 벡터화된 거리 계산 함수를 구현하여 다수의 적에 대한 거리 계산을 최적화합니다. 공간 분할(spatial partitioning) 기법을 적용하여 사거리 내의 적만 효율적으로 필터링하는 시스템을 만듭니다. 매 프레임마다 전체 적을 검색하는 대신 일정 간격(예: 0.1초)으로 타겟을 재선택하여 성능을 향상시킵니다. 거리 계산 시 제곱근 연산을 피하고 거리의 제곱값으로 비교하여 연산 비용을 절약합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          }
        ]
      },
      {
        "id": 7,
        "title": "기본 적 AI 및 스포너 시스템",
        "description": "플레이어를 추격하고 공격하는 기본 적 AI와 적 생성 시스템을 구현합니다.",
        "details": "src/systems/ai_system.py에서 EnemyAIComponent를 정의하여 AI 상태(PATROL, CHASE, ATTACK)를 관리합니다. 적과 플레이어 사이의 거리에 따라 행동을 결정하는 상태 기반 AI를 구현합니다. EnemySpawner 클래스로 일정 시간마다 화면 가장자리에서 적을 생성하며, 시간 경과에 따라 난이도가 증가하도록 적 능력치를 조정합니다. 적의 체력, 공격력, 이동 속도를 JSON 데이터로 관리합니다.",
        "testStrategy": "AI 상태 전환 로직이 거리와 조건에 따라 정확히 동작하는지 테스트합니다. 적 스포너의 시간 기반 생성과 난이도 조정이 의도대로 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EnemyAIComponent와 AI 상태 구조 설계",
            "description": "AI 상태(PATROL, CHASE, ATTACK)를 관리하는 EnemyAIComponent 클래스를 설계하고 구현합니다.",
            "dependencies": [],
            "details": "src/systems/ai_system.py에 EnemyAIComponent 클래스를 생성하고, AI_STATE 열거형으로 PATROL, CHASE, ATTACK 상태를 정의합니다. 각 상태별 행동 로직을 위한 메서드 구조를 설계하고, 상태 전환을 위한 조건 검사 시스템을 구현합니다. 적의 현재 타겟, 상태, 이동 방향 등을 저장하는 데이터 구조를 만듭니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "거리 기반 AI 상태 전환 로직 구현",
            "description": "플레이어와의 거리에 따라 AI 상태가 자동으로 전환되는 로직을 구현합니다.",
            "dependencies": [
              "7.1"
            ],
            "details": "플레이어와 적 사이의 거리를 계산하는 함수를 구현하고, 거리에 따른 상태 전환 임계값(순찰 범위, 추격 시작 거리, 공격 범위)을 설정합니다. update_ai_state() 메서드에서 현재 거리를 확인하여 적절한 상태로 전환하는 로직을 구현합니다. 각 상태별 행동(순찰 이동, 플레이어 추격, 공격 실행)을 구현합니다. 상태를 변경하는 조건 계산과 계산 로직, 상태 변경 로직을 분리하여 유닛테스트를 할수 있도록 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "EnemySpawner와 시간 기반 생성 시스템 구현",
            "description": "일정 시간마다 화면 가장자리에서 적을 생성하는 EnemySpawner 시스템을 구현합니다.",
            "dependencies": [
              "7.1"
            ],
            "details": "EnemySpawner 클래스를 생성하고, 스폰 타이머와 스폰 간격을 관리하는 시스템을 구현합니다. 화면 가장자리의 랜덤한 위치에서 적을 생성하는 로직을 만들고, 화면 밖 영역에서 생성되도록 스폰 포인트를 계산합니다. 동시에 존재할 수 있는 최대 적 수 제한을 구현합니다. 동시에 적을 생성 할 수 있는지의 여부 판단 로직을 분리, 스폰 타임 측정하는 로직 분리 등 판단을 계산하는 로직과 실제 변경하는 로직을 분리하여 유닛테스트 하기 유용하도록 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "시간 기반 난이도 조정 메커니즘 구현",
            "description": "게임 진행 시간에 따라 적의 능력치와 스폰 빈도가 증가하는 난이도 조정 시스템을 구현합니다.",
            "dependencies": [
              "7.3"
            ],
            "details": "게임 경과 시간을 추적하는 시스템을 구현하고, 시간에 따른 난이도 계수를 계산하는 함수를 만듭니다. 적 생성 시 현재 난이도에 따라 체력, 공격력, 이동 속도를 조정하는 로직을 구현합니다. 스폰 간격도 시간이 지날수록 점차 단축되도록 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "JSON 기반 적 데이터 관리 시스템 구현",
            "description": "적의 기본 능력치와 AI 설정을 JSON 파일로 관리하는 데이터 시스템을 구현합니다.",
            "dependencies": [
              "7.2"
            ],
            "details": "data/enemies.json 파일을 생성하여 적 타입별 기본 스탯(체력, 공격력, 이동 속도, AI 임계값 등)을 정의합니다. JSON 데이터를 로드하고 적 생성 시 해당 데이터를 적용하는 DataManager 클래스를 구현합니다. 적 타입별로 다른 AI 행동 패턴을 설정할 수 있도록 확장 가능한 구조를 만듭니다. 팩토리 패턴을 사용해서 시간 대 별로 스폰 정책을 따로 설정할 수 있고, 개별의 스폰 정책에 대해서 스폰 시스템이 몰라도 되도록 추상화 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          }
        ]
      },
      {
        "id": 8,
        "title": "경험치 및 레벨업 시스템",
        "description": "적 처치 시 경험치 획득과 레벨업 메커니즘을 구현합니다.",
        "details": "src/systems/experience_system.py에서 ExperienceComponent를 정의하여 현재 경험치, 레벨, 필요 경험치를 관리합니다. 적 처치 시 경험치를 부여하는 이벤트 시스템을 구현하고, 레벨업 시 필요 경험치를 증가시키는 공식을 적용합니다. 레벨업 시 LEVEL_UP 이벤트를 발생시켜 다른 시스템에서 반응할 수 있도록 합니다. UI에서 경험치 바를 표시하기 위한 렌더링 컴포넌트를 구현합니다.",
        "testStrategy": "경험치 계산과 레벨업 조건이 정확한지 테스트합니다. 레벨업 이벤트가 적절히 발생하고 다른 시스템에 전달되는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ExperienceComponent와 경험치 관리 구조 구현",
            "description": "경험치, 레벨, 필요 경험치를 관리하는 ExperienceComponent와 기본 데이터 구조를 구현합니다.",
            "dependencies": [],
            "details": "src/systems/experience_system.py에 ExperienceComponent 클래스를 정의하여 current_exp, level, exp_to_next_level 속성을 관리합니다. 초기값 설정과 데이터 검증 로직을 포함하며, 경험치 관련 계산을 위한 헬퍼 메서드들을 구현합니다.\n<info added on 2025-08-09T06:05:55.142Z>\n기존 헬퍼 메서드 방식 대신 Strategy 패턴을 도입하여 ExperienceCalculationStrategy 추상 클래스를 생성하고 DefaultExperienceStrategy, LinearExperienceStrategy, ExponentialExperienceStrategy 등 구체적인 전략 클래스들을 구현합니다. ExperienceComponent에서 strategy 속성을 추가하여 런타임에 계산 전략을 교체할 수 있도록 합니다. 또한 IExperiencePolicy 인터페이스를 정의하여 레벨업 조건, 경험치 배율, 보상 정책 등을 추상화하고 정책 변경 시 코드 수정 없이 설정 파일이나 의존성 주입을 통해 정책을 교체할 수 있는 구조로 설계합니다.\n</info added on 2025-08-09T06:05:55.142Z>",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 2,
            "title": "이벤트 기반 경험치 부여 시스템 구현",
            "description": "적 처치 시 경험치를 부여하는 이벤트 시스템과 경험치 획득 로직을 구현합니다.",
            "dependencies": [
              "8.1"
            ],
            "details": "ENEMY_DEFEATED 이벤트를 수신하여 적 유형별 경험치를 부여하는 ExperienceSystem을 구현합니다. 이벤트 리스너를 등록하고, 적 처치 시 경험치 계산 및 ExperienceComponent 업데이트 로직을 작성합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 3,
            "title": "레벨업 공식과 LEVEL_UP 이벤트 처리 구현",
            "description": "레벨업 조건 확인, 필요 경험치 증가 공식, LEVEL_UP 이벤트 발생 로직을 구현합니다.",
            "dependencies": [
              "8.2"
            ],
            "details": "경험치가 필요 경험치에 도달했을 때 레벨업을 처리하는 로직을 구현합니다. 레벨별 필요 경험치 증가 공식(예: level * 100)을 적용하고, 레벨업 시 LEVEL_UP 이벤트를 발생시켜 다른 시스템에서 반응할 수 있도록 합니다.",
            "status": "pending",
            "testStrategy": "유닛테스트 구현을 위한 인터뷰를 진행하고(@.claude/commands/interview-for-unit-test.md), 인터뷰에서 추출한 테스트 시나리오를 바탕으로 테스트 케이스를 작성합니다. 마지막으로 앞서 작성한 기능이 정상적으로 작동하는지 테스트 하며 테스트가 통과할 때까지 반복합니다. 단 같은 오류가 3번 이상 반복되면, 잠시 멈추고 사용자와 소통하며 오류를 고쳐 나가세요."
          },
          {
            "id": 4,
            "title": "UI 렌더링용 경험치 컴포넌트 구현",
            "description": "경험치 바 표시를 위한 UI 렌더링 컴포넌트와 시각적 피드백을 구현합니다.",
            "dependencies": [
              "8.3"
            ],
            "details": "경험치 정보를 UI에 표시하기 위한 ExperienceRenderer를 구현합니다. 현재 경험치/최대 경험치 비율을 계산하여 프로그레스 바로 표시하고, 레벨업 시 시각적 이펙트와 경험치 획득 시 숫자 표시 효과를 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "JSON 기반 아이템 시스템 및 인벤토리",
        "description": "JSON 데이터 기반 아이템과 6슬롯 인벤토리, 레벨업 시 아이템 선택 UI를 구현합니다.",
        "details": "data/items.json에서 아이템 데이터(이름, 설명, 효과, 아이콘)를 정의합니다. src/systems/inventory_system.py에서 6슬롯 제한 인벤토리를 구현하고, ItemComponent로 아이템 효과를 관리합니다. 레벨업 시 2개 아이템 중 1개를 선택하는 UI를 구현하며, 아이템 효과를 즉시 플레이어에게 적용하는 시스템을 만듭니다. 아이템 효과는 가산 방식으로 중첩되도록 구현합니다.",
        "testStrategy": "아이템 데이터 로딩과 인벤토리 관리 로직을 테스트합니다. 아이템 효과 적용과 중첩 계산이 정확한지 검증하며, UI 상호작용이 올바르게 작동하는지 테스트합니다.",
        "priority": "high",
        "dependencies": [
          4,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "JSON 아이템 데이터 구조 설계 및 로딩 시스템 구현",
            "description": "data/items.json 파일 생성 및 ItemData 모델 정의, DataLoader를 통한 아이템 데이터 로딩 구현",
            "dependencies": [],
            "details": "data/items.json에서 아이템 속성(이름, 설명, 효과 타입, 효과 값, 아이콘 경로)을 정의합니다. Pydantic ItemData 모델로 타입 안전성을 보장하고, DataLoader 클래스에 load_items() 메서드를 추가하여 JSON 파일을 로딩합니다. 아이템 효과는 ATTACK_SPEED, DAMAGE, HEALTH 등 열거형으로 관리합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "6슬롯 인벤토리 관리 시스템 구현",
            "description": "InventoryComponent 및 InventorySystem 구현으로 6개 슬롯 제한 아이템 보관 시스템 개발",
            "dependencies": [
              "9.1"
            ],
            "details": "src/systems/inventory_system.py에서 InventoryComponent(최대 6개 슬롯)와 InventorySystem을 구현합니다. add_item(), remove_item(), is_full() 메서드로 인벤토리 관리를 담당하고, 아이템 중복 시 수량 증가 로직을 구현합니다. 인벤토리 상태 변화 시 INVENTORY_CHANGED 이벤트를 발생시킵니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "ItemComponent 및 아이템 효과 적용 메커니즘 구현",
            "description": "ItemComponent 정의 및 플레이어 스탯에 아이템 효과를 적용하는 시스템 구현",
            "dependencies": [
              "9.2"
            ],
            "details": "src/components/item_component.py에서 ItemComponent(아이템 ID, 수량, 효과 목록)를 정의합니다. ItemEffectSystem에서 인벤토리 아이템들의 효과를 플레이어 스탯에 가산 방식으로 적용하는 calculate_total_effects() 메서드를 구현합니다. 실시간으로 아이템 효과가 플레이어에게 반영되도록 합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "레벨업 시 아이템 선택 UI 시스템 구현",
            "description": "레벨업 이벤트 감지 및 2개 아이템 중 1개 선택하는 모달 UI 구현",
            "dependencies": [
              "9.3"
            ],
            "details": "src/ui/item_selection_ui.py에서 ItemSelectionUI 클래스를 구현합니다. LEVEL_UP 이벤트 수신 시 랜덤한 2개 아이템을 제시하고, 마우스 클릭으로 선택할 수 있는 모달 창을 표시합니다. 선택된 아이템은 즉시 인벤토리에 추가되고 효과가 적용됩니다. ESC 키로 선택을 취소할 수 있는 기능도 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "아이템 효과 중첩 계산 및 최적화 로직 구현",
            "description": "동일 아이템의 효과 중첩 계산과 성능 최적화를 위한 캐싱 시스템 구현",
            "dependencies": [
              "9.4"
            ],
            "details": "아이템 효과 중첩을 위한 EffectCalculator 클래스를 구현합니다. 동일 아이템 여러 개 보유 시 가산 방식으로 효과를 누적하고, 계산 결과를 캐싱하여 성능을 최적화합니다. 아이템 변경 시에만 효과를 재계산하도록 하고, 효과별 최대 한계치 설정 기능을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "룰 엔진 기반 시너지 시스템",
        "description": "특정 아이템 조합 시 추가 효과가 발생하는 룰 엔진 기반 시너지 시스템을 구현합니다.",
        "details": "src/systems/synergy_system.py에서 룰 엔진을 구현하여 아이템 조합 패턴을 검사합니다. data/synergies.json에서 시너지 규칙(조합 아이템 목록, 추가 효과)을 정의합니다. 인벤토리 변경 시마다 활성 시너지를 재계산하고, 시너지 효과를 플레이어 스탯에 적용합니다. 축구화+축구공=15% 데미지 증가 등의 기본 시너지를 구현하며, 시너지 효과에 최대치 제한(데미지 300%, 공격속도 200%)을 설정합니다.",
        "testStrategy": "다양한 아이템 조합에 대한 시너지 인식과 효과 적용을 테스트합니다. 시너지 규칙 변경 시 실시간 반영과 최대치 제한이 정상 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "룰 엔진 아키텍처 설계 및 기본 구조 구현",
            "description": "시너지 시스템의 핵심이 되는 룰 엔진의 기본 아키텍처를 설계하고 구현합니다.",
            "dependencies": [],
            "details": "src/systems/synergy_system.py에 SynergyRuleEngine 클래스를 생성하고, 규칙 로딩, 패턴 매칭, 효과 계산을 담당하는 기본 인터페이스를 정의합니다. Rule, Pattern, Effect 등의 기본 데이터 클래스들을 구현하여 시너지 규칙의 구조를 명확히 합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "시너지 패턴 매칭 알고리즘 구현",
            "description": "아이템 조합을 분석하여 시너지 패턴을 찾는 핵심 알고리즘을 구현합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "PatternMatcher 클래스를 구현하여 현재 인벤토리의 아이템들이 정의된 시너지 패턴과 일치하는지 효율적으로 검사합니다. 여러 시너지가 동시에 활성화될 수 있는 경우와 우선순위 처리 로직을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "JSON 기반 시너지 규칙 관리 시스템",
            "description": "data/synergies.json 파일을 통해 시너지 규칙을 관리하는 시스템을 구현합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "축구화+축구공=15% 데미지 증가 등의 기본 시너지 규칙을 JSON 형태로 정의하고, 런타임에 이를 로딩하여 룰 엔진에 적용하는 SynergyRuleLoader 클래스를 구현합니다. 규칙 검증 및 오류 처리 로직도 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "실시간 시너지 계산 및 효과 적용",
            "description": "인벤토리 변경 시마다 활성 시너지를 실시간으로 계산하고 플레이어 스탯에 적용합니다.",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "SynergyCalculator 클래스를 구현하여 인벤토리 변경 이벤트를 감지하고, 활성화된 시너지 효과를 플레이어의 스탯에 실시간으로 적용/해제합니다. 시너지 효과의 누적 계산과 스탯 수정자 시스템과의 연동을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "최대치 제한 및 밸런싱 시스템",
            "description": "시너지 효과에 최대치 제한을 적용하여 게임 밸런스를 유지합니다.",
            "dependencies": [
              "10.4"
            ],
            "details": "데미지 300%, 공격속도 200% 등의 시너지 효과 최대치 제한을 설정하고, BalancingManager 클래스를 통해 이를 관리합니다. 시너지 효과가 설정된 최대치를 넘지 않도록 하는 캡핑 로직과 경고 시스템을 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "시너지 시스템 성능 최적화",
            "description": "룰 엔진의 패턴 매칭과 효과 계산 성능을 최적화합니다.",
            "dependencies": [
              "10.4",
              "10.5"
            ],
            "details": "시너지 패턴 매칭 알고리즘을 최적화하여 대량의 아이템과 복잡한 시너지 규칙에서도 60fps를 유지하도록 합니다. 캐싱 메커니즘, 지연 계산, 인덱싱 등의 기법을 적용하여 성능을 개선하고, 프로파일링을 통해 병목점을 식별하고 해결합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "교장선생님 보스 시스템",
        "description": "1분 30초마다 등장하는 교장선생님 보스와 훈화 말씀 패턴을 구현합니다.",
        "details": "src/systems/boss_system.py에서 BossSpawner를 구현하여 90초마다 교장선생님을 소환합니다. BossAI 클래스에서 훈화 말씀 알파(스턴) → 베타(광역 공격) 패턴을 구현합니다. 보스 공격 전 시각적 예고(경고 표시)와 디버프 적용 시스템을 만듭니다. 미션 시스템으로 디버프 해제 조건(특정 적 처치, 시간 경과 등)을 구현하며, 보스 처치 시 추가 보상을 제공합니다.",
        "testStrategy": "보스 등장 타이밍과 패턴 실행이 정확한지 테스트합니다. 디버프 적용과 미션 시스템 연동, 보스 AI 상태 전환이 의도대로 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "BossSpawner와 타이밍 관리 시스템 구현",
            "description": "90초마다 교장선생님 보스를 자동 소환하는 BossSpawner 클래스와 타이밍 관리 시스템을 구현합니다.",
            "dependencies": [],
            "details": "src/systems/boss_system.py에서 BossSpawner 클래스를 구현하여 pygame.time.get_ticks()를 사용한 정확한 90초 간격 체크를 수행합니다. 보스 활성화 상태를 관리하고, 보스가 이미 존재할 때는 새로 소환하지 않는 로직을 포함합니다. 게임 일시정지 시에도 타이밍이 정확히 유지되도록 pause-aware 타이머를 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "BossAI 패턴 시스템 (훈화 알파/베타) 구현",
            "description": "교장선생님의 훈화 말씀 패턴(알파: 스턴, 베타: 광역 공격)을 관리하는 BossAI 클래스를 구현합니다.",
            "dependencies": [
              "11.1"
            ],
            "details": "BossAI 클래스에서 상태 머신을 구현하여 IDLE → ALPHA_PATTERN → BETA_PATTERN → COOLDOWN 순서로 상태를 전환합니다. 알파 패턴에서는 전체 플레이어에게 2초간 스턴 디버프를 적용하고, 베타 패턴에서는 광역 데미지를 가하는 공격을 실행합니다. 패턴 간 적절한 쿨다운과 예측 가능한 타이밍을 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "디버프 시스템과 시각적 경고 표시 구현",
            "description": "보스 공격 전 시각적 예고와 디버프 적용/관리 시스템을 구현합니다.",
            "dependencies": [
              "11.2"
            ],
            "details": "src/systems/debuff_system.py에서 DebuffManager 클래스를 구현하여 스턴, 슬로우 등 다양한 디버프를 관리합니다. 보스 공격 3초 전부터 화면에 경고 표시(빨간 테두리, 경고 메시지)를 표시하고, 디버프 아이콘을 UI에 표시합니다. 디버프 지속시간과 효과 강도를 설정 가능하도록 구현합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "미션 기반 디버프 해제 메커니즘 구현",
            "description": "특정 조건을 만족하면 디버프를 해제할 수 있는 미션 시스템을 구현합니다.",
            "dependencies": [
              "11.3"
            ],
            "details": "src/systems/mission_system.py에서 MissionManager 클래스를 구현하여 '특정 적 N마리 처치', '일정 시간 생존', '특정 위치 이동' 등의 미션 조건을 관리합니다. 미션 완료 시 활성 디버프를 제거하고 완료 알림을 표시합니다. 디버프 종류별로 다른 해제 미션을 설정할 수 있도록 data/boss_missions.json을 구성합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "보스 보상 시스템 구현",
            "description": "교장선생님 보스 처치 시 추가 경험치와 특별 아이템을 제공하는 보상 시스템을 구현합니다.",
            "dependencies": [
              "11.2",
              "11.4"
            ],
            "details": "BossRewardSystem 클래스에서 보스 처치 시 일반 적보다 5배 많은 경험치와 희귀 아이템(10% 확률)을 드롭하도록 구현합니다. 보스별 고유 드롭 테이블을 data/boss_rewards.json에 정의하고, 보상 획득 시 특별한 시각적 이펙트와 사운드를 재생합니다. 보스 처치 통계를 기록하여 누적 보상 시스템의 기초를 마련합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "UI 시스템 및 게임 상태 표시",
        "description": "체력바, 경험치바, 아이템 인벤토리 등 핵심 게임 UI를 구현합니다.",
        "details": "src/ui/ 디렉토리에 UISystem을 구현하여 HUD 요소들을 관리합니다. HealthBar, ExperienceBar, InventoryUI, ItemSelectionUI 클래스를 만들어 각각의 UI 요소를 담당하게 합니다. pygame을 사용한 텍스트 렌더링과 프로그레스 바 표시를 구현하며, 레벨업 시 아이템 선택 모달 UI를 만듭니다. 데미지 숫자와 레벨업 이펙트 등 시각적 피드백을 추가합니다.",
        "testStrategy": "UI 요소들이 게임 상태 변화에 따라 정확히 업데이트되는지 테스트합니다. 아이템 선택 UI의 상호작용과 시각적 피드백이 올바르게 작동하는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "UISystem 기본 구조와 HUD 관리 시스템 구현",
            "description": "UI 요소들을 통합 관리하는 UISystem 클래스와 기본 HUD 구조를 구현합니다.",
            "dependencies": [],
            "details": "src/ui/ui_system.py에 UISystem 클래스를 생성하여 모든 UI 요소들을 중앙에서 관리합니다. HUD 레이아웃 설정과 UI 요소들의 위치 계산을 담당하며, 게임 상태 변화에 따른 UI 업데이트 이벤트 처리 시스템을 구현합니다. pygame의 Surface와 Rect를 활용한 기본 렌더링 구조를 설정합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "HealthBar와 ExperienceBar 프로그레스 바 구현",
            "description": "플레이어 체력과 경험치를 표시하는 프로그레스 바 UI를 구현합니다.",
            "dependencies": [
              "12.1"
            ],
            "details": "src/ui/health_bar.py와 experience_bar.py에 각각 HealthBar, ExperienceBar 클래스를 구현합니다. 현재값/최대값 비율에 따른 바 채우기 효과와 색상 변화를 구현하며, 부드러운 애니메이션 효과를 추가합니다. 체력 감소 시 빨간색 효과, 경험치 증가 시 파란색 효과 등 시각적 피드백을 포함합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "InventoryUI와 ItemSelectionUI 모달 시스템 구현",
            "description": "아이템 인벤토리와 레벨업 시 아이템 선택 모달 UI를 구현합니다.",
            "dependencies": [
              "12.1"
            ],
            "details": "src/ui/inventory_ui.py와 item_selection_ui.py를 구현합니다. InventoryUI는 현재 보유 아이템들을 격자 형태로 표시하고, ItemSelectionUI는 레벨업 시 3개 아이템 중 선택할 수 있는 모달을 구현합니다. 마우스 클릭 이벤트 처리와 아이템 아이콘, 설명 텍스트 렌더링을 포함하며, 모달 배경 어둡게 처리와 애니메이션 효과를 추가합니다.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "시각적 피드백과 이펙트 시스템 구현",
            "description": "데미지 숫자, 레벨업 효과 등 게임 내 시각적 피드백 시스템을 구현합니다.",
            "dependencies": [
              "12.2",
              "12.3"
            ],
            "details": "src/ui/visual_effects.py에 VisualEffects 클래스를 구현합니다. 플로팅 데미지 텍스트(위로 올라가며 페이드아웃), 레벨업 시 화면 전체 빛나는 효과, 아이템 획득 시 알림 메시지를 구현합니다. 파티클 시스템을 활용한 이펙트와 타이밍 기반 애니메이션 관리 시스템을 포함하며, 성능 최적화를 위한 이펙트 풀링 시스템을 적용합니다.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-07T18:01:58.038Z",
      "updated": "2025-08-07T20:59:45.987Z",
      "description": "Tasks for master context"
    }
  }
}