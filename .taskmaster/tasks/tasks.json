{
  "master": {
    "tasks": [
      {
        "id": 44,
        "title": "ECS Foundation Layer 핵심 인터페이스 정의",
        "description": "Entity, Component, ComponentRegistry, SystemOrchestrator의 기본 인터페이스와 추상 클래스 정의",
        "details": "Entity 순수 식별자 클래스, Component ABC 기본 클래스(validate, serialize, deserialize 메서드 포함), ComponentRegistry 타입 관리 시스템, SystemOrchestrator 시스템 실행 순서 제어를 구현한다. Component 클래스에는 copy, shallow_copy, merge_from, diff, is_equal_to 등의 유틸리티 메서드를 포함해야 한다. Python 3.13+ 네이티브 타입 힌트를 사용하고 dataclass 기반으로 구현한다.",
        "testStrategy": "Entity 생성 테스트, Component 직렬화/역직렬화 테스트, ComponentRegistry 타입 등록 및 팩토리 기능 테스트, SystemOrchestrator 우선순위 기반 실행 순서 테스트 작성",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Entity 순수 식별자 클래스 구현",
            "description": "게임 객체의 고유 식별자를 관리하는 Entity 클래스를 구현한다",
            "dependencies": [],
            "details": "UUID 기반 또는 incrementing integer 기반의 고유 식별자를 가지는 Entity 클래스를 구현. Python 3.13+ 네이티브 타입 힌트 사용, dataclass 기반 설계. 해시 가능하고 비교 가능하며 직렬화 가능해야 함. thread-safe한 ID 생성 보장.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Component ABC 추상 클래스 기본 구조 정의",
            "description": "모든 컴포넌트가 상속받을 추상 기본 클래스 Component를 정의한다",
            "dependencies": [
              "44.1"
            ],
            "details": "ABC를 사용한 추상 클래스 Component 정의. entity_id 속성과 abstractmethod들의 시그니처 정의. validate, serialize, deserialize 추상 메서드 선언. dataclass 기반으로 설계하고 Python 3.13+ 타입 힌트 적용.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Component 유틸리티 메서드 구현",
            "description": "Component 클래스에 copy, shallow_copy, merge_from, diff, is_equal_to 등의 유틸리티 메서드를 구현한다",
            "dependencies": [
              "44.2"
            ],
            "details": "copy(): 깊은 복사 구현, shallow_copy(): 얕은 복사 구현, merge_from(): 다른 컴포넌트로부터 속성 병합, diff(): 두 컴포넌트 간 차이 반환, is_equal_to(): 동등성 비교. 각 메서드는 타입 안전하고 제네릭하게 동작해야 함.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Component validate, serialize, deserialize 메서드 구현",
            "description": "Component의 데이터 유효성 검증과 직렬화/역직렬화 기능을 구현한다",
            "dependencies": [
              "44.3"
            ],
            "details": "validate(): Pydantic 기반 데이터 유효성 검증, serialize(): dict/JSON 형태로 직렬화, deserialize(): dict에서 컴포넌트 객체로 역직렬화. 타입 안전성과 오류 처리 포함. 순환 참조 방지 및 성능 최적화.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "ComponentRegistry 타입 관리 시스템 구현",
            "description": "컴포넌트 타입별 등록, 팩토리 생성, 타입 검증을 담당하는 ComponentRegistry를 구현한다",
            "dependencies": [
              "44.4"
            ],
            "details": "register_component_type(): 컴포넌트 타입 등록, create_component(): 팩토리 패턴으로 컴포넌트 생성, get_component_types(): 등록된 타입 목록 반환, validate_component_type(): 타입 유효성 검증. 제네릭과 타입 힌트를 활용한 타입 안전성 보장.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "SystemOrchestrator 시스템 실행 순서 제어 구현",
            "description": "시스템들의 우선순위 기반 실행 순서를 관리하는 SystemOrchestrator를 구현한다",
            "dependencies": [
              "44.5"
            ],
            "details": "SystemPriority IntEnum 정의(CRITICAL, HIGH, NORMAL, LOW), register_system(): 시스템 등록 및 우선순위 설정, execute_systems(): 우선순위 순서로 시스템 실행, validate_dependencies(): 시스템 의존성 검증. 토폴로지 정렬을 통한 실행 순서 결정.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 45,
        "title": "SharedEventQueue 3-Layer 이벤트 시스템 구현",
        "description": "Producer-Consumer-Subscriber 패턴 기반의 타입 안전한 이벤트 처리 시스템 구현",
        "details": "ISharedEventQueue<T> 제네릭 인터페이스, IEventTunnelManager 터널 관리, IEventProducer<T>, IEventConsumer<T>, IEventSubscriber<T> 인터페이스 구현. SharedEventQueue는 스레드 안전하고 불변성을 보장해야 한다. Consumer는 이벤트를 큐에서 제거만, Subscriber는 읽기 전용 접근만, Producer는 새 이벤트 생성만 담당한다. 배치 처리 기능(produce_batch, consume_batch)을 포함한다.",
        "testStrategy": "동시성 테스트(100개 이상 동시 이벤트), 불변성 보장 테스트, Producer-Consumer-Subscriber 역할 분리 검증, 메모리 누수 테스트, 성능 테스트(이벤트 처리 1000개/초)",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ISharedEventQueue<T> 제네릭 인터페이스 설계",
            "description": "타입 안전한 이벤트 큐의 기본 인터페이스 정의 및 제네릭 타입 매개변수 설계",
            "dependencies": [],
            "details": "ISharedEventQueue<T> 인터페이스에 큐 생성, 크기 조회, 클리어 등 기본 메서드 정의. 제네릭 타입 T를 사용한 타입 안전성 보장. 스레드 안전성을 위한 락 메커니즘 인터페이스 포함. Python 3.13+ 타입 힌트와 ABC를 활용한 추상 클래스 정의.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "IEventTunnelManager 터널 관리 시스템 설계",
            "description": "이벤트 터널의 생성, 관리, 제거를 담당하는 터널 관리자 인터페이스 구현",
            "dependencies": [
              "45.1"
            ],
            "details": "IEventTunnelManager 인터페이스로 터널 생명주기 관리. 터널 ID 기반 터널 생성/삭제/조회 기능. 터널별 메타데이터 관리 및 상태 추적. 터널 간 이벤트 라우팅 로직 설계. 동시 접근 시 스레드 안전성 보장.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "IEventProducer<T>/IEventConsumer<T>/IEventSubscriber<T> 인터페이스 구현",
            "description": "Producer-Consumer-Subscriber 패턴의 각 역할별 인터페이스 정의 및 역할 분리",
            "dependencies": [
              "45.1"
            ],
            "details": "IEventProducer<T>: produce(event), produce_batch(events) 메서드. IEventConsumer<T>: consume(), consume_batch(count) 메서드로 이벤트 제거. IEventSubscriber<T>: subscribe(), peek(), peek_batch() 메서드로 읽기 전용 접근. 각 인터페이스별 권한 분리 및 타입 안전성 보장.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "SharedEventQueue 스레드 안전성 구현",
            "description": "멀티스레딩 환경에서 안전한 이벤트 큐 구현 및 동시성 제어 메커니즘",
            "dependencies": [
              "45.2",
              "45.3"
            ],
            "details": "threading.Lock, threading.RLock을 사용한 스레드 안전성 보장. Producer-Consumer 패턴에서 race condition 방지. 데드락 방지를 위한 락 순서 정의. concurrent.futures를 활용한 비동기 처리 지원. 성능 최적화를 위한 fine-grained locking 적용.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "불변성 보장 메커니즘 구현",
            "description": "이벤트 데이터의 불변성을 보장하는 메커니즘 및 deep copy 시스템 구현",
            "dependencies": [
              "45.4"
            ],
            "details": "copy.deepcopy를 사용한 이벤트 객체 불변성 보장. Subscriber가 받는 이벤트는 읽기 전용 복사본으로 제공. Producer가 생성한 원본 이벤트 보호. 메모리 효율성을 위한 copy-on-write 메커니즘 고려. frozen dataclass 활용한 불변 이벤트 타입 지원.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "배치 처리 기능 구현",
            "description": "produce_batch, consume_batch 등 대량 이벤트 처리를 위한 배치 기능 구현",
            "dependencies": [
              "45.5"
            ],
            "details": "produce_batch(events: list[T]) 메서드로 여러 이벤트 한번에 생성. consume_batch(count: int) 메서드로 대량 이벤트 소비. 배치 크기 제한 및 메모리 사용량 최적화. 배치 처리 시 원자성(atomicity) 보장. 성능 벤치마크 목표: 1000개/초 이벤트 처리.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "종합 테스트 및 성능 검증",
            "description": "동시성 테스트, 성능 테스트, 메모리 누수 검증 등 종합적인 시스템 검증",
            "dependencies": [
              "45.6"
            ],
            "details": "100개 이상 동시 이벤트 처리 테스트. Producer-Consumer-Subscriber 역할 분리 검증 테스트. 메모리 누수 및 리소스 해제 테스트. 1000개/초 이벤트 처리 성능 목표 달성 검증. 장시간 실행 안정성 테스트 및 스트레스 테스트 수행.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 46,
        "title": "핵심 게임 컴포넌트들 ECS 기반 재구현",
        "description": "기존 컴포넌트들을 새로운 Component 기반 클래스로 재구현하고 IntEnum 성능 패턴 적용",
        "details": "PositionComponent, EnemyComponent, WeaponComponent, ProjectileComponent, RenderComponent, VelocityComponent, CollisionComponent, PlayerComponent, HealthComponent, CameraComponent를 새로운 Component 기반으로 재구현. 모든 게임 값에 IntEnum 사용하고 multi-layer 패턴 적용(value, display_name, 성능 조회). WeaponType, EnemyType, PlayerStatus, GameState, ItemType 등의 Enum 정의 포함.",
        "testStrategy": "각 컴포넌트별 데이터 유효성 검증 테스트, 직렬화/역직렬화 테스트, IntEnum 성능 조회 테스트, 컴포넌트 간 호환성 테스트",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "기본 컴포넌트 구현 (Position/Render/Velocity)",
            "description": "PositionComponent, RenderComponent, VelocityComponent를 새로운 Component 기반 클래스로 재구현",
            "dependencies": [],
            "details": "Component ABC 기반으로 PositionComponent (world_x, world_y 좌표), RenderComponent (sprite, color, layer 정보), VelocityComponent (dx, dy 속도) 구현. dataclass 사용하고 Python 3.13+ 타입 힌트 적용. validate, serialize, deserialize 메서드 포함",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "게임 로직 컴포넌트 구현 (Player/Enemy/Weapon/Projectile)",
            "description": "PlayerComponent, EnemyComponent, WeaponComponent, ProjectileComponent를 Component 기반으로 재구현",
            "dependencies": [
              "46.1"
            ],
            "details": "PlayerComponent (player_status, inventory 관리), EnemyComponent (enemy_type, ai_behavior), WeaponComponent (weapon_type, damage, attack_speed), ProjectileComponent (projectile_type, damage, lifetime) 구현. 각각 적절한 IntEnum 타입 사용",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "상태 관리 컴포넌트 구현 (Health/Collision/Camera)",
            "description": "HealthComponent, CollisionComponent, CameraComponent를 Component 기반으로 재구현",
            "dependencies": [
              "46.1"
            ],
            "details": "HealthComponent (current, maximum, regeneration_rate, player_status), CollisionComponent (collision_type, radius, mask), CameraComponent (target_entity_id, zoom, bounds) 구현. 상태 관리에 필요한 IntEnum 타입 적용",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "게임 IntEnum 타입 정의 (WeaponType/EnemyType/PlayerStatus)",
            "description": "WeaponType, EnemyType, PlayerStatus IntEnum을 다층 패턴으로 정의",
            "dependencies": [],
            "details": "WeaponType (SOCCER_BALL, BASKETBALL, BASEBALL_BAT), EnemyType (BASIC, FAST, TANK), PlayerStatus (ALIVE, INVULNERABLE, DEAD) IntEnum 구현. 각각 display_name 속성과 성능 조회용 배열 포함. 한국어 display_name 적용",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "시스템 상태 IntEnum 타입 정의 (GameState/ItemType)",
            "description": "GameState, ItemType IntEnum을 다층 패턴으로 정의하고 전체 컴포넌트 통합 테스트",
            "dependencies": [
              "46.2",
              "46.3",
              "46.4"
            ],
            "details": "GameState (MENU, PLAYING, PAUSED, GAME_OVER, BOSS_FIGHT), ItemType (SOCCER_SHOES, BASKETBALL_SHOES, RED_GINSENG, MILK) IntEnum 구현. 모든 컴포넌트 간 호환성 테스트 및 직렬화/역직렬화 통합 테스트 수행",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 47,
        "title": "Manager 계층 인터페이스 및 DTO 설계",
        "description": "도메인별 Manager 인터페이스와 DTO 클래스들 정의하여 계층 간 타입 안전한 통신 구조 구축",
        "details": "IEnemyManager, IWeaponManager, IProjectileManager 도메인 인터페이스와 ICoordinateManager, IDifficultyManager, IGameStateManager, IConfigurationManager 인프라 인터페이스 정의. EnemyCreateDTO, WeaponCreateDTO, ProjectileCreateDTO 등 DTO 클래스들과 validate() 메서드 구현. 각 DTO는 ECS Component로 변환 가능한 메서드(to_enemy_component() 등) 포함.",
        "testStrategy": "모든 DTO 유효성 검증 테스트, DTO to Component 변환 테스트, Manager 인터페이스 계약 테스트, 타입 안전성 검증(mypy strict mode)",
        "priority": "high",
        "dependencies": [
          46
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "도메인별 Manager 인터페이스 정의",
            "description": "IEnemyManager, IWeaponManager, IProjectileManager 인터페이스를 ABC 기반으로 정의하고 필수 메서드 시그니처 구현",
            "dependencies": [],
            "details": "각 Manager 인터페이스는 create, update, delete, get 메서드를 포함하며 DTO 기반 파라미터와 타입 힌트를 완벽히 지원. IEnemyManager는 create_enemy(dto: EnemyCreateDTO) -> Entity, IWeaponManager는 create_weapon(dto: WeaponCreateDTO) -> Entity, IProjectileManager는 create_projectile(dto: ProjectileCreateDTO) -> Entity 메서드 포함",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "인프라 Manager 인터페이스 정의",
            "description": "ICoordinateManager, IDifficultyManager, IGameStateManager, IConfigurationManager 인터페이스를 ABC 기반으로 정의",
            "dependencies": [],
            "details": "각 인프라 Manager는 시스템 전반의 상태 관리를 담당. ICoordinateManager는 world_to_screen/screen_to_world 변환, IDifficultyManager는 게임 난이도 조절, IGameStateManager는 게임 상태 전환, IConfigurationManager는 설정 관리 메서드 포함",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "DTO 클래스들 설계 및 구현",
            "description": "EnemyCreateDTO, WeaponCreateDTO, ProjectileCreateDTO 등 데이터 전송 객체들을 pydantic 기반으로 구현",
            "dependencies": [
              "47.1"
            ],
            "details": "@dataclass와 pydantic 검증을 활용하여 타입 안전한 DTO 클래스들 구현. 각 DTO는 필수 필드와 선택적 필드를 명확히 구분하고, EnemyCreateDTO(enemy_type, position, health 등), WeaponCreateDTO(weapon_type, damage, synergy_items 등), ProjectileCreateDTO(projectile_type, start_pos, velocity 등) 포함",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "DTO 유효성 검증 및 ECS Component 변환 메서드 구현",
            "description": "각 DTO에 validate() 메서드와 ECS Component 변환 메서드들(to_enemy_component, to_weapon_component 등) 구현",
            "dependencies": [
              "47.3"
            ],
            "details": "모든 DTO는 validate() 메서드로 비즈니스 규칙 검증(예: 체력은 0 이상, 무기 타입은 유효한 WeaponType enum 값). ECS 변환 메서드는 DTO 데이터를 해당 Component 인스턴스로 변환하여 EntityManager에서 직접 사용 가능하도록 구현",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 48,
        "title": "Strategy Pattern 기반 공격/타겟팅 전략 구현",
        "description": "IAttackStrategy와 ITargetingStrategy 인터페이스 및 구체적인 전략들 구현",
        "details": "IAttackStrategy(calculate_projectile 메서드로 ProjectileCreateDTO 반환), ITargetingStrategy(select_primary_target, prioritize_targets 메서드) 인터페이스 정의. DirectAttackStrategy, AreaAttackStrategy, HomingAttackStrategy와 ClosestTargetingStrategy, LowestHealthTargetingStrategy, HighestThreatTargetingStrategy 구현. 모든 전략은 순수 함수로 구현하여 ECS Component 기반 계산 수행.",
        "testStrategy": "각 전략별 ProjectileCreateDTO 생성 테스트, 타겟 선택 알고리즘 정확성 테스트, 전략 교체 테스트, 성능 비교 테스트",
        "priority": "medium",
        "dependencies": [
          47
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "IAttackStrategy와 ITargetingStrategy 인터페이스 정의",
            "description": "공격 전략과 타겟팅 전략을 위한 추상 인터페이스 정의 및 타입 시스템 구축",
            "dependencies": [],
            "details": "IAttackStrategy 인터페이스에 calculate_projectile 메서드 정의 (ProjectileCreateDTO 반환). ITargetingStrategy 인터페이스에 select_primary_target, prioritize_targets 메서드 정의. 각 인터페이스는 ABC를 상속하여 구현하고, 필요한 DTO 클래스들(ProjectileCreateDTO 등)도 함께 정의. 모든 메서드는 순수 함수로 설계하여 ECS Component 데이터만을 매개변수로 받도록 구현.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "공격 전략 구현체 개발 (DirectAttackStrategy/AreaAttackStrategy/HomingAttackStrategy)",
            "description": "3가지 공격 패턴에 대한 구체적인 전략 클래스 구현",
            "dependencies": [
              "48.1"
            ],
            "details": "DirectAttackStrategy는 직선 공격용 ProjectileCreateDTO 계산. AreaAttackStrategy는 범위 공격용 다중 투사체 계산. HomingAttackStrategy는 추적 공격용 타겟 추적 로직 포함 투사체 생성. 각 전략은 WeaponComponent, PositionComponent 등 ECS 컴포넌트 데이터를 입력으로 받아 순수 함수 방식으로 ProjectileCreateDTO를 반환하도록 구현.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "타겟팅 전략 구현체 개발 (ClosestTargetingStrategy/LowestHealthTargetingStrategy/HighestThreatTargetingStrategy)",
            "description": "3가지 타겟 선택 알고리즘에 대한 구체적인 전략 클래스 구현",
            "dependencies": [
              "48.1"
            ],
            "details": "ClosestTargetingStrategy는 거리 기반 최적 타겟 선택. LowestHealthTargetingStrategy는 체력 기반 우선순위 계산. HighestThreatTargetingStrategy는 위협도 기반 타겟 우선순위 결정. 각 전략은 적 엔티티 목록과 플레이어 위치를 매개변수로 받아 select_primary_target으로 주 타겟을, prioritize_targets로 우선순위 정렬된 타겟 목록을 반환하도록 구현.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 49,
        "title": "Strategy Pattern 기반 스폰/이동 전략 구현",
        "description": "ISpawnStrategy와 IMovementStrategy 인터페이스 및 구체적인 전략들 구현",
        "details": "ISpawnStrategy(calculate_spawn 메서드로 EnemyCreateDTO 목록 반환), IMovementStrategy(calculate_movement 메서드로 VelocityComponent 반환) 인터페이스 정의. RandomSpawnStrategy, WaveSpawnStrategy, CircularSpawnStrategy와 DirectMovementStrategy, SmoothFollowStrategy, PatrolMovementStrategy 구현. 모든 전략은 ECS Component 기반으로 순수 계산 수행.",
        "testStrategy": "스폰 위치 계산 정확성 테스트, 이동 벡터 계산 테스트, 웨이브 패턴 및 순찰 패턴 동작 테스트, 전략별 성능 측정",
        "priority": "medium",
        "dependencies": [
          47
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ISpawnStrategy 및 IMovementStrategy 인터페이스 정의",
            "description": "Strategy 패턴 기반 스폰 및 이동 전략을 위한 추상 인터페이스 구현",
            "dependencies": [],
            "details": "ISpawnStrategy는 calculate_spawn(world_bounds, current_time, enemy_count) -> list[EnemyCreateDTO] 메서드 정의. IMovementStrategy는 calculate_movement(entity_position, target_position, delta_time) -> VelocityComponent 메서드 정의. 모든 전략이 순수 함수로 동작하도록 설계하여 ECS Component 기반 계산 수행.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "스폰 전략 구현 (Random/Wave/Circular)",
            "description": "RandomSpawnStrategy, WaveSpawnStrategy, CircularSpawnStrategy 세 가지 스폰 전략 구현",
            "dependencies": [
              "49.1"
            ],
            "details": "RandomSpawnStrategy는 맵 경계 내 무작위 위치 계산. WaveSpawnStrategy는 특정 방향에서 웨이브 형태로 스폰 위치 계산. CircularSpawnStrategy는 플레이어 중심으로 원형 패턴 스폰 위치 계산. 각 전략은 게임 시간과 현재 적 수를 고려하여 적절한 EnemyCreateDTO 목록 반환.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "이동 전략 구현 (Direct/SmoothFollow/Patrol)",
            "description": "DirectMovementStrategy, SmoothFollowStrategy, PatrolMovementStrategy 세 가지 이동 전략 구현",
            "dependencies": [
              "49.1"
            ],
            "details": "DirectMovementStrategy는 타겟 직선 이동 벡터 계산. SmoothFollowStrategy는 부드러운 추적을 위한 감쇠 계수 적용 이동 벡터 계산. PatrolMovementStrategy는 지정된 경로점들을 순환하는 순찰 이동 벡터 계산. 모든 전략은 VelocityComponent를 통해 일관된 인터페이스 제공.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 50,
        "title": "Domain Manager 구현체 개발",
        "description": "EnemyManager, WeaponManager, ProjectileManager의 구체적인 구현체 개발",
        "details": "각 Manager는 해당 인터페이스를 100% 구현하고 EntityManager와 ComponentRegistry를 활용하여 ECS 엔티티 관리. EnemyManager는 create_enemy로 필요한 모든 컴포넌트(EnemyComponent, PositionComponent, HealthComponent 등)를 자동 추가. WeaponManager는 시너지 계산 및 공격 쿨다운 관리. ProjectileManager는 물리 업데이트 및 충돌 처리 담당.",
        "testStrategy": "각 Manager별 CRUD 기능 테스트, DTO 기반 엔티티 생성 테스트, 컴포넌트 자동 추가 검증, Manager 간 독립성 테스트",
        "priority": "medium",
        "dependencies": [
          48,
          49
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EnemyManager 구현체 개발",
            "description": "IEnemyManager 인터페이스를 구현하여 적 엔티티 생성 및 컴포넌트 자동 추가 기능 개발",
            "dependencies": [],
            "details": "create_enemy 메서드로 EnemyCreateDTO를 받아 Entity 생성하고 EnemyComponent, PositionComponent, HealthComponent, VelocityComponent 등 필요한 컴포넌트들을 자동으로 추가. EntityManager와 ComponentRegistry를 활용한 CRUD 기능 구현. 적 타입별 차별화된 컴포넌트 설정 로직 포함.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "WeaponManager 구현체 개발",
            "description": "IWeaponManager 인터페이스를 구현하여 무기 시너지 계산 및 쿨다운 관리 기능 개발",
            "dependencies": [],
            "details": "시너지 아이템 조합에 따른 데미지 배율 계산, 공격 쿨다운 관리, WeaponCreateDTO 기반 무기 엔티티 생성. WeaponComponent, CooldownComponent 등을 자동 추가하고 아이템 시너지 로직을 통한 성능 향상 계산 구현.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "ProjectileManager 구현체 개발",
            "description": "IProjectileManager 인터페이스를 구현하여 발사체 물리 업데이트 및 충돌 처리 기능 개발",
            "dependencies": [],
            "details": "ProjectileCreateDTO 기반 발사체 엔티티 생성, ProjectileComponent와 PhysicsComponent 자동 추가. 발사체 궤도 계산, 충돌 감지, 생명주기 관리. 발사체 타입별(축구공, 농구공, 야구방망이) 차별화된 물리 속성 적용.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Manager 통합 및 ECS 연동 구현",
            "description": "모든 Manager들의 EntityManager/ComponentRegistry 연동 및 통합된 CRUD 기능 구현",
            "dependencies": [
              "50.1",
              "50.2",
              "50.3"
            ],
            "details": "각 Manager가 EntityManager와 ComponentRegistry를 공유하여 일관된 엔티티 관리. Manager 간 의존성 해결, 순환 참조 방지, 엔티티 생성/삭제 시 관련 Manager들 간의 동기화 보장. 성능 최적화를 위한 배치 처리 및 캐싱 메커니즘 구현.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 51,
        "title": "Strategy Pattern 적용 게임 시스템 구현",
        "description": "WeaponSystem, EnemySystem, ProjectileSystem을 전략 패턴이 적용된 IEventAwareSystem으로 구현",
        "details": "각 시스템은 IEventAwareSystem 인터페이스 구현하고 해당 Manager와 Strategy 인터페이스를 의존성 주입으로 받는다. WeaponSystem은 공격 조건 확인 후 Strategy로 ProjectileCreateDTO 계산하여 ProjectileManager에 전달. EnemySystem은 스폰 조건 확인 후 Strategy로 EnemyCreateDTO 계산. 모든 시스템은 이벤트 Producer를 통해 결과 이벤트 발행.",
        "testStrategy": "시스템별 update 사이클 테스트, 전략 패턴 적용 검증, 이벤트 발행 테스트, 런타임 전략 교체 테스트",
        "priority": "medium",
        "dependencies": [
          50
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "IEventAwareSystem 인터페이스 정의 및 기본 구조 설계",
            "description": "이벤트 인식 가능한 시스템의 기본 인터페이스를 정의하고 전략 패턴과 의존성 주입을 지원하는 추상 기반 클래스 구현",
            "dependencies": [],
            "details": "IEventAwareSystem 인터페이스에 update, initialize, cleanup 메서드 정의. 제네릭 타입 지원으로 다양한 전략 타입 수용. AbstractEventAwareSystem 기본 클래스로 공통 이벤트 Producer 관리 기능 제공. 의존성 주입을 위한 @dataclass 기반 설정 구조 포함.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "WeaponSystem 이벤트 인식 시스템 구현",
            "description": "공격 조건 확인 및 Strategy 활용하여 발사체 생성을 처리하는 WeaponSystem 구현",
            "dependencies": [
              "51.1"
            ],
            "details": "WeaponComponent 보유 엔티티 탐지, 공격 쿨다운 및 타겟 조건 확인. IAttackStrategy와 ITargetingStrategy 의존성 주입으로 받아 ProjectileCreateDTO 계산. ProjectileManager를 통한 발사체 생성 및 WeaponAttackEvent Producer로 공격 이벤트 발행. 런타임 전략 교체 지원.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EnemySystem 이벤트 인식 시스템 구현",
            "description": "적 스폰 조건 확인 및 Strategy를 활용한 적 생성 로직을 처리하는 EnemySystem 구현",
            "dependencies": [
              "51.1"
            ],
            "details": "게임 시간, 웨이브 진행도에 따른 스폰 조건 확인. ISpawnStrategy 의존성 주입으로 EnemyCreateDTO 목록 계산. EntityManager를 통한 적 엔티티 생성 및 EnemySpawnEvent Producer로 스폰 이벤트 발행. 난이도별 동적 전략 적용 지원.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ProjectileSystem 이벤트 인식 시스템 구현",
            "description": "발사체 이동, 충돌 처리, 생명주기 관리를 담당하는 ProjectileSystem 구현",
            "dependencies": [
              "51.1"
            ],
            "details": "ProjectileComponent 보유 엔티티의 이동 계산 및 위치 업데이트. 충돌 감지 시 데미지 적용 및 ProjectileHitEvent 발행. 발사체 수명 관리 및 제거 처리. IMovementStrategy 활용으로 다양한 발사체 움직임 패턴 지원.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "의존성 주입 및 이벤트 Producer 통합 시스템",
            "description": "모든 시스템에 필요한 Manager와 Strategy를 주입하고 이벤트 Producer를 통합 관리하는 시스템 구현",
            "dependencies": [
              "51.2",
              "51.3",
              "51.4"
            ],
            "details": "SystemOrchestrator에 의존성 주입 컨테이너 통합. 각 시스템별 필요한 Manager(ProjectileManager, EntityManager)와 Strategy 인터페이스 자동 주입. EventTunnelManager와 연동하여 시스템별 적절한 Producer 할당. 런타임 의존성 교체 및 시스템 재구성 지원.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 52,
        "title": "이벤트 기반 시스템 통합 및 EventTunnelManager 구현",
        "description": "모든 시스템을 이벤트 기반으로 통합하고 Producer-Consumer-Subscriber 터널 관리 시스템 완성",
        "details": "EventTunnelManager로 모든 이벤트 타입별 터널 관리(EnemyDeathEvent, WeaponAttackEvent, LevelUpEvent 등). 각 시스템이 적절한 Producer/Consumer/Subscriber를 획득하여 이벤트 기반 통신 수행. ExperienceSystem은 WeaponAttackEvent Consumer, UISystem은 모든 이벤트 Subscriber로 동작. 이벤트 플로우 end-to-end 검증.",
        "testStrategy": "이벤트 발행-소비-구독 전체 플로우 테스트, 터널별 격리 검증, 이벤트 유실 없음 확인, 시스템 간 비동기 통신 테스트",
        "priority": "medium",
        "dependencies": [
          51
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "EventTunnelManager 핵심 클래스 구현",
            "description": "이벤트 타입별 터널을 관리하는 EventTunnelManager 클래스와 기본 인터페이스 정의",
            "dependencies": [],
            "details": "EventTunnelManager 싱글톤 클래스 구현. 이벤트 타입별로 Producer/Consumer/Subscriber 인스턴스를 생성하고 관리하는 터널 시스템. 타입 안전성을 위한 제네릭 인터페이스와 이벤트 타입 등록/해제 기능 포함.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "핵심 이벤트 타입 클래스 정의",
            "description": "EnemyDeathEvent, WeaponAttackEvent, LevelUpEvent 등 게임 핵심 이벤트 타입 클래스 구현",
            "dependencies": [
              "52.1"
            ],
            "details": "BaseEvent를 상속받는 구체적인 이벤트 클래스들 정의. EnemyDeathEvent(entity_id, position, experience), WeaponAttackEvent(damage, target_id, weapon_type), LevelUpEvent(new_level, player_id) 등 게임 로직에 필요한 페이로드 포함.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Producer/Consumer/Subscriber 할당 시스템 구현",
            "description": "시스템별로 적절한 역할(Producer/Consumer/Subscriber)을 할당하는 자동화 시스템 구현",
            "dependencies": [
              "52.1",
              "52.2"
            ],
            "details": "SystemOrchestrator와 연동하여 각 시스템이 필요한 이벤트 역할을 자동 할당받는 시스템. 시스템 클래스의 메타데이터나 인터페이스 기반으로 Producer/Consumer/Subscriber 자격을 판단하고 EventTunnelManager에서 적절한 인스턴스 제공.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ExperienceSystem 이벤트 기반 리팩토링",
            "description": "ExperienceSystem을 WeaponAttackEvent Consumer로 동작하도록 리팩토링",
            "dependencies": [
              "52.2",
              "52.3"
            ],
            "details": "기존 ExperienceSystem을 이벤트 기반으로 변경. WeaponAttackEvent를 소비하여 경험치 계산 및 레벨업 처리. LevelUpEvent 발행 기능 추가. 비동기 이벤트 처리를 위한 큐 시스템 통합.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "UISystem 이벤트 기반 리팩토링",
            "description": "UISystem을 모든 게임 이벤트의 Subscriber로 동작하도록 리팩토리",
            "dependencies": [
              "52.2",
              "52.3"
            ],
            "details": "UISystem이 EnemyDeathEvent, WeaponAttackEvent, LevelUpEvent 등 모든 주요 게임 이벤트를 구독하여 UI 업데이트. 이벤트별 UI 반응 로직 구현 (데미지 표시, 경험치 바 업데이트, 레벨업 알림 등).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "이벤트 플로우 end-to-end 검증 시스템 구현",
            "description": "전체 이벤트 시스템의 동작을 검증하는 종합 테스트 및 모니터링 시스템 구현",
            "dependencies": [
              "52.4",
              "52.5"
            ],
            "details": "이벤트 발행부터 최종 소비까지 전체 플로우 추적 시스템. 이벤트 유실 감지, 처리 지연 모니터링, 시스템 간 통신 상태 확인. 개발/디버그 모드에서 이벤트 플로우 시각화 및 로깅 기능 포함.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 53,
        "title": "SystemOrchestrator 통합 및 성능 최적화",
        "description": "모든 시스템을 SystemOrchestrator로 관리하고 우선순위 기반 실행 순서 구현, 전체 성능 최적화",
        "details": "SystemOrchestrator에 모든 시스템 등록하고 SystemPriority 기반 실행 순서 결정(CRITICAL: 카메라/입력, HIGH: 물리/충돌, NORMAL: 게임플레이, LOW: 렌더링). 의존성 검증 및 토폴로지 정렬 구현. 시스템별 성능 통계 수집 및 모니터링. 60 FPS 목표 달성을 위한 최적화(적 100개 + 투사체 200개 상황).",
        "testStrategy": "시스템 실행 순서 검증, 의존성 순환 검출 테스트, 성능 목표 달성 검증(60 FPS), 메모리 사용량 모니터링, 장시간 실행 안정성 테스트",
        "priority": "low",
        "dependencies": [
          52
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "SystemOrchestrator에 모든 시스템 등록 및 우선순위 기반 실행 순서 구현",
            "description": "기존 시스템들을 SystemOrchestrator에 등록하고 SystemPriority 기반으로 실행 순서를 결정하는 알고리즘 구현",
            "dependencies": [],
            "details": "CRITICAL(카메라/입력), HIGH(물리/충돌), NORMAL(게임플레이), LOW(렌더링) 우선순위 설정. 모든 기존 시스템을 orchestrator에 등록하고 우선순위 기반 스케줄링 구현",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "시스템 의존성 검증 및 토폴로지 정렬 알고리즘 구현",
            "description": "시스템 간 의존성을 검증하고 순환 의존성을 검출하는 토폴로지 정렬 알고리즘 구현",
            "dependencies": [
              "53.1"
            ],
            "details": "의존성 그래프 생성, 순환 의존성 검출, 토폴로지 정렬을 통한 안전한 실행 순서 결정. 의존성 위반 시 명확한 에러 메시지 제공",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "시스템별 성능 통계 수집 시스템 구현",
            "description": "각 시스템의 실행 시간, 메모리 사용량, 호출 빈도 등을 수집하는 성능 모니터링 시스템 구현",
            "dependencies": [
              "53.2"
            ],
            "details": "시스템별 실행 시간 측정, 메모리 사용량 추적, 성능 병목지점 식별, 통계 데이터 저장 및 조회 인터페이스 제공",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "메모리 사용량 모니터링 및 최적화 시스템 구현",
            "description": "전체 게임의 메모리 사용량을 실시간 모니터링하고 메모리 누수를 감지하는 시스템 구현",
            "dependencies": [
              "53.3"
            ],
            "details": "실시간 메모리 사용량 추적, 메모리 누수 감지, 가비지 컬렉션 타이밍 최적화, 메모리 임계치 설정 및 경고 시스템",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "60 FPS 목표 성능 최적화 구현",
            "description": "적 100개 + 투사체 200개 상황에서 60 FPS 유지를 위한 성능 최적화 구현",
            "dependencies": [
              "53.4"
            ],
            "details": "프레임 시간 16.67ms 이하 유지, CPU 바운드 작업 최적화, 렌더링 배치 처리, 불필요한 계산 제거, 객체 풀링 적용",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "장시간 실행 안정성 보장 시스템 구현",
            "description": "게임이 장시간 실행되어도 안정적으로 동작하도록 보장하는 시스템 구현",
            "dependencies": [
              "53.5"
            ],
            "details": "메모리 누수 방지, 시스템 리소스 정리, 예외 처리 강화, 자동 복구 메커니즘, 장시간 테스트 자동화",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "통합 테스트 및 성능 벤치마크 구현",
            "description": "SystemOrchestrator 통합 후 전체 시스템의 성능 테스트 및 벤치마크 구현",
            "dependencies": [
              "53.6"
            ],
            "details": "60 FPS 달성 검증, 의존성 순환 검출 테스트, 시스템 실행 순서 검증, 장시간 안정성 테스트, 성능 회귀 방지 테스트",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-07T18:01:58.038Z",
      "updated": "2025-08-25T05:06:58.111Z",
      "description": "Tasks for master context"
    }
  }
}